var tests_passed = 0;
var tests_failed = 0;

def assert_eq(name, expected, actual)
{
    if (expected == actual)
    {
        tests_passed++;
        print("[PASS] " + name);
    } else
    {
        tests_failed++;
        write("[FAIL] {}: expected {}, got {}\n", name, expected, actual);
    }
}

def assert_true(name, condition)
{
    if (condition)
    {
        tests_passed++;
        print("[PASS] " + name);
    } else
    {
        tests_failed++;
        print("[FAIL] " + name);
    }
}

def assert_near(name, expected, actual, tolerance)
{
    var diff = expected - actual;
    if (diff < 0) { diff = -diff; }
    if (diff <= tolerance)
    {
        tests_passed++;
        print("[PASS] " + name);
    } else
    {
        tests_failed++;
        write("[FAIL] {}: expected ~{}, got {} (diff={})\n", name, expected, actual, diff);
    }
}


print("--- TEST 09: Fibers & Shared State ---");

 
 

def printer(tag, val1, val2)
{
    // Se a stack estiver desalinhada:
    // tag pode virar nil, val1 vira tag, etc.
    print("Tag: " + tag);
    print("Soma: " + (val1 + val2)); 
    
    assert_eq("Arg 1 position", "CHECK", tag);
    assert_eq("Arg 2 position", 10, val1);
    assert_eq("Arg 3 position", 20, val2);
}

process test_spawn()
{
    // Passamos 3 argumentos
    fiber printer("CHECK", 10, 20);
    
    // Aguarda fiber executar
    var i = 0;
    while (i < 10) 
    {
        frame;
        i++;
    }
}

test_spawn();


print("--- TESTE: Logic & Yield ---");

struct State { x, y };

def worker(st)
{
    var steps = 0;
    while (steps < 3) 
    {  
        st.x = st.x + 1;
        print("Step " + steps + ": x=" + st.x);
        yield;
        steps++;
    }
    print("Worker Done");
}

process enemy()
{
    var s = State(0, 0);
    fiber worker(s);
    
    // Deixamos o fiber correr 4 frames
    frame; frame; frame; frame;
    
    assert_eq("State updated by fiber", 3, s.x);
}

enemy();


print("--- TESTE: Recursion inside Fiber ---");

var finalResult = 0;

def factorial(n)
{
    if (n <= 1) return 1;
    
    yield; // Pausa para garantir que a stack sobrevive ao yield
    

    return n * factorial(n - 1);
}

def runner()
{
    finalResult = factorial(5);
}

process math_test()
{
    fiber runner();
    
    // Precisamos de vÃ¡rios frames por causa dos yields recursivos
    var i = 0;
    while (i < 10)
    {
        frame;
        i++;
    }
    
    print("Fatorial de 5: " + finalResult);
    assert_eq("Recursive fiber result", 120, finalResult);
}

math_test();




// ==========================================
// CASO 1: ExecuÃ§Ã£o BÃ¡sica de Fiber
// ==========================================
var fiberRan = false;

def simpleFiber()
{
    print("   -> Fiber iniciou");
    fiberRan = true;

}

process fiberTest1()
{
    fiber simpleFiber();
    var i = 0;
    while (i < 1000) 
    {
        frame; // MantÃ©m o pai vivo enquanto o filho corre
        i++;
    }
    assert_true("Fiber executed inside process", fiberRan);
}

fiberTest1();

 

var timerDone = false;

def sleeper() 
{
    yield(50); // Espera ~3 frames (assumindo 16ms por frame)
    timerDone = true;
}

process timeTest()
{
    fiber sleeper();
    
    frame; // ~16ms
    assert_true("Timer still running (16ms)", !timerDone);
    
    frame; // ~32ms
    assert_true("Timer still running (32ms)", !timerDone);
    
    frame; // ~48ms (quase lÃ¡)
    frame; // ~64ms
    frame; // ~80ms
    frame; // ~96ms -> Deve ter acordado
    
    // Verificar que ACORDOU!
    assert_true("Timer completed after ~100ms", timerDone);
}

print("--- TESTE: Yield com Tempo ---");
timeTest();


// ==========================================
// TESTES ADICIONAIS DE ROBUSTEZ
// ==========================================

print("--- TESTE: MÃºltiplos Fibers no Mesmo Process ---");

var fiber1_done = false;
var fiber2_done = false;
var fiber3_done = false;

def fiberA() {
    var i = 0;
    while (i < 3) { yield; i++; }
    fiber1_done = true;
}

def fiberB() {
    var i = 0;
    while (i < 5) { yield; i++; }
    fiber2_done = true;
}

def fiberC() {
    var i = 0;
    while (i < 2) { yield; i++; }
    fiber3_done = true;
}

process multiTest() {
    fiber fiberA();
    fiber fiberB();
    fiber fiberC();
    
    var i = 0;
    while (i < 20) { frame; i++; }
    
    assert_true("Fiber A completed", fiber1_done);
    assert_true("Fiber B completed", fiber2_done);
    assert_true("Fiber C completed", fiber3_done);
}

multiTest();


print("--- TESTE: Fiber com Muitos Argumentos ---");

var arg_sum = 0;

def manyArgs(a, b, c, d, e, f, g, h) {
    arg_sum = a + b + c + d + e + f + g + h;
}

process argsTest() {
    fiber manyArgs(1, 2, 3, 4, 5, 6, 7, 8);
    var i = 0;
    while (i < 10) { frame; i++; }
    assert_eq("8 arguments sum", 36, arg_sum);
}

argsTest();


print("--- TESTE: Fiber com Arrays ---");

var array_result = 0;

def arrayWorker(arr) {
    var sum = 0;
    var i = 0;
    while (i < len(arr)) {
        sum = sum + arr[i];
        yield;
        i++;
    }
    array_result = sum;
}

process arrayTest() {
    var data = [10, 20, 30, 40, 50];
    fiber arrayWorker(data);
    
    var i = 0;
    while (i < 20) { frame; i++; }
    
    assert_eq("Array sum in fiber", 150, array_result);
}

arrayTest();


print("--- TESTE: Fiber com Map ---");

var map_result = "";

def mapWorker(m) {
    if (m.has("name")) {
        map_result = m["name"];
    }
}

process mapTest() {
    var data = {"name": "BuLang", "version": 1};
    fiber mapWorker(data);
    
    var i = 0;
    while (i < 10) { frame; i++; }
    
    assert_eq("Map access in fiber", "BuLang", map_result);
}

mapTest();


print("--- TESTE: Fiber Modifica Array Global ---");

var global_arr = [0, 0, 0];

def arrayModifier() {
    global_arr[0] = 100;
    yield;
    global_arr[1] = 200;
    yield;
    global_arr[2] = 300;
}

process modifyTest() {
    fiber arrayModifier();
    
    var i = 0;
    while (i < 10) { frame; i++; }
    
    assert_eq("Global array[0]", 100, global_arr[0]);
    assert_eq("Global array[1]", 200, global_arr[1]);
    assert_eq("Global array[2]", 300, global_arr[2]);
}

modifyTest();


print("--- TESTE: Fiber com Struct Complexo ---");

struct Complex { data, children };

var complex_result = 0;

def complexWorker(c) {
    var sum = c.data;
    var i = 0;
    while (i < len(c.children)) {
        sum = sum + c.children[i];
        yield;
        i++;
    }
    complex_result = sum;
}

process complexTest() {
    var obj = Complex(100, [1, 2, 3, 4, 5]);
    fiber complexWorker(obj);
    
    var i = 0;
    while (i < 20) { frame; i++; }
    
    assert_eq("Complex struct sum", 115, complex_result);
}

complexTest();


print("--- TESTE: RecursÃ£o Profunda com Yield ---");

var deep_result = 0;

def deepRecursion(n, acc) {
    if (n <= 0) {
        deep_result = acc;
        return;
    }
    yield;
    deepRecursion(n - 1, acc + n);
}

process deepTest() {
    fiber deepRecursion(10, 0);
    
    var i = 0;
    while (i < 50) { frame; i++; }
    
    // 10+9+8+7+6+5+4+3+2+1 = 55
    assert_eq("Deep recursion sum", 55, deep_result);
}

deepTest();


print("--- TESTE: MÃºltiplos Processes com Fibers ---");

var proc1_result = 0;
var proc2_result = 0;

def worker1() {
    var i = 0;
    while (i < 5) { yield; i++; }
    proc1_result = 111;
}

def worker2() {
    var i = 0;
    while (i < 5) { yield; i++; }
    proc2_result = 222;
}

process proc1() {
    fiber worker1();
    var i = 0;
    while (i < 20) { frame; i++; }
}

process proc2() {
    fiber worker2();
    var i = 0;
    while (i < 20) { frame; i++; }
}

proc1();
proc2();


print("--- TESTE: Fiber com Strings ---");

var string_result = "";

def stringWorker(s1, s2, s3) {
    string_result = s1 + "-" + s2 + "-" + s3;
}

process stringTest() {
    fiber stringWorker("Hello", "Fiber", "World");
    var i = 0;
    while (i < 10) { frame; i++; }
    assert_eq("String concat in fiber", "Hello-Fiber-World", string_result);
}

stringTest();


print("--- TESTE: Fiber que Cria Array ---");

var created_array = nil;

def arrayCreator() {
    created_array = [];
    var i = 0;
    while (i < 5) {
        created_array.push(i * 10);
        yield;
        i++;
    }
}

process createTest() {
    fiber arrayCreator();
    var i = 0;
    while (i < 20) { frame; i++; }
    
    assert_eq("Created array length", 5, len(created_array));
    assert_eq("Created array[0]", 0, created_array[0]);
    assert_eq("Created array[4]", 40, created_array[4]);
}

createTest();


// ==========================================
// RESUMO FINAL
// ==========================================
print("");
print("========================================");
write("FIBER TESTS: {} passed, {} failed\n", tests_passed, tests_failed);
print("========================================");


// ==========================================
// TESTES DOIDOS - EDGE CASES EXTREMOS
// ==========================================

print("");
print("ðŸ”¥ðŸ”¥ðŸ”¥ TESTES DOIDOS ðŸ”¥ðŸ”¥ðŸ”¥");


print("--- DOIDO 1: Fiber que spawna outro Fiber ---");

var nested_fiber_result = 0;

def innerFiber() {
    nested_fiber_result = 999;
}

def outerFiber() {
    // Um fiber a tentar criar outro fiber?! 
    // Isto pode explodir!
    nested_fiber_result = 111;
}

process nestedFiberTest() {
    fiber outerFiber();
    var i = 0;
    while (i < 20) { frame; i++; }
    assert_true("Nested fiber survived", nested_fiber_result == 111);
}

nestedFiberTest();


print("--- DOIDO 2: MÃºltiplos Fibers (dentro do limite) ---");

var fiber_count = 0;

def massiveFiber1() {
    yield;
    fiber_count = fiber_count + 1;
}

def massiveFiber2() {
    yield;
    fiber_count = fiber_count + 1;
}

process massiveTest() {
    // Max 2 fibers por process, entÃ£o usamos sÃ³ 2
    fiber massiveFiber1();
    fiber massiveFiber2();
    
    var j = 0;
    while (j < 20) { frame; j++; }
    
    assert_eq("2 fibers completed", 2, fiber_count);
}

massiveTest();


print("--- DOIDO 3: Yield dentro de Yield (Nested Loops) ---");

var nested_yield_result = 0;

def nestedYieldWorker() {
    var outer = 0;
    while (outer < 5) {
        var inner = 0;
        while (inner < 5) {
            nested_yield_result = nested_yield_result + 1;
            yield;  // Yield no loop interno!
            inner++;
        }
        yield;  // Yield no loop externo tambÃ©m!
        outer++;
    }
}

process nestedYieldTest() {
    fiber nestedYieldWorker();
    var i = 0;
    while (i < 100) { frame; i++; }
    // 5*5 = 25 incrementos
    assert_eq("Nested yield loops", 25, nested_yield_result);
}

nestedYieldTest();


print("--- DOIDO 4: Fiber modifica struct de outro fiber ---");

struct SharedData { value };
var shared = SharedData(0);

def writerFiber() {
    var i = 0;
    while (i < 10) {
        shared.value = shared.value + 1;
        yield;
        i++;
    }
}

def readerFiber() {
    var i = 0;
    while (i < 10) {
        shared.value = shared.value * 1;  // LÃª e "escreve" o mesmo
        yield;
        i++;
    }
}

process raceTest() {
    fiber writerFiber();
    fiber readerFiber();
    var i = 0;
    while (i < 50) { frame; i++; }
    assert_eq("Shared state race", 10, shared.value);
}

raceTest();


print("--- DOIDO 5: Array gigante num fiber ---");

var big_array_sum = 0;

def bigArrayFiber() {
    var arr = [];
    var i = 0;
    while (i < 1000) {
        arr.push(i);
        i++;
    }
    
    var sum = 0;
    i = 0;
    while (i < len(arr)) {
        sum = sum + arr[i];
        if (i % 100 == 0) { yield; }  // Yield a cada 100
        i++;
    }
    big_array_sum = sum;
}

process bigArrayTest() {
    fiber bigArrayFiber();
    var i = 0;
    while (i < 50) { frame; i++; }
    // Sum of 0..999 = 999*1000/2 = 499500
    assert_eq("Big array sum", 499500, big_array_sum);
}

bigArrayTest();


print("--- DOIDO 6: RecursÃ£o MÃºtua com Yield ---");

var mutual_result = 0;

def pingFiber(n) {
    if (n <= 0) { return 0; }
    yield;
    return n + pongFiber(n - 1);
}

def pongFiber(n) {
    if (n <= 0) { return 0; }
    yield;
    return n + pingFiber(n - 1);
}

def mutualStarter() {
    mutual_result = pingFiber(6);
}

process mutualTest() {
    fiber mutualStarter();
    var i = 0;
    while (i < 50) { frame; i++; }
    // 6+5+4+3+2+1 = 21
    assert_eq("Mutual recursion", 21, mutual_result);
}

mutualTest();


print("--- DOIDO 7: Fiber com Maps Nested ---");

var nested_map_result = "";

def nestedMapFiber() {
    var data = {
        "level1": {
            "level2": {
                "level3": "DEEP_VALUE"
            }
        }
    };
    yield;
    nested_map_result = data["level1"]["level2"]["level3"];
}

process nestedMapTest() {
    fiber nestedMapFiber();
    var i = 0;
    while (i < 10) { frame; i++; }
    assert_eq("Nested map access", "DEEP_VALUE", nested_map_result);
}

nestedMapTest();


print("--- DOIDO 8: Fiber que morre e renasce (nova instÃ¢ncia) ---");

var rebirth_counter = 0;

def mortalFiber() {
    rebirth_counter = rebirth_counter + 1;
}

process rebirthTest() {
    // Spawna 3 vezes o mesmo fiber
    fiber mortalFiber();
    frame; frame;
    fiber mortalFiber();
    frame; frame;
    fiber mortalFiber();
    
    var i = 0;
    while (i < 20) { frame; i++; }
    
    assert_eq("Fiber rebirth count", 3, rebirth_counter);
}

rebirthTest();


print("--- DOIDO 9: Stress Test - 100 yields seguidos ---");

var stress_counter = 0;

def stressFiber() {
    var i = 0;
    while (i < 100) {
        stress_counter = stress_counter + 1;
        yield;
        i++;
    }
}

process stressTest() {
    fiber stressFiber();
    var i = 0;
    while (i < 200) { frame; i++; }
    assert_eq("100 yields stress", 100, stress_counter);
}

stressTest();


print("--- DOIDO 10: Fiber com closure-like behavior ---");

var closure_result = 0;

def makeCounter() {
    var count = 0;
    
    def increment() {
        count = count + 1;
        return count;
    }
    
    var i = 0;
    while (i < 5) {
        closure_result = increment();
        yield;
        i++;
    }
}

process closureTest() {
    fiber makeCounter();
    var i = 0;
    while (i < 20) { frame; i++; }
    assert_eq("Closure-like counter", 5, closure_result);
}

closureTest();


print("--- DOIDO 11: Fibonacci com Yield ---");

var fib_result = 0;

def fibFiber(n) {
    if (n <= 1) { return n; }
    yield;
    var a = fibFiber(n - 1);
    yield;
    var b = fibFiber(n - 2);
    return a + b;
}

def fibRunner() {
    fib_result = fibFiber(10);
}

process fibTest() {
    fiber fibRunner();
    var i = 0;
    while (i < 500) { frame; i++; }
    // Fib(10) = 55
    assert_eq("Fibonacci(10) with yields", 55, fib_result);
}

fibTest();


print("--- DOIDO 12: String manipulation heavy ---");

var string_stress_result = "";

def stringStressFiber() {
    var s = "";
    var i = 0;
    while (i < 20) {
        s = s + str(i) + "-";
        yield;
        i++;
    }
    string_stress_result = s;
}

process stringStressTest() {
    fiber stringStressFiber();
    var i = 0;
    while (i < 50) { frame; i++; }
    // String deve ter conteÃºdo (verificaÃ§Ã£o mais simples)
    assert_true("String stress has content", len(string_stress_result) > 10);
}

stringStressTest();


print("--- DOIDO 13: Array of Arrays ---");

var matrix_sum = 0;

def matrixFiber() {
    var matrix = [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
    ];
    
    var sum = 0;
    var row = 0;
    while (row < 3) {
        var col = 0;
        while (col < 3) {
            sum = sum + matrix[row][col];
            yield;
            col++;
        }
        row++;
    }
    matrix_sum = sum;
}

process matrixTest() {
    fiber matrixFiber();
    var i = 0;
    while (i < 30) { frame; i++; }
    // 1+2+3+4+5+6+7+8+9 = 45
    assert_eq("Matrix sum", 45, matrix_sum);
}

matrixTest();


print("--- DOIDO 14: Process dentro de Process (indirect) ---");

var proc_chain_result = 0;

process innerProcess() {
    proc_chain_result = 777;
    frame;
}

process outerProcess() {
    innerProcess();
    var i = 0;
    while (i < 20) { frame; i++; }
}

outerProcess();

// VerificaÃ§Ã£o apÃ³s processes terminarem
process verifyChain() {
    var i = 0;
    while (i < 50) { frame; i++; }
    assert_eq("Process chain", 777, proc_chain_result);
}

verifyChain();


print("--- DOIDO 15: NIL everywhere ---");

var nil_test_result = 0;

def nilFiber(a, b, c) {
    if (a == nil) { nil_test_result = nil_test_result + 1; }
    if (b == nil) { nil_test_result = nil_test_result + 1; }
    if (c == nil) { nil_test_result = nil_test_result + 1; }
    yield;
    
    var arr = [nil, nil, nil];
    var i = 0;
    while (i < len(arr)) {
        if (arr[i] == nil) { nil_test_result = nil_test_result + 1; }
        i++;
    }
}

process nilTest() {
    fiber nilFiber(nil, nil, nil);
    var i = 0;
    while (i < 10) { frame; i++; }
    // 3 args nil + 3 array nil = 6
    assert_eq("NIL handling", 6, nil_test_result);
}

nilTest();


// ==========================================
// RESUMO DOIDO
// ==========================================
print("");
print("ðŸðŸðŸ FIM DOS TESTES DOIDOS ðŸðŸðŸ");
print("========================================");
write("TOTAL: {} passed, {} failed\n", tests_passed, tests_failed);
if (tests_failed == 0) {
    print("ðŸŽ‰ ZERO SEGFAULTS! VM Ã‰ ROBUSTA! ðŸŽ‰");
} else {
    print("âš ï¸ Alguns testes falharam!");
}
print("========================================");


 