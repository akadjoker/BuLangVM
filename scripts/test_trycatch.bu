var tests_passed = 0;
var tests_failed = 0;

def assert_eq(name, expected, actual)
{
    if (expected == actual)
    {
        tests_passed++;
        print("[PASS] " + name);
    } else
    {
        tests_failed++;
        write("[FAIL] {}: expected {}, got {}\n", name, expected, actual);
    }
}

def assert_true(name, condition)
{
    if (condition)
    {
        tests_passed++;
        print("[PASS] " + name);
    } else
    {
        tests_failed++;
        print("[FAIL] " + name);
    }
}

def assert_near(name, expected, actual, tolerance)
{
    var diff = expected - actual;
    if (diff < 0) { diff = -diff; }
    if (diff <= tolerance)
    {
        tests_passed++;
        print("[PASS] " + name);
    } else
    {
        tests_failed++;
        write("[FAIL] {}: expected ~{}, got {} (diff={})\n", name, expected, actual, diff);
    }
}

var executedTry = false;
var executedCatch = false;

try {
    executedTry = true;
    var x = 10 + 10;
} catch (e) {
    executedCatch = true;
}

assert(executedTry, "Try block executed");
assert(!executedCatch, "Catch block skipped on success");

// ==========================================
// CASO 2: Erro de Runtime (Divisão por Zero)
// ==========================================
var successPath = false;
var catchPath = false;
var errorMsg = "";

try {
    // Forçar erro
    var a = 10;
    var b = 0;
    var c = a / b; // Deve lançar erro aqui
    
    successPath = true; // Esta linha NUNCA deve ser atingida
} catch (err) {
    catchPath = true;
    errorMsg = err; // Captura a mensagem de erro
    print("   -> Erro capturado: " + err);
}

assert(!successPath, "Execution stopped at error");
assert(catchPath, "Jumped to catch block");

// ==========================================
// CASO 3: Erro de Tipo (Type Error)
// ==========================================
var typeCatch = false;

try 
{
    var s = "texto";
    var n = s * 5; // erro 
} catch (e) {
    typeCatch = true;
}

assert(typeCatch, "Caught type error");

// ==========================================
// CASO 4: Acesso a Nulo
// ==========================================
var nilCatch = false;

try {
    var n = nil;
    var x = n + 10; // Operação ilegal com nil
} catch (e) {
    nilCatch = true;
}

assert(nilCatch, "Caught nil operation error");

// ==========================================
// CASO 5: Estado após Catch
// ==========================================
// Garante que a VM continua saudável para executar código normal
// depois de sair do bloco catch.

var afterValue = 0;
try {
    var boom = 10 / 0;
} catch (e) {
    // Recupera
}

afterValue = 100;
assert_eq(afterValue, 100, "VM continues execution after catch");

pass("08_try_catch.bu completed");