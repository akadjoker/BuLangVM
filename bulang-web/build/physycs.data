{
    "title": "Physycs",
    "width": 800,
    "height": 600,
    "background": "#1a1a2e"
}
// ============================================
// Demo Basico - Hello World com Raylib
// ============================================

import raylib;
using raylib;

// Cores
var white = Color(245, 245, 245, 255);
var darkGray = Color(80, 80, 80, 255);
var blue = Color(66, 135, 245, 255);
var red = Color(230, 80, 80, 255);

// Variaveis
var x = 400;
var y = 300;
var radius = 30;
var speed = 5;

// Inicializar janela
InitWindow(800, 600, "BuLang Web - Basic Demo");
SetTargetFPS(60);

// Game loop
while (!WindowShouldClose())
{
    // Input
    if (IsKeyDown(KEY_RIGHT)) x = x + speed;
    if (IsKeyDown(KEY_LEFT)) x = x - speed;
    if (IsKeyDown(KEY_DOWN)) y = y + speed;
    if (IsKeyDown(KEY_UP)) y = y - speed;

    // Limites
    if (x < radius) x = radius;
    if (x > 800 - radius) x = 800 - radius;
    if (y < radius) y = radius;
    if (y > 600 - radius) y = 600 - radius;

    // Desenhar
    BeginDrawing();
    ClearBackground(white);

    // Titulo
    DrawText("BuLang Web Demo", 280, 20, 30, darkGray);
    DrawText("Use arrow keys to move", 280, 60, 16, darkGray);

    // Circulo controlavel
    DrawCircle(x, y, radius, blue);
    DrawCircleLines(x, y, radius + 5, red);

    // FPS
    DrawFPS(10, 10);

    EndDrawing();
}

CloseWindow();
print("Demo finished!");
require "raylib";
import math;
import raylib;
using raylib;

var screenW = 800;
var screenH = 600;
var renderW = 400;
var renderH = 300;

InitWindow(screenW, screenH, "DOOM + Sprites");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var BLACK = Color(0, 0, 0, 255);
var RED = Color(255, 0, 0, 255);
var GREEN = Color(0, 255, 0, 255);
var BLUE = Color(0, 0, 255, 255);
var YELLOW = Color(255, 255, 0, 255);
var CYAN = Color(0, 255, 255, 255);
var MAGENTA = Color(255, 0, 255, 255);
var GRAY = Color(100, 100, 100, 255);

// ==========================================
// MAPA
// ==========================================
var mapW = 16;
var mapH = 16;

var worldMap = [];

var rows = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,2,2,2,0,0,0,0,3,3,3,0,0,1],
    [1,0,0,2,0,0,0,0,0,0,0,0,3,0,0,1],
    [1,0,0,2,0,0,0,0,0,0,0,0,3,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,3,0,0,0,0,0,0,0,0,2,0,0,1],
    [1,0,0,3,0,0,0,0,0,0,0,0,2,0,0,1],
    [1,0,0,3,3,3,0,0,0,0,2,2,2,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

for (var y = 0; y < mapH; y = y + 1)
{
    var row = rows[y];
    for (var x = 0; x < mapW; x = x + 1)
    {
        worldMap.push(row[x]);
    }
}

def getMap(x, y)
{
    if (x < 0 || x >= mapW || y < 0 || y >= mapH)
        return 1;
    return worldMap[y * mapW + x];
}

// ==========================================
// SPRITES
// ==========================================

struct Sprite
{
    var x, y;
    var color;
    var type; // 0 = inimigo, 1 = item
};

var sprites = [];

// Criar alguns sprites no mapa
var s1 = Sprite();
s1.x = 5.5;
s1.y = 5.5;
s1.color = RED;
s1.type = 0;
sprites.push(s1);

var s2 = Sprite();
s2.x = 10.5;
s2.y = 5.5;
s2.color = GREEN;
s2.type = 0;
sprites.push(s2);

var s3 = Sprite();
s3.x = 7.5;
s3.y = 10.5;
s3.color = CYAN;
s3.type = 1;
sprites.push(s3);

var s4 = Sprite();
s4.x = 12.5;
s4.y = 10.5;
s4.color = YELLOW;
s4.type = 0;
sprites.push(s4);

var s5 = Sprite();
s5.x = 3.5;
s5.y = 11.5;
s5.color = MAGENTA;
s5.type = 1;
sprites.push(s5);

// ==========================================
// PLAYER
// ==========================================

var posX = 4.0;
var posY = 8.0;
var dirX = -1.0;
var dirY = 0.0;
var planeX = 0.0;
var planeY = 0.66;

var moveSpeed = 0.08;
var rotSpeed = 0.04;

// ==========================================
// CORES DAS PAREDES
// ==========================================

def getWallColor(wallType, side, brightness)
{
    var baseColor;
    
    if (wallType == 1)
    {
        baseColor = Color(150, 50, 50, 255);
    }
    else if (wallType == 2)
    {
        baseColor = Color(50, 150, 50, 255);
    }
    else if (wallType == 3)
    {
        baseColor = Color(50, 50, 150, 255);
    }
    else if (wallType == 4)
    {
        baseColor = Color(150, 150, 50, 255);
    }
    else
    {
        baseColor = GRAY;
    }
    
    if (side == 1)
    {
        baseColor = Color(baseColor.r * 0.7, baseColor.g * 0.7, baseColor.b * 0.7, 255);
    }
    
    baseColor = Color(
        baseColor.r * brightness,
        baseColor.g * brightness,
        baseColor.b * brightness,
        255
    );
    
    return baseColor;
}

// ==========================================
// RAYCASTING
// ==========================================

var zBuffer = [];

def castRays(target)
{
    BeginTextureMode(target);
    
    // Céu
    DrawRectangle(0, 0, renderW, renderH / 2, Color(30, 30, 80, 255));
    
    // Chão
    DrawRectangle(0, renderH / 2, renderW, renderH / 2, Color(40, 40, 40, 255));
    
    // Limpar zBuffer
    zBuffer = [];
    for (var i = 0; i < renderW; i = i + 1)
    {
        zBuffer.push(0.0);
    }
    
    for (var x = 0; x < renderW; x = x + 1)
    {
        var cameraX = 2.0 * x / renderW - 1.0;
        var rayDirX = dirX + planeX * cameraX;
        var rayDirY = dirY + planeY * cameraX;

        var mapX = floor(posX);
        var mapY = floor(posY);
        
        var deltaDistX;
        var deltaDistY;

        if (rayDirX == 0.0) deltaDistX = 10000000.0;
        else deltaDistX = abs(1.0 / rayDirX);

        if (rayDirY == 0.0) deltaDistY = 10000000.0;
        else deltaDistY = abs(1.0 / rayDirY);
        
        var stepX, stepY;
        var sideDistX, sideDistY;
        
        if (rayDirX < 0.0)
        {
            stepX = -1;
            sideDistX = (posX - mapX) * deltaDistX;
        }
        else
        {
            stepX = 1;
            sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }
        
        if (rayDirY < 0.0)
        {
            stepY = -1;
            sideDistY = (posY - mapY) * deltaDistY;
        }
        else
        {
            stepY = 1;
            sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }
        
        var hit = 0;
        var side = 0;
        var wallType = 0;
        
        var steps = 0;
        while (hit == 0 && steps < 100)
        {
            steps = steps + 1;
            if (sideDistX < sideDistY)
            {
                sideDistX = sideDistX + deltaDistX;
                mapX = mapX + stepX;
                side = 0;
            }
            else
            {
                sideDistY = sideDistY + deltaDistY;
                mapY = mapY + stepY;
                side = 1;
            }
            
            if (mapX >= 0 && mapX < mapW && mapY >= 0 && mapY < mapH)
            {
                wallType = getMap(mapX, mapY);
                if (wallType > 0) hit = 1;
            }
            else
            {
                hit = 1;
                wallType = 1;
            }
        }
        
        var perpWallDist;
        if (side == 0)
        {
            if (abs(rayDirX) < 0.00001) perpWallDist = 0.00001;
            else perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
        }
        else
        {
            if (abs(rayDirY) < 0.00001) perpWallDist = 0.00001;
            else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;
        }
        
        if (perpWallDist <= 0.0001) perpWallDist = 0.0001;
        
        zBuffer[x] = perpWallDist;
        
        var lineHeight = floor(renderH / perpWallDist);
        
        var drawStart = -lineHeight / 2 + renderH / 2;
        if (drawStart < 0) drawStart = 0;
        
        var drawEnd = lineHeight / 2 + renderH / 2;
        if (drawEnd >= renderH) drawEnd = renderH - 1;
        
        var brightness = 1.0 / (1.0 + perpWallDist * perpWallDist * 0.02);
        if (brightness > 1.0) brightness = 1.0;
        
        var color = getWallColor(wallType, side, brightness);
        
        DrawLine(x, drawStart, x, drawEnd, color);
    }
    
    EndTextureMode();
}

// ==========================================
// SPRITE RENDERING (billboard)
// ==========================================

def drawSprites(target)
{
    BeginTextureMode(target);
    
    // Ordenar sprites por distância (painter's algorithm)
    var spriteOrder = [];
    var spriteDistance = [];
    
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        spriteOrder.push(i);
        var s = sprites[i];
        var dist = (posX - s.x) * (posX - s.x) + (posY - s.y) * (posY - s.y);
        spriteDistance.push(dist);
    }
    
    // Bubble sort (longe -> perto)
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        for (var j = i + 1; j < len(sprites); j = j + 1)
        {
            if (spriteDistance[i] < spriteDistance[j])
            {
                var tmpDist = spriteDistance[i];
                spriteDistance[i] = spriteDistance[j];
                spriteDistance[j] = tmpDist;
                
                var tmpOrder = spriteOrder[i];
                spriteOrder[i] = spriteOrder[j];
                spriteOrder[j] = tmpOrder;
            }
        }
    }
    
    // Desenhar sprites de trás para frente
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        var s = sprites[spriteOrder[i]];
        
        // Posição relativa ao player
        var spriteX = s.x - posX;
        var spriteY = s.y - posY;
        
        // Inverter matriz camera
        var invDet = 1.0 / (planeX * dirY - dirX * planeY);
        
        var transformX = invDet * (dirY * spriteX - dirX * spriteY);
        var transformY = invDet * (-planeY * spriteX + planeX * spriteY);
        
        // Sprite está atrás do player
        if (transformY <= 0.0)
        {
            continue;
        }
        
        var spriteScreenX = floor((renderW / 2) * (1.0 + transformX / transformY));
        
        var spriteHeight = abs(floor(renderH / transformY));
        var spriteWidth = abs(floor(renderH / transformY));
        
        var drawStartY = -spriteHeight / 2 + renderH / 2;
        if (drawStartY < 0) drawStartY = 0;
        
        var drawEndY = spriteHeight / 2 + renderH / 2;
        if (drawEndY >= renderH) drawEndY = renderH - 1;
        
        var drawStartX = -spriteWidth / 2 + spriteScreenX;
        if (drawStartX < 0) drawStartX = 0;
        
        var drawEndX = spriteWidth / 2 + spriteScreenX;
        if (drawEndX >= renderW) drawEndX = renderW - 1;
        
        // Desenhar sprite coluna por coluna
        for (var stripe = drawStartX; stripe < drawEndX; stripe = stripe + 1)
        {
            // Verificar zBuffer (sprite atrás de parede?)
            if (transformY < zBuffer[stripe])
            {
                // Desenhar "textura" do sprite (círculo simples)
                for (var y = drawStartY; y < drawEndY; y = y + 1)
                {
                    // Coordenadas normalizadas (-1 a 1)
                    var nx = (stripe - spriteScreenX) / (spriteWidth / 2.0);
                    var ny = (y - (drawStartY + drawEndY) / 2.0) / (spriteHeight / 2.0);
                    
                    var dist = sqrt(nx * nx + ny * ny);
                    
                    if (dist < 1.0) // Dentro do círculo
                    {
                        var brightness = 1.0 / (1.0 + transformY * transformY * 0.02);
                        if (brightness > 1.0) brightness = 1.0;
                        
                        var c = s.color;
                        var finalColor = Color(
                            c.r * brightness,
                            c.g * brightness,
                            c.b * brightness,
                            255
                        );
                        
                        // Borda mais escura
                        if (dist > 0.8)
                        {
                            finalColor = Color(
                                finalColor.r * 0.5,
                                finalColor.g * 0.5,
                                finalColor.b * 0.5,
                                255
                            );
                        }
                        
                        DrawPixel(stripe, y, finalColor);
                    }
                }
            }
        }
    }
    
    EndTextureMode();
}

// ==========================================
// MINIMAP
// ==========================================

def drawMinimap()
{
    var scale = 15;
    var offsetX = 10;
    var offsetY = 10;
    
    DrawRectangle(offsetX - 2, offsetY - 2, mapW * scale + 4, mapH * scale + 4, Color(0, 0, 0, 200));
    
    for (var y = 0; y < mapH; y = y + 1)
    {
        for (var x = 0; x < mapW; x = x + 1)
        {
            var tile = getMap(x, y);
            if (tile > 0)
            {
                var c = getWallColor(tile, 0, 0.5);
                DrawRectangle(offsetX + x * scale, offsetY + y * scale, scale - 1, scale - 1, c);
            }
        }
    }
    
    // Sprites no minimap
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        var s = sprites[i];
        DrawCircle(offsetX + s.x * scale, offsetY + s.y * scale, 3, s.color);
    }
    
    // Player
    var px = floor(posX * scale);
    var py = floor(posY * scale);
    DrawCircle(offsetX + px, offsetY + py, 3, RED);
    DrawLine(offsetX + px, offsetY + py, offsetX + px + dirX * 10, offsetY + py + dirY * 10, RED);
}

// ==========================================
// MAIN LOOP
// ==========================================

var target = LoadRenderTexture(renderW, renderH);
var src = Rectangle(0, 0, renderW, -renderH);
var dest = Rectangle(0, 0, screenW, screenH);
var origin = Vector2(0, 0);

while (!WindowShouldClose())
{
    // INPUT
    if (IsKeyDown(KEY_W))
    {
        if (getMap(floor(posX + dirX * moveSpeed), floor(posY)) == 0)
            posX = posX + dirX * moveSpeed;
        if (getMap(floor(posX), floor(posY + dirY * moveSpeed)) == 0)
            posY = posY + dirY * moveSpeed;
    }
    
    if (IsKeyDown(KEY_S))
    {
        if (getMap(floor(posX - dirX * moveSpeed), floor(posY)) == 0)
            posX = posX - dirX * moveSpeed;
        if (getMap(floor(posX), floor(posY - dirY * moveSpeed)) == 0)
            posY = posY - dirY * moveSpeed;
    }
    
    if (IsKeyDown(KEY_A))
    {
        var oldDirX = dirX;
        dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
        dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
        
        var oldPlaneX = planeX;
        planeX = planeX * cos(rotSpeed) - planeY * sin(rotSpeed);
        planeY = oldPlaneX * sin(rotSpeed) + planeY * cos(rotSpeed);
    }
    
    if (IsKeyDown(KEY_D))
    {
        var oldDirX = dirX;
        dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
        dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
        
        var oldPlaneX = planeX;
        planeX = planeX * cos(-rotSpeed) - planeY * sin(-rotSpeed);
        planeY = oldPlaneX * sin(-rotSpeed) + planeY * cos(-rotSpeed);
    }
    
    // RENDER
    castRays(target);
    drawSprites(target);
    
    BeginDrawing();
    ClearBackground(BLACK);
    
    var tex = GetRenderTextureTexture(target);
    DrawTexturePro(tex, src, dest, origin, 0.0, WHITE);
    
    drawMinimap();
    
    DrawText("WASD = Move | Sprites!", 10, screenH - 30, 16, WHITE);
    DrawText(format("Sprites: {}", len(sprites)), 10, screenH - 50, 14, WHITE);
    DrawFPS(screenW - 100, 10);
    
    EndDrawing();
}

CloseWindow();require "raylib";

import math;
import raylib;
using raylib;

include "vec2.bu";
include "quadtree.bu";

InitWindow(800, 600, "Physics Engine");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var BLACK = Color(0, 0, 0, 255);
var RED = Color(255, 100, 100, 255);
var GREEN = Color(100, 255, 100, 255);
var BLUE = Color(100, 100, 255, 255);
var YELLOW = Color(255, 255, 100, 255);
var GRAY = Color(80, 80, 80, 255);
var LIME = Color(0, 158, 47, 255);

var GRAVITY = 500.0;

// ==========================================
// RIGID BODY
// ==========================================
struct Contact
{
    var bodyA;
    var bodyB;
    var manifold; 
};

struct RigidBody
{
    var type;
    var pos;
    var vel;
    var angle;
    var angularVel;
    
    var mass;
    var invMass;
    var inertia;
    var invInertia;
    
    var restitution;
    var friction;
    
    var radius;
    var vertices;
    
    var color;
    var isStatic;
    var bounds;

    var id;
};

def createCircle(x, y, radius, density)
{
    var body = RigidBody();
    body.type = 0;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id=0;
    body.radius = radius;
    
    var area = 3.14159 * radius * radius;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * radius * radius * 0.5;
    body.invInertia = 1.0 / body.inertia;
    
    body.restitution = 0.2;
    body.friction = 0.6;
    
    body.color = Color(100 + math.rand(155), 100 + math.rand(155), 100 + math.rand(155), 255);
    body.isStatic = false;
    body.bounds= Rect(x,y,radius,radius);
    
    return body;
}

def createBox(x, y, width, height, density)
{
    var body = RigidBody();
    body.type = 1;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id=0;
    var hw = width / 2.0;
    var hh = height / 2.0;
    
    body.vertices = [];
    body.vertices.push(Vec2(-hw, -hh));
    body.vertices.push(Vec2(hw, -hh));
    body.vertices.push(Vec2(hw, hh));
    body.vertices.push(Vec2(-hw, hh));
    
    
    var area = width * height;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    
   
    body.inertia = body.mass * (width * width + height * height) / 12.0 * 3.0;
    body.invInertia = 1.0 / body.inertia;
    
    body.restitution = 0.0;
    body.friction = 0.7;
    
    body.color = Color(100 + math.rand(155), 100 + math.rand(155), 100 + math.rand(155), 255);
    body.isStatic = false;
    body.bounds = Rect(0.0, 0.0, hw, hh);
    
    return body;
}

def createStaticBox(x, y, width, height)
{
    var body = createBox(x, y, width, height, 1.0);
    body.isStatic = true;
    body.invMass = 0.0;
    body.invInertia = 0.0;
    body.color = GRAY;
    body.bounds = Rect(0.0, 0.0, width, height);
    return body;
}

// ==========================================
// POLYGON HELPERS
// ==========================================

def getTransformedVertices(body)
{
    if (body.type != 1)
    {
        return [];
    }
    
    var transformed = [];
    var c = cos(body.angle);
    var s = sin(body.angle);
    
    for (var i = 0; i < len(body.vertices); i = i + 1)
    {
        var v = body.vertices[i];
        var rx = v.x * c - v.y * s;
        var ry = v.x * s + v.y * c;
        transformed.push(Vec2(rx + body.pos.x, ry + body.pos.y));
    }
    
    return transformed;
}

def calculateNormals(vertices)
{
    var normals = [];
    
    for (var i = 0; i < len(vertices); i = i + 1)
    {
        var v1 = vertices[i];
        var v2 = vertices[(i + 1) % len(vertices)];
        
        var edge = sub(v2, v1);
        var normal = normalize(perp(edge));
        normals.push(normal);
    }
    
    return normals;
}

// ==========================================
// CLIPPING (encontrar pontos de contacto REAIS!)
// ==========================================

def findContactPoints(vertsA, vertsB, normal)
{
    // Encontra a aresta de referência (mais perpendicular à normal)
    var maxProj = -999999.0;
    var refEdgeIdx = 0;
    var normalsA = calculateNormals(vertsA);
    
    for (var i = 0; i < len(normalsA); i = i + 1)
    {
        var proj = dot(normalsA[i], normal);
        if (proj > maxProj)
        {
            maxProj = proj;
            refEdgeIdx = i;
        }
    }
    
    var v1 = vertsA[refEdgeIdx];
    var v2 = vertsA[(refEdgeIdx + 1) % len(vertsA)];
    
    // Encontra os vértices de B que estão "dentro" (por trás da normal)
    var contacts = [];
    
    for (var i = 0; i < len(vertsB); i = i + 1)
    {
        var v = vertsB[i];
        var toV = sub(v, v1);
        var dist = dot(toV, normal);
        
        if (dist <= 0.01) // Pequena tolerância
        {
            contacts.push(v);
        }
    }
    
    // Se não encontrou nenhum vértice, tenta arestas
    if (len(contacts) == 0)
    {
        // Simplificação: usa o ponto mais próximo da aresta
        var midPoint = Vec2((v1.x + v2.x) / 2.0, (v1.y + v2.y) / 2.0);
        contacts.push(midPoint);
  
    }
    
    return contacts;
}

// ==========================================
// SAT COLLISION DETECTION
// ==========================================

struct Manifold
{
    var hasCollision;
    var normal;
    var penetration;
    var contacts; 
};


// Encontra o vértice mais extremo numa direção
def getSupport(vertices, dir)
{
    var bestProj = -999999.0;
    var bestVertex = vertices[0];
    
    for(var i = 0; i < len(vertices); i = i + 1)
    {
         var v = vertices[i];
         var proj = dot(v, dir);
         
         if (proj > bestProj) 
         { 
            bestProj = proj; 
            bestVertex = v; 
         }
    }
    return bestVertex;
}

def projectPolygon(vertices, axis)
{
    var min = dot(vertices[0], axis);
    var max = min;
    
    for (var i = 1; i < len(vertices); i = i + 1)
    {
        var p = dot(vertices[i], axis);
        if (p < min) min = p;
        if (p > max) max = p;
    }
    
    return [min, max];
}

def projectCircle(center, radius, axis)
{
    var p = dot(center, axis);
    return [p - radius, p + radius];
}

def checkCircleCircle(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    
    var delta = sub(b.pos, a.pos);
    var distSq = lengthSq(delta);
    var radiusSum = a.radius + b.radius;
    
    if (distSq >= radiusSum * radiusSum)
    {
        return manifold;
    }
    
    var dist = sqrt(distSq);
    
    manifold.hasCollision = true;
    manifold.penetration = radiusSum - dist;
    
    if (dist > 0.0001)
    {
        manifold.normal = normalize(delta);
    }
    else
    {
        manifold.normal = Vec2(1.0, 0.0);
    }
    
    manifold.contacts = [];
    manifold.contacts.push(add(a.pos, scale(manifold.normal, a.radius)));
    
    return manifold;
}
def checkPolygonPolygon(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    
    var vertsA = getTransformedVertices(a);
    var vertsB = getTransformedVertices(b);
    
    var normalsA = calculateNormals(vertsA);
    var normalsB = calculateNormals(vertsB);
    
    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);
    
    // 1. Testar eixos de A
    for (var i = 0; i < len(normalsA); i = i + 1)
    {
        var axis = normalsA[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }
    
    // 2. Testar eixos de B
    for (var i = 0; i < len(normalsB); i = i + 1)
    {
        var axis = normalsB[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }
    
    manifold.hasCollision = true;
    manifold.penetration = minOverlap;
    
    // 3. Orientar a normal de A para B
    var delta = sub(b.pos, a.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }
    manifold.normal = bestAxis;
    

    
    var dirToA = scale(manifold.normal, -1.0);
    var contactOnB = getSupport(vertsB, dirToA);
    
    // Opcional: Para ser mais estável, podemos ver se o ponto de A furou B
    // Mas para começar, apenas 1 ponto no array chega!
    manifold.contacts = [];
    manifold.contacts.push(contactOnB);
    
    return manifold;
}

def checkCirclePolygon(circle, poly)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    
    var verts = getTransformedVertices(poly);
    var normals = calculateNormals(verts);
    
    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);
    
    for (var i = 0; i < len(normals); i = i + 1)
    {
        var axis = normals[i];
        
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }
    
    var closestDist = 999999.0;
    var closestVert = verts[0];
    
    for (var i = 0; i < len(verts); i = i + 1)
    {
        var dist = lengthSq(sub(verts[i], circle.pos));
        if (dist < closestDist)
        {
            closestDist = dist;
            closestVert = verts[i];
        }
    }
    
    var toClosest = sub(closestVert, circle.pos);
    if (lengthSq(toClosest) > 0.0001)
    {
        var axis = normalize(toClosest);
        
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }
    
    manifold.hasCollision = true;
    manifold.penetration = minOverlap;
    
    var delta = sub(poly.pos, circle.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }
    
    manifold.normal = bestAxis;
    manifold.contacts = [];
    manifold.contacts.push(add(circle.pos, scale(bestAxis, circle.radius)));
    
    return manifold;
}

def checkCollision(a, b)
{
    if (a.type == 0 && b.type == 0)
    {
        return checkCircleCircle(a, b);
    }
    else if (a.type == 1 && b.type == 1)
    {
        return checkPolygonPolygon(a, b);
    }
    else if (a.type == 0 && b.type == 1)
    {
        return checkCirclePolygon(a, b);
    }
    else
    {
        var m = checkCirclePolygon(b, a);
        if (m.hasCollision)
        {
            m.normal = scale(m.normal, -1.0);
        }
        return m;
    }
}

// ==========================================
// COLLISION RESOLUTION
// ==========================================

def resolveCollision(a, b, manifold)
{
    if (a.isStatic && b.isStatic)
    {
        return;
    }
    
    // Positional correction
    var correction = scale(manifold.normal, manifold.penetration / (a.invMass + b.invMass) * 0.8);
    
    if (!a.isStatic)
    {
        a.pos = sub(a.pos, scale(correction, a.invMass));
    }
    if (!b.isStatic)
    {
        b.pos = add(b.pos, scale(correction, b.invMass));
    }
    
    // Resolver para CADA ponto de contacto!
    for (var c = 0; c < len(manifold.contacts); c = c + 1)
    {
        var contactPoint = manifold.contacts[c];
        
        var ra = sub(contactPoint, a.pos);
        var rb = sub(contactPoint, b.pos);
        
        var vaLinear = a.vel;
        var vbLinear = b.vel;
        
        var vaAngular = Vec2(-a.angularVel * ra.y, a.angularVel * ra.x);
        var vbAngular = Vec2(-b.angularVel * rb.y, b.angularVel * rb.x);
        
        var va = add(vaLinear, vaAngular);
        var vb = add(vbLinear, vbAngular);
        
        var rv = sub(vb, va);
        
        var velAlongNormal = dot(rv, manifold.normal);
        
        if (velAlongNormal > 0.0)
        {
            continue;
        }
        
        var e = min(a.restitution, b.restitution);
        
        var raCrossN = cross(ra, manifold.normal);
        var rbCrossN = cross(rb, manifold.normal);
        
        var invMassSum = a.invMass + b.invMass + 
                         raCrossN * raCrossN * a.invInertia + 
                         rbCrossN * rbCrossN * b.invInertia;
        
        var j = -(1.0 + e) * velAlongNormal;
        j = j / invMassSum;
        j = j / len(manifold.contacts); // Dividir impulso pelos contactos!
        
        var impulse = scale(manifold.normal, j);
        
        if (!a.isStatic)
        {
            a.vel = sub(a.vel, scale(impulse, a.invMass));
            a.angularVel = a.angularVel - cross(ra, impulse) * a.invInertia;
        }
        if (!b.isStatic)
        {
            b.vel = add(b.vel, scale(impulse, b.invMass));
            b.angularVel = b.angularVel + cross(rb, impulse) * b.invInertia;
        }
        
        // Fricção
        rv = sub(add(vbLinear, Vec2(-b.angularVel * rb.y, b.angularVel * rb.x)),
                 add(vaLinear, Vec2(-a.angularVel * ra.y, a.angularVel * ra.x)));
        
        var tangent = sub(rv, scale(manifold.normal, dot(rv, manifold.normal)));
        
        if (lengthSq(tangent) > 0.0001)
        {
            tangent = normalize(tangent);
            
            var raCrossT = cross(ra, tangent);
            var rbCrossT = cross(rb, tangent);
            
            var invMassSumT = a.invMass + b.invMass + 
                              raCrossT * raCrossT * a.invInertia + 
                              rbCrossT * rbCrossT * b.invInertia;
            
            var jt = -dot(rv, tangent);
            jt = jt / invMassSumT;
            jt = jt / len(manifold.contacts);
            
            var mu = sqrt(a.friction * a.friction + b.friction * b.friction);
            
            var frictionImpulse;
            if (abs(jt) < j * mu)
            {
                frictionImpulse = scale(tangent, jt);
            }
            else
            {
                frictionImpulse = scale(tangent, -j * mu);
            }
            
            if (!a.isStatic)
            {
                a.vel = sub(a.vel, scale(frictionImpulse, a.invMass));
                a.angularVel = a.angularVel - cross(ra, frictionImpulse) * a.invInertia;
            }
            if (!b.isStatic)
            {
                b.vel = add(b.vel, scale(frictionImpulse, b.invMass));
                b.angularVel = b.angularVel + cross(rb, frictionImpulse) * b.invInertia;
            }
        }
    }
}

// NOVA função apenas para impulsos
def resolveCollisionImpulse(a, b, manifold)
{
    if (a.isStatic && b.isStatic)
    {
        return;
    }
    

    for (var c = 0; c < len(manifold.contacts); c = c + 1)
    {
        var contactPoint = manifold.contacts[c];
        var ra = sub(contactPoint, a.pos);
        var rb = sub(contactPoint, b.pos);
        
        var vaLinear = a.vel;
        var vbLinear = b.vel;
        var vaAngular = Vec2(-a.angularVel * ra.y, a.angularVel * ra.x);
        var vbAngular = Vec2(-b.angularVel * rb.y, b.angularVel * rb.x);
        
        var va = add(vaLinear, vaAngular);
        var vb = add(vbLinear, vbAngular);
        var rv = sub(vb, va);
        
        var velAlongNormal = dot(rv, manifold.normal);
        
        if (velAlongNormal > 0.0)
        {
            continue;
        }
        
        // Resting contact: se velocidade é muito baixa, zero restitution
        var e = min(a.restitution, b.restitution);
        if (abs(velAlongNormal) < 50.0) // Threshold para "resting"
        {
            e = 0.0;
        }
        
        var raCrossN = cross(ra, manifold.normal);
        var rbCrossN = cross(rb, manifold.normal);
        var invMassSum = a.invMass + b.invMass +
                        raCrossN * raCrossN * a.invInertia +
                        rbCrossN * rbCrossN * b.invInertia;
        
        var j = -(1.0 + e) * velAlongNormal;
        j = j / invMassSum;
        j = j / len(manifold.contacts);
        
        var impulse = scale(manifold.normal, j);
        
        if (!a.isStatic)
        {
            a.vel = sub(a.vel, scale(impulse, a.invMass));
            a.angularVel = a.angularVel - cross(ra, impulse) * a.invInertia;
        }
        
        if (!b.isStatic)
        {
            b.vel = add(b.vel, scale(impulse, b.invMass));
            b.angularVel = b.angularVel + cross(rb, impulse) * b.invInertia;
        }
        
        // Fricção (mesmo código)
        rv = sub(add(vbLinear, Vec2(-b.angularVel * rb.y, b.angularVel * rb.x)),
                 add(vaLinear, Vec2(-a.angularVel * ra.y, a.angularVel * ra.x)));
        
        var tangent = sub(rv, scale(manifold.normal, dot(rv, manifold.normal)));
        if (lengthSq(tangent) > 0.0001)
        {
            tangent = normalize(tangent);
            var raCrossT = cross(ra, tangent);
            var rbCrossT = cross(rb, tangent);
            var invMassSumT = a.invMass + b.invMass +
                            raCrossT * raCrossT * a.invInertia +
                            rbCrossT * rbCrossT * b.invInertia;
            
            var jt = -dot(rv, tangent);
            jt = jt / invMassSumT;
            jt = jt / len(manifold.contacts);
            
            var mu = sqrt(a.friction * a.friction + b.friction * b.friction);
            var frictionImpulse;
            
            if (abs(jt) < j * mu)
            {
                frictionImpulse = scale(tangent, jt);
            }
            else
            {
                frictionImpulse = scale(tangent, -j * mu);
            }
            
            if (!a.isStatic)
            {
                a.vel = sub(a.vel, scale(frictionImpulse, a.invMass));
                a.angularVel = a.angularVel - cross(ra, frictionImpulse) * a.invInertia;
            }
            
            if (!b.isStatic)
            {
                b.vel = add(b.vel, scale(frictionImpulse, b.invMass));
                b.angularVel = b.angularVel + cross(rb, frictionImpulse) * b.invInertia;
            }
        }
    }
}

// ==========================================
// WORLD
// ==========================================

 

 
var IDS = 0;
var bodies = [];

// Dar ID único aos estáticos também
IDS = IDS + 1;
var ground = createStaticBox(400, 580, 800, 40);
ground.id = IDS;
bodies.push(ground);

IDS = IDS + 1;
var leftWall = createStaticBox(10, 300, 20, 600);
leftWall.id = IDS;
bodies.push(leftWall);

IDS = IDS + 1;
var rightWall = createStaticBox(790, 300, 20, 600);
rightWall.id = IDS;
bodies.push(rightWall);

IDS = IDS + 1;
var ramp = createStaticBox(300, 450, 200, 20);
ramp.id = IDS;
ramp.angle = -0.3;
bodies.push(ramp);

// ==========================================
// HELPERS
// ==========================================

def min(a, b)
{
    if (a < b) return a;
    return b;
}

def max(a, b)
{
    if (a > b) return a;
    return b;
}

def updateAABB(body)
{
    if (body.type == 0) // CIRCLE
    {
        // Centro + meia-largura/altura
        body.bounds.x = body.pos.x;
        body.bounds.y = body.pos.y;
        body.bounds.w = body.radius;
        body.bounds.h = body.radius;
    }
    else // BOX / POLYGON
    {
        var verts = getTransformedVertices(body);
        var minX = 999999.0;
        var maxX = -999999.0;
        var minY = 999999.0;
        var maxY = -999999.0;
        
        for(var i = 0; i < len(verts); i = i + 1)
        {
            var v = verts[i];
            if (v.x < minX) minX = v.x;
            if (v.x > maxX) maxX = v.x;
            if (v.y < minY) minY = v.y;
            if (v.y > maxY) maxY = v.y;
        }
        
        // Centro é a média dos extremos
        body.bounds.x = (minX + maxX) / 2.0;
        body.bounds.y = (minY + maxY) / 2.0;
        // Meia-largura e meia-altura
        body.bounds.w = (maxX - minX) / 2.0;
        body.bounds.h = (maxY - minY) / 2.0;
    }
}


// ==========================================
// MAIN LOOP
// ==========================================

var screenRect = Rect();
screenRect.x = 400; 
screenRect.y = 300;
screenRect.w = 400; 
screenRect.h = 300;

 

 

while (!WindowShouldClose())
{
    var dt = 1.0 / 60.0;
    
    // Spawn
    if (IsMouseButtonPressed(0))
    {
        var mx = GetMouseX();
        var my = GetMouseY();
        IDS = IDS + 1;
        
        var c = createCircle(mx, my, 15 + math.rand(25), 1.0);
        c.id = IDS;
        c.angularVel = (math.rand(100) - 50) / 50.0;
        bodies.push(c);
    }
    
    if (IsMouseButtonPressed(1))
    {
        var mx = GetMouseX();
        var my = GetMouseY();
        IDS = IDS + 1;
        
        var b = createBox(mx, my, 30 + math.rand(40), 30 + math.rand(40), 1.0);
        b.id = IDS;
        b.angle = (math.rand(360) / 360.0) * 6.28;
        b.angularVel = (math.rand(100) - 50) / 50.0;
        bodies.push(b);
    }
    
    // Physics step
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];
        
        if (!body.isStatic)
        {
            body.vel.y = body.vel.y + GRAVITY * dt;
            
            body.pos = add(body.pos, scale(body.vel, dt));
            body.angle = body.angle + body.angularVel * dt;
            
            body.vel = scale(body.vel, 0.998);
            body.angularVel = body.angularVel * 0.98;
            
            if (abs(body.angularVel) < 0.02)
            {
                body.angularVel = 0.0;
            }
        }
        
        updateAABB(body);
    }
    

    var qt = createQuadTree(screenRect, 4);
    
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        insertQT(qt, bodies[i]);
    }
    
  // Collision detection
    var contacts = [];
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var bodyA = bodies[i];
        var candidates = [];
        queryQT(qt, bodyA.bounds, candidates);
        
        for (var j = 0; j < len(candidates); j = j + 1)
        {
            var bodyB = candidates[j];
            
            
            if (bodyA.id != bodyB.id && bodyA.id < bodyB.id)
            {
                if (intersectsRect(bodyA.bounds, bodyB.bounds))
                {
                    var manifold = checkCollision(bodyA, bodyB);
                    if (manifold.hasCollision)
                    {
                        var c = Contact();
                        c.bodyA = bodyA;
                        c.bodyB = bodyB;
                        c.manifold = manifold;
                        contacts.push(c);
                    }
                }
            }
        }
    }

 

        // CORREÇÃO POSICIONAL - UMA VEZ ANTES DO SOLVER!
        for (var i = 0; i < len(contacts); i = i + 1)
        {
            var c = contacts[i];
            var a = c.bodyA;
            var b = c.bodyB;
            var manifold = c.manifold;
            
            if (!a.isStatic || !b.isStatic)
            {
                var percent = 0.4; // Bias reduzido (era 0.8)
                var slop = 0.05;   // Penetration allowance
                var correctionMag = max(manifold.penetration - slop, 0.0) / (a.invMass + b.invMass) * percent;
                var correction = scale(manifold.normal, correctionMag);
                
                if (!a.isStatic)
                {
                    a.pos = sub(a.pos, scale(correction, a.invMass));
                }
                if (!b.isStatic)
                {
                    b.pos = add(b.pos, scale(correction, b.invMass));
                }
            }
        }

 
    var solverIterations = 6; // Aumenta para 6
    for (var iter = 0; iter < solverIterations; iter = iter + 1)
    {
        for (var i = 0; i < len(contacts); i = i + 1)
        {
            var c = contacts[i];
            resolveCollisionImpulse(c.bodyA, c.bodyB, c.manifold);  
        }
    }

    
    
    // Render
    BeginDrawing();
    ClearBackground(Color(20, 20, 30, 255));
    
    drawQuadTree(qt);
    
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];
        
        if (body.type == 0)
        {
            DrawCircle(body.pos.x, body.pos.y, body.radius, body.color);
            DrawCircleLines(body.pos.x, body.pos.y, body.radius, WHITE);
            
            var ex = body.pos.x + cos(body.angle) * body.radius;
            var ey = body.pos.y + sin(body.angle) * body.radius;
            DrawLine(body.pos.x, body.pos.y, ex, ey, WHITE);
        }
        else
        {
            var verts = getTransformedVertices(body);
            
            for (var j = 0; j < len(verts); j = j + 1)
            {
                var v1 = verts[j];
                var v2 = verts[(j + 1) % len(verts)];
                
                DrawLine(v1.x, v1.y, v2.x, v2.y, body.color);
            }
        }
        
        // Debug AABB
         DrawRectangleLines(body.bounds.x - body.bounds.w, body.bounds.y - body.bounds.h, 
                            body.bounds.w * 2, body.bounds.h * 2, GREEN);
    }
    
    DrawText("Left Click: Circle | Right Click: Box", 10, 10, 20, WHITE);
    DrawText(format("Bodies: {} | Contacts: {}", len(bodies), len(contacts)), 10, 35, 16, GREEN);
    DrawFPS(700, 10);
    
    EndDrawing();
}

CloseWindow();require "raylib";

import math;
import raylib;

using raylib;

include "vec2.bu";
include "quadtree.bu";

InitWindow(600, 800, "BULang PINBALL - Flippers");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var RED = Color(255, 100, 100, 255);
var GREEN = Color(100, 255, 100, 255);
var YELLOW = Color(255, 255, 100, 255);
var GRAY = Color(80, 80, 80, 255);
var ORANGE = Color(255, 165, 0, 255);
var PURPLE = Color(200, 100, 255, 255);
var CYAN = Color(0, 255, 255, 255);

var GRAVITY = 600.0;

// ==========================================
// RIGID BODY
// ==========================================
struct Contact
{
    var bodyA;
    var bodyB;
    var manifold;
};

struct RigidBody
{
    var type;
    var pos;
    var vel;
    var angle;
    var angularVel;
    var mass;
    var invMass;
    var inertia;
    var invInertia;
    var restitution;
    var friction;
    var radius;
    var vertices;
    var color;
    var isStatic;
    var bounds;
    var id;
    var isBumper;
    var isFlipper;
    var pivot;
    var motorSpeed;
    var maxMotorTorque;
    var lowerAngleLimit;
    var upperAngleLimit;
};

def createCircle(x, y, radius, density)
{
    var body = RigidBody();
    body.type = 0;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;
    body.radius = radius;
    var area = 3.14159 * radius * radius;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * radius * radius * 0.5;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.7;
    body.friction = 0.2;
    body.color = WHITE;
    body.isStatic = false;
    body.bounds = Rect(x, y, radius, radius);
    body.isBumper = false;
    body.isFlipper = false;
    body.pivot = Vec2(0.0, 0.0);
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 0.0;
    body.lowerAngleLimit = 0.0;
    body.upperAngleLimit = 0.0;
    return body;
}

def createBox(x, y, width, height, density)
{
    var body = RigidBody();
    body.type = 1;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;

    var hw = width / 2.0;
    var hh = height / 2.0;
    body.vertices = [];
    body.vertices.push(Vec2(-hw, -hh));
    body.vertices.push(Vec2(hw, -hh));
    body.vertices.push(Vec2(hw, hh));
    body.vertices.push(Vec2(-hw, hh));

    var area = width * height;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * (width * width + height * height) / 12.0 * 3.0;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.0;
    body.friction = 0.7;
    body.color = GRAY;
    body.isStatic = false;
    body.bounds = Rect(0.0, 0.0, hw, hh);
    body.isBumper = false;
    body.isFlipper = false;
    body.pivot = Vec2(0.0, 0.0);
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 0.0;
    body.lowerAngleLimit = 0.0;
    body.upperAngleLimit = 0.0;
    return body;
}

def createStaticBox(x, y, width, height)
{
    var body = createBox(x, y, width, height, 1.0);
    body.isStatic = true;
    body.invMass = 0.0;
    body.invInertia = 0.0;
    body.color = GRAY;
    body.restitution = 0.8;
    body.friction = 0.1;

    body.bounds = Rect(0.0, 0.0, width, height);
    return body;
}
def createFlipper(pivotX, pivotY, width, height, isLeft)
{
    var body = RigidBody();
    body.type = 1;
    body.pivot = Vec2(pivotX, pivotY);
    body.pos = Vec2(pivotX, pivotY);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;

    var hw = width / 2.0;
    var hh = height / 2.0;

    body.vertices = [];
    if (isLeft)
    {
        body.vertices.push(Vec2(0.0, -hh));
        body.vertices.push(Vec2(width, -hh));
        body.vertices.push(Vec2(width, hh));
        body.vertices.push(Vec2(0.0, hh));

        // Left flipper: -30° to +30° (ajustado para bater melhor)
        body.angle = 0.52;  
        body.lowerAngleLimit = -0.52; 
        body.upperAngleLimit = 0.52; 
    }
    else
    {
        body.vertices.push(Vec2(-width, -hh));
        body.vertices.push(Vec2(0.0, -hh));
        body.vertices.push(Vec2(0.0, hh));
        body.vertices.push(Vec2(-width, hh));

        // Right flipper
        body.angle = -0.52; 
        body.lowerAngleLimit = -0.52;
        body.upperAngleLimit = 0.52;  
    }

    body.bounds = Rect(0.0, 0.0, hw, hh);

    // --- CORREÇÃO DE FÍSICA ---
    // Usamos uma massa fixa baixa para o jogo ser rápido
    body.mass = 20.0; 
    
    // invMass = 0 diz ao motor de física para NÃO mover a posição (pino)
    // Mas invInertia > 0 diz que PODE rodar
    body.invMass = 1.0 / body.mass;

    
    // Momento de inércia para um retângulo a rodar numa ponta (Axis Theorem seria melhor, mas Box chega)
    // Inertia = m * (w^2 + h^2) / 12
    body.inertia = body.mass * (width * width + height * height) / 12.0;
    body.invInertia = 1.0 / body.inertia;

    body.restitution = 0.9; // Menos elástico para não ser caótico
    body.friction = 0.8;    // Muita frição para "agarrar" a bola
    body.color = YELLOW;
    body.isStatic = false;  
    body.isBumper = false;
    body.isFlipper = true;

    
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 2000000.0; 

    return body;
}

// ==========================================
// POLYGON HELPERS
// ==========================================
def getTransformedVertices(body)
{
    if (body.type != 1)
    {
        return [];
    }

    var transformed = [];
    var c = cos(body.angle);
    var s = sin(body.angle);

    if (body.isFlipper)
    {
        for (var i = 0; i < len(body.vertices); i = i + 1)
        {
            var v = body.vertices[i];
            var rx = v.x * c - v.y * s;
            var ry = v.x * s + v.y * c;
            transformed.push(Vec2(rx + body.pivot.x, ry + body.pivot.y));
        }
    }
    else
    {
        for (var i = 0; i < len(body.vertices); i = i + 1)
        {
            var v = body.vertices[i];
            var rx = v.x * c - v.y * s;
            var ry = v.x * s + v.y * c;
            transformed.push(Vec2(rx + body.pos.x, ry + body.pos.y));
        }
    }

    return transformed;
}

def calculateNormals(vertices)
{
    var normals = [];
    for (var i = 0; i < len(vertices); i = i + 1)
    {
        var v1 = vertices[i];
        var v2 = vertices[(i + 1) % len(vertices)];
        var edge = sub(v2, v1);
        var normal = normalize(perp(edge));
        normals.push(normal);
    }
    return normals;
}

def getSupport(vertices, dir)
{
    var bestProj = -999999.0;
    var bestVertex = vertices[0];
    for(var i = 0; i < len(vertices); i = i + 1)
    {
        var v = vertices[i];
        var proj = dot(v, dir);
        if (proj > bestProj)
        {
            bestProj = proj;
            bestVertex = v;
        }
    }
    return bestVertex;
}

def projectPolygon(vertices, axis)
{
    var min = dot(vertices[0], axis);
    var max = min;
    for (var i = 1; i < len(vertices); i = i + 1)
    {
        var p = dot(vertices[i], axis);
        if (p < min) min = p;
        if (p > max) max = p;
    }
    return [min, max];
}

def projectCircle(center, radius, axis)
{
    var p = dot(center, axis);
    return [p - radius, p + radius];
}

// ==========================================
// SAT COLLISION
// ==========================================
struct Manifold
{
    var hasCollision;
    var normal;
    var penetration;
    var contacts;
};

def checkCircleCircle(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var delta = sub(b.pos, a.pos);
    var distSq = lengthSq(delta);
    var radiusSum = a.radius + b.radius;

    if (distSq >= radiusSum * radiusSum)
    {
        return manifold;
    }

    var dist = sqrt(distSq);
    manifold.hasCollision = true;
    manifold.penetration = radiusSum - dist;

    if (dist > 0.0001)
    {
        manifold.normal = normalize(delta);
    }
    else
    {
        manifold.normal = Vec2(1.0, 0.0);
    }

    manifold.contacts = [];
    manifold.contacts.push(add(a.pos, scale(manifold.normal, a.radius)));
    return manifold;
}

def checkPolygonPolygon(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var vertsA = getTransformedVertices(a);
    var vertsB = getTransformedVertices(b);
    var normalsA = calculateNormals(vertsA);
    var normalsB = calculateNormals(vertsB);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normalsA); i = i + 1)
    {
        var axis = normalsA[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    for (var i = 0; i < len(normalsB); i = i + 1)
    {
        var axis = normalsB[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(b.pos, a.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    var dirToA = scale(manifold.normal, -1.0);
    var contactOnB = getSupport(vertsB, dirToA);

    manifold.contacts = [];
    manifold.contacts.push(contactOnB);
    return manifold;
}

def checkCirclePolygon(circle, poly)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var verts = getTransformedVertices(poly);
    var normals = calculateNormals(verts);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normals); i = i + 1)
    {
        var axis = normals[i];
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    var closestDist = 999999.0;
    var closestVert = verts[0];
    for (var i = 0; i < len(verts); i = i + 1)
    {
        var dist = lengthSq(sub(verts[i], circle.pos));
        if (dist < closestDist)
        {
            closestDist = dist;
            closestVert = verts[i];
        }
    }

    var toClosest = sub(closestVert, circle.pos);
    if (lengthSq(toClosest) > 0.0001)
    {
        var axis = normalize(toClosest);
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(poly.pos, circle.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    manifold.contacts = [];
    manifold.contacts.push(add(circle.pos, scale(bestAxis, circle.radius)));
    return manifold;
}

def checkCollision(a, b)
{
    if (a.type == 0 && b.type == 0)
    {
        return checkCircleCircle(a, b);
    }
    else if (a.type == 1 && b.type == 1)
    {
        return checkPolygonPolygon(a, b);
    }
    else if (a.type == 0 && b.type == 1)
    {
        return checkCirclePolygon(a, b);
    }
    else
    {
        var m = checkCirclePolygon(b, a);
        if (m.hasCollision)
        {
            m.normal = scale(m.normal, -1.0);
        }
        return m;
    }
}

// ==========================================
// COLLISION RESOLUTION
// ==========================================
def resolveCollisionImpulse(a, b, manifold)
{
    if (a.isStatic && b.isStatic)
    {
        return;
    }

    for (var c = 0; c < len(manifold.contacts); c = c + 1)
    {
        var contactPoint = manifold.contacts[c];

        var centerA = a.pos;
        var centerB = b.pos;
        if (a.isFlipper) centerA = a.pivot;
        if (b.isFlipper) centerB = b.pivot;

        var ra = sub(contactPoint, centerA);
        var rb = sub(contactPoint, centerB);

        var vaLinear = a.vel;
        var vbLinear = b.vel;
        var vaAngular = Vec2(-a.angularVel * ra.y, a.angularVel * ra.x);
        var vbAngular = Vec2(-b.angularVel * rb.y, b.angularVel * rb.x);

        var va = add(vaLinear, vaAngular);
        var vb = add(vbLinear, vbAngular);
        var rv = sub(vb, va);

        var velAlongNormal = dot(rv, manifold.normal);

        if (velAlongNormal > 0.0)
        {
            continue;
        }

        var e = min(a.restitution, b.restitution);

        if (a.isBumper || b.isBumper)
        {
            e = 1.5;
        }
        else if (abs(velAlongNormal) < 50.0)
        {
            e = 0.0;
        }

        var raCrossN = cross(ra, manifold.normal);
        var rbCrossN = cross(rb, manifold.normal);
        var invMassSum = a.invMass + b.invMass +
                        raCrossN * raCrossN * a.invInertia +
                        rbCrossN * rbCrossN * b.invInertia;

        var j = -(1.0 + e) * velAlongNormal;
        j = j / invMassSum;
        j = j / len(manifold.contacts);

        var impulse = scale(manifold.normal, j);

        if (!a.isStatic)
        {
            a.vel = sub(a.vel, scale(impulse, a.invMass));
            a.angularVel = a.angularVel - cross(ra, impulse) * a.invInertia;
        }

        if (!b.isStatic)
        {
            b.vel = add(b.vel, scale(impulse, b.invMass));
            b.angularVel = b.angularVel + cross(rb, impulse) * b.invInertia;
        }

        // Fricção
        rv = sub(add(vbLinear, Vec2(-b.angularVel * rb.y, b.angularVel * rb.x)),
                 add(vaLinear, Vec2(-a.angularVel * ra.y, a.angularVel * ra.x)));

        var tangent = sub(rv, scale(manifold.normal, dot(rv, manifold.normal)));
        if (lengthSq(tangent) > 0.0001)
        {
            tangent = normalize(tangent);
            var raCrossT = cross(ra, tangent);
            var rbCrossT = cross(rb, tangent);
            var invMassSumT = a.invMass + b.invMass +
                            raCrossT * raCrossT * a.invInertia +
                            rbCrossT * rbCrossT * b.invInertia;

            var jt = -dot(rv, tangent);
            jt = jt / invMassSumT;
            jt = jt / len(manifold.contacts);

            var mu = sqrt(a.friction * a.friction + b.friction * b.friction);
            var frictionImpulse;

            if (abs(jt) < j * mu)
            {
                frictionImpulse = scale(tangent, jt);
            }
            else
            {
                frictionImpulse = scale(tangent, -j * mu);
            }

            if (!a.isStatic)
            {
                a.vel = sub(a.vel, scale(frictionImpulse, a.invMass));
                a.angularVel = a.angularVel - cross(ra, frictionImpulse) * a.invInertia;
            }

            if (!b.isStatic)
            {
                b.vel = add(b.vel, scale(frictionImpulse, b.invMass));
                b.angularVel = b.angularVel + cross(rb, frictionImpulse) * b.invInertia;
            }
        }
    }
}

// ==========================================
// MOTOR SIMULATION 
// ==========================================
def applyMotor(flipper, dt)
{
    if (!flipper.isFlipper) return;

    var targetAngle = flipper.motorSpeed;
    
    var angleError = targetAngle - flipper.angle;
    var desiredAngularVel = angleError * 60.0; 
    var angularError = desiredAngularVel - flipper.angularVel;
    
    var torque = angularError * flipper.inertia * 150.0;
    
    // Clamp torque
    if (torque > flipper.maxMotorTorque) torque = flipper.maxMotorTorque;
    if (torque < -flipper.maxMotorTorque) torque = -flipper.maxMotorTorque;
    
    // Apply torque
    flipper.angularVel = flipper.angularVel + torque * flipper.invInertia * dt;
    
    // Limites (SEM zerar angularVel!)
    if (flipper.angle < flipper.lowerAngleLimit)
    {
        flipper.angle = flipper.lowerAngleLimit;
    }
    if (flipper.angle > flipper.upperAngleLimit)
    {
        flipper.angle = flipper.upperAngleLimit;
    }
}



// Constraint para manter flipper no pivot
def constrainFlipperToPivot(flipper)
{
    if (!flipper.isFlipper) return;

    // Flipper NÃO se move linearmente! Apenas roda
    flipper.pos = flipper.pivot;
    flipper.vel = Vec2(0.0, 0.0);
}

// ==========================================
// HELPERS
// ==========================================
def min(a, b)
{
    if (a < b) return a;
    return b;
}

def max(a, b)
{
    if (a > b) return a;
    return b;
}

def updateAABB(body)
{
    if (body.type == 0)
    {
        body.bounds.x = body.pos.x;
        body.bounds.y = body.pos.y;
        body.bounds.w = body.radius;
        body.bounds.h = body.radius;
    }
    else
    {
        var verts = getTransformedVertices(body);
        var minX = 999999.0;
        var maxX = -999999.0;
        var minY = 999999.0;
        var maxY = -999999.0;

        for(var i = 0; i < len(verts); i = i + 1)
        {
            var v = verts[i];
            if (v.x < minX) minX = v.x;
            if (v.x > maxX) maxX = v.x;
            if (v.y < minY) minY = v.y;
            if (v.y > maxY) maxY = v.y;
        }

        body.bounds.x = (minX + maxX) / 2.0;
        body.bounds.y = (minY + maxY) / 2.0;
        body.bounds.w = (maxX - minX) / 2.0;
        body.bounds.h = (maxY - minY) / 2.0;
    }
}

// ==========================================
// WORLD SETUP
// ==========================================
var IDS = 0;
var bodies = [];
var score = 0;
var ball;
var flipperLeft;
var flipperRight;

def createWorld()
{

// Paredes
IDS = IDS + 1;
var leftWall = createStaticBox(15, 400, 30, 800);
leftWall.id = IDS;
bodies.push(leftWall);

IDS = IDS + 1;
var rightWall = createStaticBox(585, 400, 30, 800);
rightWall.id = IDS;
bodies.push(rightWall);

IDS = IDS + 1;
var topWall = createStaticBox(300, 15, 600, 30);
topWall.id = IDS;
bodies.push(topWall);

// Paredes inclinadas
IDS = IDS + 1;
var leftSlant = createStaticBox(100, 100, 140, 15);
leftSlant.angle = 0.6;
leftSlant.id = IDS;
bodies.push(leftSlant);

IDS = IDS + 1;
var rightSlant = createStaticBox(500, 100, 140, 15);
rightSlant.angle = -0.6;
rightSlant.id = IDS;
bodies.push(rightSlant);

// Flippers CORRIGIDOS!
IDS = IDS + 1;
flipperLeft = createFlipper(170, 700, 120, 16, true);
flipperLeft.id = IDS;
bodies.push(flipperLeft);


IDS = IDS + 1;
flipperRight = createFlipper(430, 700, 120, 16, false);
flipperRight.id = IDS;
bodies.push(flipperRight);

// Bumpers
IDS = IDS + 1;
var bumper1 = createCircle(200, 280, 30, 1.0);
bumper1.isStatic = true;
bumper1.invMass = 0.0;
bumper1.invInertia = 0.0;
bumper1.color = RED;
bumper1.isBumper = true;
bumper1.id = IDS;
bodies.push(bumper1);

IDS = IDS + 1;
var bumper2 = createCircle(400, 280, 30, 1.0);
bumper2.isStatic = true;
bumper2.invMass = 0.0;
bumper2.invInertia = 0.0;
bumper2.color = RED;
bumper2.isBumper = true;
bumper2.id = IDS;
bodies.push(bumper2);

IDS = IDS + 1;
var bumper3 = createCircle(300, 400, 30, 1.0);
bumper3.isStatic = true;
bumper3.invMass = 0.0;
bumper3.invInertia = 0.0;
bumper3.color = RED;
bumper3.isBumper = true;

bumper3.id = IDS;
bodies.push(bumper3);

// Obstáculos
IDS = IDS + 1;
var obstacle1 = createStaticBox(150, 500, 50, 12);
obstacle1.angle = 0.5;
obstacle1.id = IDS;
obstacle1.restitution = 0.9;
obstacle1.color = PURPLE;
 
bodies.push(obstacle1);

IDS = IDS + 1;
var obstacle2 = createStaticBox(450, 500, 50, 12);
obstacle2.angle = -0.5;
obstacle2.restitution = 0.9;
obstacle2.id = IDS;
obstacle2.color = PURPLE;
 
bodies.push(obstacle2);

// Bola
IDS = IDS + 1;
ball = createCircle(300, 200, 12, 1.0);
ball.id = IDS;
ball.color = CYAN;
ball.restitution = 0.9;
ball.friction = 0.02;
ball.mass = 1.0;
ball.invMass = 1.0 / ball.mass; 
bodies.push(ball);
}

def renderWorld()
{
      for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];
        if (body.type == 0)
        {
            DrawCircle(body.pos.x, body.pos.y, body.radius, body.color);

            if (body.isBumper)
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 5, ORANGE);
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 8, ORANGE);
            }
            else
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius, WHITE);
            }
        }
        else
        {
            var verts = getTransformedVertices(body);
            for (var j = 0; j < len(verts); j = j + 1)
            {
                var v1 = verts[j];
                var v2 = verts[(j + 1) % len(verts)];
                DrawLineEx(v1.x, v1.y      ,v2.x, v2.y, 5.0, body.color);
            }

            if (body.isFlipper)
            {
                DrawCircle(body.pivot.x, body.pivot.y, 7, GREEN);
                DrawCircleLines(body.pivot.x, body.pivot.y, 10, WHITE);
            }
        }
    }
}




// ==========================================
// MAIN LOOP
// ==========================================
var screenRect = Rect();
screenRect.x = 300;
screenRect.y = 400;
screenRect.w = 300;
screenRect.h = 400;
createWorld();
var ballRef = ball;

while (!WindowShouldClose())
{
    var dt = 1.0 / 60.0;

   // Motor control
 
if (IsKeyDown(KEY_A) || IsKeyDown(KEY_LEFT))
{
    flipperLeft.motorSpeed = flipperLeft.lowerAngleLimit;  
}
else
{
    flipperLeft.motorSpeed = flipperLeft.upperAngleLimit;  
}

if (IsKeyDown(KEY_D) || IsKeyDown(KEY_RIGHT))
{
    flipperRight.motorSpeed = flipperRight.upperAngleLimit;   
}
else
{
    flipperRight.motorSpeed = flipperRight.lowerAngleLimit;   
}



    // Nova bola
    if (IsKeyPressed(KEY_SPACE))
    {
        ballRef.pos.x = 550.0;
        ballRef.pos.y = 100.0;
        ballRef.vel = Vec2(-100.0, 0.0);
        ballRef.angularVel = 0.0;
    }

    // Physics step
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];

        if (body.isFlipper)
        {
            // Apply motor
            applyMotor(body, dt);

            // Update rotation
            body.angle = body.angle + body.angularVel * dt;

            // Damping
            body.angularVel = body.angularVel * 0.98;

            // Constraint ao pivot
            constrainFlipperToPivot(body);
        }
        else if (!body.isStatic)
        {
            body.vel.y = body.vel.y + GRAVITY * dt;
            body.pos = add(body.pos, scale(body.vel, dt));
            body.angle = body.angle + body.angularVel * dt;
            body.vel = scale(body.vel, 0.998);
            body.angularVel = body.angularVel * 0.98;

            if (abs(body.angularVel) < 0.02)
            {
                body.angularVel = 0.0;
            }
        }

        updateAABB(body);
    }

    // QuadTree
    var qt = createQuadTree(screenRect, 4);
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        insertQT(qt, bodies[i]);
    }

    // Collision detection
    var contacts = [];
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var bodyA = bodies[i];
        var candidates = [];
        queryQT(qt, bodyA.bounds, candidates);

        for (var j = 0; j < len(candidates); j = j + 1)
        {
            var bodyB = candidates[j];

            if (bodyA.id != bodyB.id && bodyA.id < bodyB.id)
            {
                if (intersectsRect(bodyA.bounds, bodyB.bounds))
                {
                    var manifold = checkCollision(bodyA, bodyB);
                    if (manifold.hasCollision)
                    {
                        var c = Contact();
                        c.bodyA = bodyA;
                        c.bodyB = bodyB;
                        c.manifold = manifold;
                        contacts.push(c);

                        // Score
                        if ((bodyA.isBumper || bodyB.isBumper) && 
                            (bodyA.id == ballRef.id || bodyB.id == ballRef.id))
                        {
                            score = score + 100;
                        }
                    }
                }
            }
        }
    }

 
    for (var i = 0; i < len(contacts); i = i + 1)
    {
        var c = contacts[i];
        var a = c.bodyA;
        var b = c.bodyB;
        var manifold = c.manifold;

        // Flippers não movem linearmente!
        var aCanMove = !a.isStatic ;
        var bCanMove = !b.isStatic ;

        if (aCanMove || bCanMove)
        {
            var percent = 0.4;
            var slop = 0.05;

            var totalInvMass = 0.0;
            if (aCanMove) totalInvMass = totalInvMass + a.invMass;
            if (bCanMove) totalInvMass = totalInvMass + b.invMass;

            if (totalInvMass > 0.0001)
            {
                var correctionMag = max(manifold.penetration - slop, 0.0) / totalInvMass * percent;
                var correction = scale(manifold.normal, correctionMag);

                if (aCanMove)
                {
                    a.pos = sub(a.pos, scale(correction, a.invMass));
                }
                if (bCanMove)
                {
                    b.pos = add(b.pos, scale(correction, b.invMass));
                }
            }
        }
    }

    // Solver
    var solverIterations = 6;
    for (var iter = 0; iter < solverIterations; iter = iter + 1)
    {
        for (var i = 0; i < len(contacts); i = i + 1)
        {
            var c = contacts[i];
            resolveCollisionImpulse(c.bodyA, c.bodyB, c.manifold);
        }
    }

    // Render
    BeginDrawing();
    ClearBackground(Color(10, 10, 20, 255));
   
    renderWorld();
  

    // UI
    DrawText("FLIPPER!", 20, 20, 32, YELLOW);
    DrawText(format("SCORE: {}", score), 20, 60, 28, GREEN);
    DrawText("A/LEFT - Left Flipper", 350, 20, 18, WHITE);
    DrawText("D/RIGHT - Right Flipper", 350, 45, 18, WHITE);
    DrawText("SPACE - Launch Ball", 350, 70, 18, CYAN);
    DrawFPS(10, 95);

    EndDrawing();
}

CloseWindow();// ============================================
// BULANG PLATFORMER - Main Game
// ============================================
require "raylib";
import math;
import raylib;
using raylib;

include "plataform/consts.bu";
include "plataform/platform.bu";
include "plataform/player.bu";


// ============================================
// GAME INITIALIZATION
// ============================================

InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "BuLang Platformer Engine");
SetTargetFPS(60);

// Create player
var player = Player(100, 100);

// Create platforms
var platforms = [];

// Ground
platforms.push(Platform(0, 410, 800, 40));

// Stairs
platforms.push(Platform(150, 360, 100, 15));
platforms.push(Platform(280, 310, 100, 15));
platforms.push(Platform(410, 260, 100, 15));

// Upper platforms
platforms.push(Platform(550, 210, 140, 15));
platforms.push(Platform(100, 180, 120, 15));
platforms.push(Platform(350, 130, 90, 15));

// Floating islands
platforms.push(Platform(600, 80, 80, 15));

// ============================================
// GAME LOOP
// ============================================

while (!WindowShouldClose()) 
{
    // UPDATE
    player.update(platforms);
    
    // DRAW
    BeginDrawing();
    ClearBackground(BLUE);
    
    // Draw platforms
    for (var i = 0; i < platforms.length(); i++) 
    {
        platforms[i].draw();
    }
    
    // Draw player
    player.draw();
    
    // UI
    DrawText("BuLang Platformer Engine", 10, 10, 18, WHITE);
    DrawText("WASD / Arrow Keys - Move", 10, 32, 14, WHITE);
    DrawText("SPACE - Jump (double jump!)", 10, 50, 14, WHITE);
    
    //DrawFps(SCREEN_WIDTH - 80, 10);
    
    EndDrawing();
}

CloseWindow();


 
// ============================================
// CONSTANTS - Game Configuration
// ============================================

// Colors
var WHITE = Color(255, 255, 255, 255);
var BLACK = Color(0, 0, 0, 255);
var RED = Color(255, 50, 50, 255);
var GREEN = Color(50, 220, 80, 255);
var BLUE = Color(100, 150, 255, 255);
var GRAY = Color(120, 120, 120, 255);
var DARK_GRAY = Color(80, 80, 80, 255);

// Keyboard Keys
var KEY_RIGHT = 262;
var KEY_LEFT = 263;
var KEY_UP = 265;
var KEY_DOWN = 264;
var KEY_SPACE = 32;
var KEY_W = 87;
var KEY_A = 65;
var KEY_S = 83;
var KEY_D = 68;

// Physics Constants
var GRAVITY = 0.6;
var MAX_FALL_SPEED = 20.0;
var JUMP_FORCE = -13.0;
var MOVE_SPEED = 4.5;
var FRICTION = 0.85;

// Screen
var SCREEN_WIDTH = 800;
var SCREEN_HEIGHT = 450;// ============================================
// PLATFORM CLASS - Static platforms
// ============================================

class Platform 
{
    var x, y, width, height;
    var color;
    var solid;
    
    def init(x, y, width, height) 
    {
        self.x = x;
        self.y = y;
        self.width = width;
        self.height = height;
        self.color = GRAY;
        self.solid = true;
    }
    
    def draw() 
    {
        DrawRectangle(self.x, self.y, self.width, self.height, self.color);
        DrawRectangle(self.x, self.y, self.width, 3, DARK_GRAY);
    }
    
    def getBounds() 
    {
        // Returns: x, y, width, height
        return self;
    }
}// ============================================
// PLAYER CLASS - Platformer character
// ============================================

class Player {
    var x, y;
    var velocityX, velocityY;
    var width, height;
    var grounded;
    var jumpCount;
    var maxJumps;
    var color;
    var facing;
    
    def init(startX, startY) {
        self.x = startX;
        self.y = startY;
        self.velocityX = 0;
        self.velocityY = 0;
        self.width = 28;
        self.height = 44;
        self.grounded = false;
        self.jumpCount = 0;
        self.maxJumps = 2;
        self.color = GREEN;
        self.facing = 1;
    }
    
    def handleInput() {
        var moveInput = 0;
        
        // Horizontal movement
        if (IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D)) {
            moveInput = 1;
            self.facing = 1;
        } else if (IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A)) {
            moveInput = -1;
            self.facing = -1;
        }
        
        // Apply movement with acceleration
        if (moveInput != 0) {
            self.velocityX = moveInput * MOVE_SPEED;
        } else {
            // Apply friction
            self.velocityX = self.velocityX * FRICTION;
            if (abs(self.velocityX) < 0.1) {
                self.velocityX = 0;
            }
        }
        
        // Jump
        if (IsKeyPressed(KEY_SPACE)) {
            if (self.grounded || self.jumpCount < self.maxJumps) {
                self.velocityY = JUMP_FORCE;
                self.jumpCount = self.jumpCount + 1;
                self.grounded = false;
            }
        }
    }
    
    def applyGravity() {
        self.velocityY = self.velocityY + GRAVITY;
        
        // Terminal velocity
        if (self.velocityY > MAX_FALL_SPEED) {
            self.velocityY = MAX_FALL_SPEED;
        }
    }
    
    def moveX() {
        self.x = self.x + self.velocityX;
    }
    
    def moveY() {
        self.y = self.y + self.velocityY;
    }
    
    def checkCollisionX(platforms) {
        for (var i = 0; i < platforms.length(); i++) {
            var platform = platforms[i];
            
            if (self.checkOverlap(platform)) {
                if (self.velocityX > 0) {
                    // Moving right - push left
                    self.x = platform.x - self.width;
                } else if (self.velocityX < 0) {
                    // Moving left - push right
                    self.x = platform.x + platform.width;
                }
                self.velocityX = 0;
            }
        }
    }
    
    def checkCollisionY(platforms) {
        self.grounded = false;
        
        for (var i = 0; i < platforms.length(); i++) {
            var platform = platforms[i];
            
            if (self.checkOverlap(platform)) {
                if (self.velocityY > 0) {
                    // Falling down - land on platform
                    self.y = platform.y - self.height;
                    self.velocityY = 0;
                    self.grounded = true;
                    self.jumpCount = 0;
                } else if (self.velocityY < 0) {
                    // Moving up - hit ceiling
                    self.y = platform.y + platform.height;
                    self.velocityY = 0;
                }
            }
        }
    }
    
    def checkOverlap(platform) {
        return self.x < platform.x + platform.width &&
               self.x + self.width > platform.x &&
               self.y < platform.y + platform.height &&
               self.y + self.height > platform.y;
    }
    
    def checkBounds() {
        // Left wall
        if (self.x < 0) {
            self.x = 0;
            self.velocityX = 0;
        }
        
        // Right wall
        if (self.x + self.width > SCREEN_WIDTH) {
            self.x = SCREEN_WIDTH - self.width;
            self.velocityX = 0;
        }
        
        // Death plane
        if (self.y > SCREEN_HEIGHT + 50) {
            self.respawn();
        }
    }
    
    def respawn() {
        self.x = 100;
        self.y = 100;
        self.velocityX = 0;
        self.velocityY = 0;
    }
    
    def update(platforms) {
        self.handleInput();
        self.applyGravity();
        
        // Move and check collisions separately for each axis
        self.moveX();
        self.checkCollisionX(platforms);
        
        self.moveY();
        self.checkCollisionY(platforms);
        
        self.checkBounds();
    }
    
    def draw() {
        // Body
        DrawRectangle(self.x, self.y, self.width, self.height, self.color);
        
        // Eyes
        var eyeOffset = 7;
        if (self.facing < 0) {
            eyeOffset = 15;
        }
        DrawRectangle(self.x + eyeOffset, self.y + 10, 5, 5, BLACK);
        DrawRectangle(self.x + eyeOffset + 9, self.y + 10, 5, 5, BLACK);
        
        // Grounded indicator (debug)
        if (self.grounded) {
            DrawCircle(self.x + 14, self.y - 8, 3, GREEN);
        }
    }
}struct Rect
{
    var x, y, w, h; // center x/y, half-width, half-height
};

def pointInRect(rect, px, py)
{
    return px >= rect.x - rect.w &&
           px <= rect.x + rect.w &&
           py >= rect.y - rect.h &&
           py <= rect.y + rect.h;
}

def intersectsRect(r1, r2)
{
    return !(r2.x - r2.w > r1.x + r1.w ||
             r2.x + r2.w < r1.x - r1.w ||
             r2.y - r2.h > r1.y + r1.h ||
             r2.y + r2.h < r1.y - r1.h);
}

struct QuadTree
{
    var boundary;
    var capacity;
    var bodies;
    var divided;
    
    var nw;
    var ne;
    var sw;
    var se;
};

def createQuadTree(boundary, capacity)
{
    var qt = QuadTree();
    qt.boundary = boundary;
    qt.capacity = capacity;
    qt.bodies = [];
    qt.divided = false;
    return qt;
}

def subdivide(qt)
{
    var x = qt.boundary.x;
    var y = qt.boundary.y;
    var w = qt.boundary.w / 2.0;
    var h = qt.boundary.h / 2.0;
    
    var ne = Rect(); 
    ne.x = x + w; 
    ne.y = y - h; 
    ne.w = w; 
    ne.h = h;
    qt.ne = createQuadTree(ne, qt.capacity);
    
    var nw = Rect(); 
    nw.x = x - w; 
    nw.y = y - h; 
    nw.w = w; 
    nw.h = h;
    qt.nw = createQuadTree(nw, qt.capacity);
    
    var se = Rect(); 
    se.x = x + w; 
    se.y = y + h; 
    se.w = w; 
    se.h = h;
    qt.se = createQuadTree(se, qt.capacity);
    
    var sw = Rect(); 
    sw.x = x - w; 
    sw.y = y + h; 
    sw.w = w; 
    sw.h = h;
    qt.sw = createQuadTree(sw, qt.capacity);
    
    qt.divided = true;
}

def insertQT(qt, body)
{
    
    if (!intersectsRect(qt.boundary, body.bounds))
    {
        return false;
    }
    
    // Se tem espaço e não dividiu, guarda aqui
    if (len(qt.bodies) < qt.capacity && !qt.divided)
    {
        qt.bodies.push(body);
        return true;
    }
    
    // Precisa dividir
    if (!qt.divided)
    {
        subdivide(qt);
    }
    
    // Tenta inserir nos filhos
    // IMPORTANTE: Um body pode estar em MÚLTIPLOS nós se cruzar fronteiras!
    var inserted = false;
    
    if (insertQT(qt.ne, body)) inserted = true;
    if (insertQT(qt.nw, body)) inserted = true;
    if (insertQT(qt.se, body)) inserted = true;
    if (insertQT(qt.sw, body)) inserted = true;
    
    // Se não couber em nenhum filho completamente, fica no pai
    if (!inserted)
    {
        qt.bodies.push(body);
        inserted = true;
    }
    
    return inserted;
}

def queryQT(qt, range, found)
{
    if (!intersectsRect(qt.boundary, range))
    {
        return;
    }
    
    // Adicionar TODOS os bodies deste nó que intersectam a range
    for (var i = 0; i < len(qt.bodies); i = i + 1)
    {
        var body = qt.bodies[i];
        
        // Verifica AABB overlap, não só o centro!
        if (intersectsRect(range, body.bounds))
        {
            // Evitar duplicados (body pode estar em múltiplos nós)
            var alreadyFound = false;
            for (var j = 0; j < len(found); j = j + 1)
            {
                if (found[j].id == body.id)
                {
                    alreadyFound = true;
                }
            }
            
            if (!alreadyFound)
            {
                found.push(body);
            }
        }
    }
    
    if (qt.divided)
    {
        queryQT(qt.nw, range, found);
        queryQT(qt.ne, range, found);
        queryQT(qt.sw, range, found);
        queryQT(qt.se, range, found);
    }
}

def drawQuadTree(qt)
{
    var b = qt.boundary;
    DrawRectangleLines(b.x - b.w, b.y - b.h, b.w * 2, b.h * 2, Color(255, 0, 0, 100));
    
    if (qt.divided)
    {
        drawQuadTree(qt.nw);
        drawQuadTree(qt.ne);
        drawQuadTree(qt.sw);
        drawQuadTree(qt.se);
    }
}// ============================================
// SPACE SHOOTER - Main
// ============================================
require "raylib";
import math;
import raylib;
using raylib;

 include "space_shooter/const.bu";
include "space_shooter/bullet.bu";
include "space_shooter/player.bu";
include "space_shooter/enemy.bu";
 
InitWindow(SCREEN_WIDTH, SCREEN_HEIGHT, "BuLang Space Shooter");
SetTargetFPS(60);

var player = SpaceShip(380, 350);
var enemies = [];

var BLACK = Color(0, 0, 0, 255);
var WHITE = Color(255, 255, 255, 255);

var spawnTimer = 0;
var spawnInterval = 60;  // Spawn a cada 1 segundo (60 frames)
var score = 0;

while (!WindowShouldClose()) 
{
    // Spawn enemies
    spawnTimer = spawnTimer + 1;
    if (spawnTimer >= spawnInterval) 
    {
        var enemyX = math.rand(770);  // Random X
        var enemy = Enemy(enemyX, -30);
        enemies.push(enemy);
        spawnTimer = 0;
    }
    

    if (IsKeyPressed(KEY_E)) {  // Tecla E
    for (var i = 0; i < 100; i++) {
        var x = math.rand(770);
        var y = math.rand(300) - 300;
        enemies.push(Enemy(x, y));
    }
    write("Spawned 100 enemies! Total: {}\n", enemies.length());
}
    
    // Update
    player.update();
    
    for (var i = 0; i < enemies.length(); i++) 
    {
        enemies[i].update();
    }
    
    // Collision detection
    player.checkBulletCollisions(enemies);
    
    // Remove inactive enemies (SWAP AND POP!)
    var i = 0;
    while (i < enemies.length()) 
    {
        var enemy = enemies[i];
        if (!enemy.active) 
        {
            score = score + 10;  // Score!
            
            // Swap and pop
            var lastIndex = enemies.length() - 1;
            if (i != lastIndex) 
            {
                enemies[i] = enemies[lastIndex];
            }
            enemies.pop();
        } else 
        {
            i = i + 1;
        }
    }
    
    // Draw
    BeginDrawing();
    ClearBackground(BLACK);
    
    // Draw enemies
    for (var i = 0; i < enemies.length(); i++) 
    {
        enemies[i].draw();
    }
    
    // Draw player
    player.draw();
    
    // UI
    DrawText("Space Shooter", 10, 10, 20, WHITE);
    DrawText("WASD - Move | SPACE - Shoot", 10, 35, 14, WHITE);
    DrawText(format("Score: {}", score), 10, 55, 16, WHITE);
    DrawText(format("Enemies: {}", enemies.length()), 10, 75, 14, WHITE);
    DrawFPS(SCREEN_WIDTH - 80, 10);
    
    EndDrawing();
}

CloseWindow();


// def testReturn() {
//     if (true) {
//         return;  // ← Crash também?
//     }
//     write("Never reached\n");
// }

// testReturn();


// def testCleanup() {
//     var i = 0;
//     while (i < 5) {
//         write("i={}\n", i);
//         var temp1 = 10;
//         var temp2 = 20;
//         i = i + 1;
//     }
//     write("Loop done\n");
//     return false;
// }

// testCleanup();
// write("After testCleanup\n");  // ← Crash aqui?


// // ============================================
// // TESTE SIMPLES: Classes + Arrays
// // ============================================

// class Item {
//     var id;
//     var value;
    
//     def init(id, value) {
//         self.id = id;
//         self.value = value;
//     }
    
//     def display() {
//       //  write("Item {} = {}\n", self.id, self.value);
//     }
// }

// class Container {
//     var name;
//     var items;
//     var count;
    
//     def init(name) {
//         self.name = name;
//         self.items = [];
//         self.count = 0;
//     }
    
//     def add(item) {
//         self.items.push(item);
//         self.count = self.count + 1;
//     }
    
//     def display() {
//        // write("Container '{}' has {} items:\n", self.name, self.count);
//         for (var i = 0; i < self.items.length(); i = i + 1) {
//           //  write("  ");
//             self.items[i].display();
//         }
//     }
    
//     def addMany(n) {
//         write("=== Adding {} items ===\n", n);
        
//         var i = 0;
//         while (i < n) {
//            // write("Loop i = {}\n", i);
            
//             var item = Item(i, i * 10);
//           //  write("Created item\n");
            
//             self.add(item);
//           //  write("Added item\n");
            
//             i = i + 1;
//            // write("Incremented to {}\n", i);
//         }
        
//         write("=== Done adding ===\n");
//     }
// }

// // ============================================
// // TESTE 1: Add manual
// // ============================================

// write("TEST 1: Manual add\n");
// var c1 = Container("Test1");

// c1.add(Item(1, 100));
// c1.add(Item(2, 200));
// c1.add(Item(3, 300));

// c1.display();

// // ============================================
// // TESTE 2: Add em loop simples (5 items)
// // ============================================

// write("\nTEST 2: Loop add (5 items)\n");
// var c2 = Container("Test2");

// for (var i = 0; i < 5; i = i + 1) {
//     c2.add(Item(i, i * 10));
// }

// c2.display();

// // ============================================
// // TESTE 3: Add dentro de método (10 items)
// // ============================================

// write("\nTEST 3: Method add (10 items)\n");
// var c3 = Container("Test3");
// c3.addMany(10);
// c3.display();

// // ============================================
// // TESTE 4: Add dentro de método (50 items) - STRESS!
// // ============================================

// write("\nTEST 4: Method add (50 items) - STRESS TEST\n");
// var c4 = Container("Test4");
// c4.addMany(50);
// c4.display();

// write("\n=== ALL TESTS PASSED ===\n");


// test_container_raylib.bu
 

// class Item {
//     var id, x, y;
    
//     def init(id, x, y) {
//         self.id = id;
//         self.x = x;
//         self.y = y;
//     }
    
//     def draw() {
//         DrawCircle(self.x, self.y, 5, RED);
//     }
// }

// class Container {
//     var items;
    
//     def init() {
//         self.items = [];
//     }
    
//     def add(item) {
//         self.items.push(item);
//     }
    
//     def addMany(n) {
//         var i = 0;
//         while (i < n) {
//             var item = Item(i, 100 + i * 10, 200);
//             self.add(item);
//             i = i + 1;
//         }
//     }
    
//     def draw() 
//     {
//         if (IsKeyDown(KEY_SPACE )) 
//         {
//               for(var i=0;i<10;i++)
//               {
//                     var item = Item(i, rand(0,800), rand(0,450));
//                     self.add(item);
//               }
//         }

//         for (var i = 0; i < self.items.length(); i = i + 1) {
//             self.items[i].draw();
//         }
//     }
// }

// InitWindow(800, 450, "Test");
// SetTargetFPS(60);

// var container = Container();

 
// write("Added 50 items OK!\n");

// while (!WindowShouldClose()) {
//     BeginDrawing();
//     ClearBackground(BLACK);
    
//     container.draw();
    


//     DrawText(format("Items: {}", container.items.length()), 10, 10, 20, WHITE);

    
//     EndDrawing();
// }

// CloseWindow();




// test_function_vars.bu



// write("\n=== Now testing in CLASS METHOD ===\n");

// var enemies = [];


// for (var i = 0; i < 300; i = i + 1)
// {
//     enemies.push(Enemy(0,0));
// }

// class Test 
// {
//         var bullets;
    
//         def init()
//         {
//             self.bullets=[];
//              for (var i = 0; i < 900; i = i + 1) 
//                 {
//                     self.bullets.push(Bullet(0,0));
//                 }
//         }

//     def run() 
//     {
       
         

//         for (var i = 0; i < self.bullets.length(); i = i + 1) 
//         {
//             var bullet = self.bullets[i];
//             write("Bullet = {}\n", bullet);
            
//             for (var j = 0; j < enemies.length(); j = j + 1) 
//             {
//                 var enemy = enemies[j];
//                 if (enemy.checkCollisionWithBullet(bullet))  
//                 { 
//                     write(" colission Enemy = {}\n", enemy);
//                      bullet.active = false;
//                      enemy.hit();
//                      break;
//                 }
//             }
//         }
//     }
// }

// var t = Test();
// t.run();// ============================================
// BULLET CLASS - Projectile
// ============================================

class Bullet {
    var x, y;
    var speed;
    var active;
    var width, height;
    
    def init(x, y) {
        self.x = x;
        self.y = y;
        self.speed = 8;
        self.active = true;
        self.width = 4;
        self.height = 12;
    }
    
    def update() {
        self.y = self.y - self.speed;
        
        // Sai do ecrã - desativa
        if (self.y < -20) {
            self.active = false;
        }
    }
    
    def draw() {
        // Bala amarela
        var YELLOW = Color(255, 255, 0, 255);
        DrawRectangle(self.x, self.y, self.width, self.height, YELLOW);
    }
}// ============================================
// CONSTANTS - Game Configuration
// ============================================

// Colors
var WHITE = Color(255, 255, 255, 255);
var BLACK = Color(0, 0, 0, 255);
var RED = Color(255, 50, 50, 255);
var GREEN = Color(50, 220, 80, 255);
var BLUE = Color(100, 150, 255, 255);
var GRAY = Color(120, 120, 120, 255);
var DARK_GRAY = Color(80, 80, 80, 255);

// Keyboard Keys
var KEY_RIGHT = 262;
var KEY_LEFT = 263;
var KEY_UP = 265;
var KEY_DOWN = 264;
var KEY_SPACE = 32;
var KEY_W = 87;
var KEY_A = 65;
var KEY_S = 83;
var KEY_D = 68;
var KEY_E = 69;
var KEY_B = 66;


// Physics Constants
var GRAVITY = 0.6;
var MAX_FALL_SPEED = 20.0;
var JUMP_FORCE = -13.0;
var MOVE_SPEED = 4.5;
var FRICTION = 0.85;

// Screen
var SCREEN_WIDTH = 800;
var SCREEN_HEIGHT = 450;


 // ============================================
// ENEMY CLASS - Alien ships
// ============================================

class Enemy {
    var x, y;
    var width, height;
    var speed;
    var health;
    var active;
    var color;
    
    def init(x, y) {
        self.x = x;
        self.y = y;
        self.width = 30;
        self.height = 30;
        self.speed = 2;
        self.health = 1;
        self.active = true;
        self.color = Color(255, 50, 50, 255);  // Vermelho
    }
    
    def update() {
        self.y = self.y + self.speed;
        
        // Saiu do ecrã
        if (self.y > 480) 
        {
            self.active = false;
        }
    }
    
    def draw() 
    {
        if (self.active) 
        {
            
        // Corpo
        DrawRectangle(self.x, self.y, self.width, self.height, self.color);
        
        // Olhos
        //var WHITE = Color(255, 255, 255, 255);
        DrawRectangle(self.x + 5, self.y + 8, 6, 6, WHITE);
        DrawRectangle(self.x + 19, self.y + 8, 6, 6, WHITE);
        
        // Pupila
        //var BLACK = Color(0, 0, 0, 255);
        DrawRectangle(self.x + 7, self.y + 10, 3, 3, BLACK);
        DrawRectangle(self.x + 21, self.y + 10, 3, 3, BLACK);
        
        }
    }
    
    def checkCollisionWithBullet(bullet) 
    {
        if (!self.active || !bullet.active) 
        {
            return false;
        }
        
        return bullet.x < self.x + self.width &&
               bullet.x + bullet.width > self.x &&
               bullet.y < self.y + self.height &&
               bullet.y + bullet.height > self.y;
    }
    
    def hit() {
        self.health = self.health - 1;
        if (self.health <= 0) {
            self.active = false;
        }
    }
}// ============================================
// PLAYER - Space ship
// ============================================

class SpaceShip {
    var x, y;
    var width, height;
    var speed;
    var bullets;
    var shootCooldown;
    var cooldownTimer;
 
    
    def init(x, y) {
        self.x = x;
        self.bullets = [];  
        self.y = y;
        self.width = 40;
        self.height = 50;
        self.speed = 5;
        self.shootCooldown = 10;  // Frames entre tiros
        self.cooldownTimer = 0;
    }

 

def shootSpread() {
    var i = 0;
    while (i < 50) {
        var bullet = Bullet(self.x + self.width / 2, self.y - 10);
     
         self.bullets.push(bullet);
        i = i + 1;
    }
}

    
    def handleInput() {
        // Movimento horizontal
        if (IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D)) {
            self.x = self.x + self.speed;
        }
        if (IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A)) {
            self.x = self.x - self.speed;
        }
        
        // Movimento vertical
        if (IsKeyDown(KEY_UP) || IsKeyDown(KEY_W)) {
            self.y = self.y - self.speed;
        }
        if (IsKeyDown(KEY_DOWN) || IsKeyDown(KEY_S)) {
            self.y = self.y + self.speed;
        }

        
        
        // Limites
        if (self.x < 0) { self.x = 0; }
        if (self.x > 760) { self.x = 760; }
        if (self.y < 0) { self.y = 0; }
        if (self.y > 400) { self.y = 400; }
        
        // Disparar
        if (self.cooldownTimer > 0) {
            self.cooldownTimer = self.cooldownTimer - 1;
        }
        
        if (IsKeyDown(KEY_B)) 
        {
            //self.shoot();
            self.shootSpread();  // BOOM! 50 balas!
            
        }
        if (IsKeyDown(KEY_SPACE) && self.cooldownTimer == 0) 
        {
            self.shoot();
 
            self.cooldownTimer = self.shootCooldown;
        }
    }
    
    def shoot() 
    {
        // Cria bala no centro da nave
        var bulletX = self.x + self.width / 2 - 2;
        var bulletY = self.y - 10;
        var bullet = Bullet(bulletX, bulletY);
        self.bullets.push(bullet);
    }
    
    def updateBullets() 
    {
        // Atualiza todas as balas
        for (var i = 0; i < self.bullets.length(); i++) 
        {
            var bullet = self.bullets[i];
            bullet.update();
           
        }
        
        // Remove balas inativas (SWAP AND POP!)
        var i = 0;
        while (i < self.bullets.length()) 
        {
            var bullet = self.bullets[i];
            if (!bullet.active) 
            {
                // Swap com última e pop
                var lastIndex = self.bullets.length() - 1;
                if (i != lastIndex) 
                {
                    self.bullets[i] = self.bullets[lastIndex];
                }
                self.bullets.pop();
            } else 
            {
                i = i + 1;
            }
        }
    }
    
    def update() 
    {
        self.handleInput();
        self.updateBullets();
    }
    
    def draw() 
    {
        // Nave verde
        var GREEN = Color(50, 255, 100, 255);
        var DARK_GREEN = Color(30, 180, 70, 255);
        
        // Corpo
        DrawRectangle(self.x, self.y, self.width, self.height, GREEN);
        
        // Cockpit
        DrawRectangle(self.x + 15, self.y + 10, 10, 15, DARK_GREEN);
        
        // Asas
        DrawRectangle(self.x - 10, self.y + 20, 10, 20, GREEN);
        DrawRectangle(self.x + 40, self.y + 20, 10, 20, GREEN);
        
        // Balas
        for (var i = 0; i < self.bullets.length(); i++) 
        {
            self.bullets[i].draw();
        }
    }
    
    def getBulletCount() 
    {
        return self.bullets.length();
    }
// def checkBulletCollisions(enemies) {
//     for (var i = 0; i < self.bullets.length(); i++) {
//         for (var j = 0; j < enemies.length(); j++) {
//             if (enemies[j].checkCollisionWithBullet(self.bullets[i])) {
//                 self.bullets[i].active = false;
//                 enemies[j].hit();
//                 break;  // 
//             }
//         }
//     }
// }
    def checkBulletCollisions(enemies) 
    {
        for (var i = 0; i < self.bullets.length(); i++) 
        {
            var bullet = self.bullets[i];
            
            for (var j = 0; j < enemies.length(); j++) 
            {
                var enemy = enemies[j];
                
                if (enemy.checkCollisionWithBullet(bullet)) 
                {
                    bullet.active = false;
                    enemy.hit();
                    
                    break;         
                }
            }
        }
    }
}
// ==========================================
// VECTOR MATH
// ==========================================

struct Vec2
{
    var x, y;
};

def add(a, b)
{
    return Vec2(a.x + b.x, a.y + b.y);
}

def sub(a, b)
{
    return Vec2(a.x - b.x, a.y - b.y);
}

def scale(v, s)
{
    return Vec2(v.x * s, v.y * s);
}

def dot(a, b)
{
    return a.x * b.x + a.y * b.y;
}

def cross(a, b)
{
    return a.x * b.y - a.y * b.x;
}



def lengthSq(v)
{
    return v.x * v.x + v.y * v.y;
}

def length(v)
{
    return sqrt(lengthSq(v));
}

def normalize(v)
{
    var LEN = length(v);
    if (LEN < 0.0001)
    {
        return Vec2(0.0, 0.0);
    }
    return Vec2(v.x / LEN, v.y / LEN);
}

def perp(v)
{
    return Vec2(-v.y, v.x);
}//include "demos/basic.bu";
//include "demos/doom.bu";
//include "demos/pinball.bu";
include "demos/physics.bu";
