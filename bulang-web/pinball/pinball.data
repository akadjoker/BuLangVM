{
    "title": "Pinball",
    "width": 800,
    "height": 600,
    "background": "#1a1a2e"
}
// ============================================
// Demo Basico - Hello World com Raylib
// ============================================

import raylib;
using raylib;

// Cores
var white = Color(245, 245, 245, 255);
var darkGray = Color(80, 80, 80, 255);
var blue = Color(66, 135, 245, 255);
var red = Color(230, 80, 80, 255);

// Variaveis
var x = 400;
var y = 300;
var radius = 30;
var speed = 5;

// Inicializar janela
InitWindow(800, 600, "BuLang Web - Basic Demo");
SetTargetFPS(60);

// Game loop
while (!WindowShouldClose())
{
    // Input
    if (IsKeyDown(KEY_RIGHT)) x = x + speed;
    if (IsKeyDown(KEY_LEFT)) x = x - speed;
    if (IsKeyDown(KEY_DOWN)) y = y + speed;
    if (IsKeyDown(KEY_UP)) y = y - speed;

    // Limites
    if (x < radius) x = radius;
    if (x > 800 - radius) x = 800 - radius;
    if (y < radius) y = radius;
    if (y > 600 - radius) y = 600 - radius;

    // Desenhar
    BeginDrawing();
    ClearBackground(white);

    // Titulo
    DrawText("BuLang Web Demo", 280, 20, 30, darkGray);
    DrawText("Use arrow keys to move", 280, 60, 16, darkGray);

    // Circulo controlavel
    DrawCircle(x, y, radius, blue);
    DrawCircleLines(x, y, radius + 5, red);

    // FPS
    DrawFPS(10, 10);

    EndDrawing();
}

CloseWindow();
print("Demo finished!");
require "raylib";
import math;
import raylib;
using raylib;

var screenW = 800;
var screenH = 600;
var renderW = 400;
var renderH = 300;

InitWindow(screenW, screenH, "DOOM + Sprites");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var BLACK = Color(0, 0, 0, 255);
var RED = Color(255, 0, 0, 255);
var GREEN = Color(0, 255, 0, 255);
var BLUE = Color(0, 0, 255, 255);
var YELLOW = Color(255, 255, 0, 255);
var CYAN = Color(0, 255, 255, 255);
var MAGENTA = Color(255, 0, 255, 255);
var GRAY = Color(100, 100, 100, 255);

// ==========================================
// MAPA
// ==========================================
var mapW = 16;
var mapH = 16;

var worldMap = [];

var rows = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,2,2,2,0,0,0,0,3,3,3,0,0,1],
    [1,0,0,2,0,0,0,0,0,0,0,0,3,0,0,1],
    [1,0,0,2,0,0,0,0,0,0,0,0,3,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,3,0,0,0,0,0,0,0,0,2,0,0,1],
    [1,0,0,3,0,0,0,0,0,0,0,0,2,0,0,1],
    [1,0,0,3,3,3,0,0,0,0,2,2,2,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

for (var y = 0; y < mapH; y = y + 1)
{
    var row = rows[y];
    for (var x = 0; x < mapW; x = x + 1)
    {
        worldMap.push(row[x]);
    }
}

def getMap(x, y)
{
    if (x < 0 || x >= mapW || y < 0 || y >= mapH)
        return 1;
    return worldMap[y * mapW + x];
}

// ==========================================
// SPRITES
// ==========================================

struct Sprite
{
    var x, y;
    var color;
    var type; // 0 = inimigo, 1 = item
};

var sprites = [];

// Criar alguns sprites no mapa
var s1 = Sprite();
s1.x = 5.5;
s1.y = 5.5;
s1.color = RED;
s1.type = 0;
sprites.push(s1);

var s2 = Sprite();
s2.x = 10.5;
s2.y = 5.5;
s2.color = GREEN;
s2.type = 0;
sprites.push(s2);

var s3 = Sprite();
s3.x = 7.5;
s3.y = 10.5;
s3.color = CYAN;
s3.type = 1;
sprites.push(s3);

var s4 = Sprite();
s4.x = 12.5;
s4.y = 10.5;
s4.color = YELLOW;
s4.type = 0;
sprites.push(s4);

var s5 = Sprite();
s5.x = 3.5;
s5.y = 11.5;
s5.color = MAGENTA;
s5.type = 1;
sprites.push(s5);

// ==========================================
// PLAYER
// ==========================================

var posX = 4.0;
var posY = 8.0;
var dirX = -1.0;
var dirY = 0.0;
var planeX = 0.0;
var planeY = 0.66;

var moveSpeed = 0.08;
var rotSpeed = 0.04;

// ==========================================
// CORES DAS PAREDES
// ==========================================

def getWallColor(wallType, side, brightness)
{
    var baseColor;
    
    if (wallType == 1)
    {
        baseColor = Color(150, 50, 50, 255);
    }
    else if (wallType == 2)
    {
        baseColor = Color(50, 150, 50, 255);
    }
    else if (wallType == 3)
    {
        baseColor = Color(50, 50, 150, 255);
    }
    else if (wallType == 4)
    {
        baseColor = Color(150, 150, 50, 255);
    }
    else
    {
        baseColor = GRAY;
    }
    
    if (side == 1)
    {
        baseColor = Color(baseColor.r * 0.7, baseColor.g * 0.7, baseColor.b * 0.7, 255);
    }
    
    baseColor = Color(
        baseColor.r * brightness,
        baseColor.g * brightness,
        baseColor.b * brightness,
        255
    );
    
    return baseColor;
}

// ==========================================
// RAYCASTING
// ==========================================

var zBuffer = [];

def castRays(target)
{
    BeginTextureMode(target);
    
    // Céu
    DrawRectangle(0, 0, renderW, renderH / 2, Color(30, 30, 80, 255));
    
    // Chão
    DrawRectangle(0, renderH / 2, renderW, renderH / 2, Color(40, 40, 40, 255));
    
    // Limpar zBuffer
    zBuffer = [];
    for (var i = 0; i < renderW; i = i + 1)
    {
        zBuffer.push(0.0);
    }
    
    for (var x = 0; x < renderW; x = x + 1)
    {
        var cameraX = 2.0 * x / renderW - 1.0;
        var rayDirX = dirX + planeX * cameraX;
        var rayDirY = dirY + planeY * cameraX;

        var mapX = floor(posX);
        var mapY = floor(posY);
        
        var deltaDistX;
        var deltaDistY;

        if (rayDirX == 0.0) deltaDistX = 10000000.0;
        else deltaDistX = abs(1.0 / rayDirX);

        if (rayDirY == 0.0) deltaDistY = 10000000.0;
        else deltaDistY = abs(1.0 / rayDirY);
        
        var stepX, stepY;
        var sideDistX, sideDistY;
        
        if (rayDirX < 0.0)
        {
            stepX = -1;
            sideDistX = (posX - mapX) * deltaDistX;
        }
        else
        {
            stepX = 1;
            sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }
        
        if (rayDirY < 0.0)
        {
            stepY = -1;
            sideDistY = (posY - mapY) * deltaDistY;
        }
        else
        {
            stepY = 1;
            sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }
        
        var hit = 0;
        var side = 0;
        var wallType = 0;
        
        var steps = 0;
        while (hit == 0 && steps < 100)
        {
            steps = steps + 1;
            if (sideDistX < sideDistY)
            {
                sideDistX = sideDistX + deltaDistX;
                mapX = mapX + stepX;
                side = 0;
            }
            else
            {
                sideDistY = sideDistY + deltaDistY;
                mapY = mapY + stepY;
                side = 1;
            }
            
            if (mapX >= 0 && mapX < mapW && mapY >= 0 && mapY < mapH)
            {
                wallType = getMap(mapX, mapY);
                if (wallType > 0) hit = 1;
            }
            else
            {
                hit = 1;
                wallType = 1;
            }
        }
        
        var perpWallDist;
        if (side == 0)
        {
            if (abs(rayDirX) < 0.00001) perpWallDist = 0.00001;
            else perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
        }
        else
        {
            if (abs(rayDirY) < 0.00001) perpWallDist = 0.00001;
            else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;
        }
        
        if (perpWallDist <= 0.0001) perpWallDist = 0.0001;
        
        zBuffer[x] = perpWallDist;
        
        var lineHeight = floor(renderH / perpWallDist);
        
        var drawStart = -lineHeight / 2 + renderH / 2;
        if (drawStart < 0) drawStart = 0;
        
        var drawEnd = lineHeight / 2 + renderH / 2;
        if (drawEnd >= renderH) drawEnd = renderH - 1;
        
        var brightness = 1.0 / (1.0 + perpWallDist * perpWallDist * 0.02);
        if (brightness > 1.0) brightness = 1.0;
        
        var color = getWallColor(wallType, side, brightness);
        
        DrawLine(x, drawStart, x, drawEnd, color);
    }
    
    EndTextureMode();
}

// ==========================================
// SPRITE RENDERING (billboard)
// ==========================================

def drawSprites(target)
{
    BeginTextureMode(target);
    
    // Ordenar sprites por distância (painter's algorithm)
    var spriteOrder = [];
    var spriteDistance = [];
    
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        spriteOrder.push(i);
        var s = sprites[i];
        var dist = (posX - s.x) * (posX - s.x) + (posY - s.y) * (posY - s.y);
        spriteDistance.push(dist);
    }
    
    // Bubble sort (longe -> perto)
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        for (var j = i + 1; j < len(sprites); j = j + 1)
        {
            if (spriteDistance[i] < spriteDistance[j])
            {
                var tmpDist = spriteDistance[i];
                spriteDistance[i] = spriteDistance[j];
                spriteDistance[j] = tmpDist;
                
                var tmpOrder = spriteOrder[i];
                spriteOrder[i] = spriteOrder[j];
                spriteOrder[j] = tmpOrder;
            }
        }
    }
    
    // Desenhar sprites de trás para frente
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        var s = sprites[spriteOrder[i]];
        
        // Posição relativa ao player
        var spriteX = s.x - posX;
        var spriteY = s.y - posY;
        
        // Inverter matriz camera
        var invDet = 1.0 / (planeX * dirY - dirX * planeY);
        
        var transformX = invDet * (dirY * spriteX - dirX * spriteY);
        var transformY = invDet * (-planeY * spriteX + planeX * spriteY);
        
        // Sprite está atrás do player
        if (transformY <= 0.0)
        {
            continue;
        }
        
        var spriteScreenX = floor((renderW / 2) * (1.0 + transformX / transformY));
        
        var spriteHeight = abs(floor(renderH / transformY));
        var spriteWidth = abs(floor(renderH / transformY));
        
        var drawStartY = -spriteHeight / 2 + renderH / 2;
        if (drawStartY < 0) drawStartY = 0;
        
        var drawEndY = spriteHeight / 2 + renderH / 2;
        if (drawEndY >= renderH) drawEndY = renderH - 1;
        
        var drawStartX = -spriteWidth / 2 + spriteScreenX;
        if (drawStartX < 0) drawStartX = 0;
        
        var drawEndX = spriteWidth / 2 + spriteScreenX;
        if (drawEndX >= renderW) drawEndX = renderW - 1;
        
        // Desenhar sprite coluna por coluna
        for (var stripe = drawStartX; stripe < drawEndX; stripe = stripe + 1)
        {
            // Verificar zBuffer (sprite atrás de parede?)
            if (transformY < zBuffer[stripe])
            {
                // Desenhar "textura" do sprite (círculo simples)
                for (var y = drawStartY; y < drawEndY; y = y + 1)
                {
                    // Coordenadas normalizadas (-1 a 1)
                    var nx = (stripe - spriteScreenX) / (spriteWidth / 2.0);
                    var ny = (y - (drawStartY + drawEndY) / 2.0) / (spriteHeight / 2.0);
                    
                    var dist = sqrt(nx * nx + ny * ny);
                    
                    if (dist < 1.0) // Dentro do círculo
                    {
                        var brightness = 1.0 / (1.0 + transformY * transformY * 0.02);
                        if (brightness > 1.0) brightness = 1.0;
                        
                        var c = s.color;
                        var finalColor = Color(
                            c.r * brightness,
                            c.g * brightness,
                            c.b * brightness,
                            255
                        );
                        
                        // Borda mais escura
                        if (dist > 0.8)
                        {
                            finalColor = Color(
                                finalColor.r * 0.5,
                                finalColor.g * 0.5,
                                finalColor.b * 0.5,
                                255
                            );
                        }
                        
                        DrawPixel(stripe, y, finalColor);
                    }
                }
            }
        }
    }
    
    EndTextureMode();
}

// ==========================================
// MINIMAP
// ==========================================

def drawMinimap()
{
    var scale = 15;
    var offsetX = 10;
    var offsetY = 10;
    
    DrawRectangle(offsetX - 2, offsetY - 2, mapW * scale + 4, mapH * scale + 4, Color(0, 0, 0, 200));
    
    for (var y = 0; y < mapH; y = y + 1)
    {
        for (var x = 0; x < mapW; x = x + 1)
        {
            var tile = getMap(x, y);
            if (tile > 0)
            {
                var c = getWallColor(tile, 0, 0.5);
                DrawRectangle(offsetX + x * scale, offsetY + y * scale, scale - 1, scale - 1, c);
            }
        }
    }
    
    // Sprites no minimap
    for (var i = 0; i < len(sprites); i = i + 1)
    {
        var s = sprites[i];
        DrawCircle(offsetX + s.x * scale, offsetY + s.y * scale, 3, s.color);
    }
    
    // Player
    var px = floor(posX * scale);
    var py = floor(posY * scale);
    DrawCircle(offsetX + px, offsetY + py, 3, RED);
    DrawLine(offsetX + px, offsetY + py, offsetX + px + dirX * 10, offsetY + py + dirY * 10, RED);
}

// ==========================================
// MAIN LOOP
// ==========================================

var target = LoadRenderTexture(renderW, renderH);
var src = Rectangle(0, 0, renderW, -renderH);
var dest = Rectangle(0, 0, screenW, screenH);
var origin = Vector2(0, 0);

while (!WindowShouldClose())
{
    // INPUT
    if (IsKeyDown(KEY_W))
    {
        if (getMap(floor(posX + dirX * moveSpeed), floor(posY)) == 0)
            posX = posX + dirX * moveSpeed;
        if (getMap(floor(posX), floor(posY + dirY * moveSpeed)) == 0)
            posY = posY + dirY * moveSpeed;
    }
    
    if (IsKeyDown(KEY_S))
    {
        if (getMap(floor(posX - dirX * moveSpeed), floor(posY)) == 0)
            posX = posX - dirX * moveSpeed;
        if (getMap(floor(posX), floor(posY - dirY * moveSpeed)) == 0)
            posY = posY - dirY * moveSpeed;
    }
    
    if (IsKeyDown(KEY_A))
    {
        var oldDirX = dirX;
        dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
        dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
        
        var oldPlaneX = planeX;
        planeX = planeX * cos(rotSpeed) - planeY * sin(rotSpeed);
        planeY = oldPlaneX * sin(rotSpeed) + planeY * cos(rotSpeed);
    }
    
    if (IsKeyDown(KEY_D))
    {
        var oldDirX = dirX;
        dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
        dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
        
        var oldPlaneX = planeX;
        planeX = planeX * cos(-rotSpeed) - planeY * sin(-rotSpeed);
        planeY = oldPlaneX * sin(-rotSpeed) + planeY * cos(-rotSpeed);
    }
    
    // RENDER
    castRays(target);
    drawSprites(target);
    
    BeginDrawing();
    ClearBackground(BLACK);
    
    var tex = GetRenderTextureTexture(target);
    DrawTexturePro(tex, src, dest, origin, 0.0, WHITE);
    
    drawMinimap();
    
    DrawText("WASD = Move | Sprites!", 10, screenH - 30, 16, WHITE);
    DrawText(format("Sprites: {}", len(sprites)), 10, screenH - 50, 14, WHITE);
    DrawFPS(screenW - 100, 10);
    
    EndDrawing();
}

CloseWindow();require "raylib";

import math;
import raylib;

using raylib;

include "vec2.bu";
include "quadtree.bu";

InitWindow(600, 800, "BULang PINBALL - Flippers");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var RED = Color(255, 100, 100, 255);
var GREEN = Color(100, 255, 100, 255);
var YELLOW = Color(255, 255, 100, 255);
var GRAY = Color(80, 80, 80, 255);
var ORANGE = Color(255, 165, 0, 255);
var PURPLE = Color(200, 100, 255, 255);
var CYAN = Color(0, 255, 255, 255);

var GRAVITY = 600.0;

// ==========================================
// RIGID BODY
// ==========================================
struct Contact
{
    var bodyA;
    var bodyB;
    var manifold;
};

struct RigidBody
{
    var type;
    var pos;
    var vel;
    var angle;
    var angularVel;
    var mass;
    var invMass;
    var inertia;
    var invInertia;
    var restitution;
    var friction;
    var radius;
    var vertices;
    var color;
    var isStatic;
    var bounds;
    var id;
    var isBumper;
    var isFlipper;
    var pivot;
    var motorSpeed;
    var maxMotorTorque;
    var lowerAngleLimit;
    var upperAngleLimit;
};

def createCircle(x, y, radius, density)
{
    var body = RigidBody();
    body.type = 0;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;
    body.radius = radius;
    var area = 3.14159 * radius * radius;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * radius * radius * 0.5;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.7;
    body.friction = 0.2;
    body.color = WHITE;
    body.isStatic = false;
    body.bounds = Rect(x, y, radius, radius);
    body.isBumper = false;
    body.isFlipper = false;
    body.pivot = Vec2(0.0, 0.0);
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 0.0;
    body.lowerAngleLimit = 0.0;
    body.upperAngleLimit = 0.0;
    return body;
}

def createBox(x, y, width, height, density)
{
    var body = RigidBody();
    body.type = 1;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;

    var hw = width / 2.0;
    var hh = height / 2.0;
    body.vertices = [];
    body.vertices.push(Vec2(-hw, -hh));
    body.vertices.push(Vec2(hw, -hh));
    body.vertices.push(Vec2(hw, hh));
    body.vertices.push(Vec2(-hw, hh));

    var area = width * height;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * (width * width + height * height) / 12.0 * 3.0;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.0;
    body.friction = 0.7;
    body.color = GRAY;
    body.isStatic = false;
    body.bounds = Rect(0.0, 0.0, hw, hh);
    body.isBumper = false;
    body.isFlipper = false;
    body.pivot = Vec2(0.0, 0.0);
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 0.0;
    body.lowerAngleLimit = 0.0;
    body.upperAngleLimit = 0.0;
    return body;
}

def createStaticBox(x, y, width, height)
{
    var body = createBox(x, y, width, height, 1.0);
    body.isStatic = true;
    body.invMass = 0.0;
    body.invInertia = 0.0;
    body.color = GRAY;
    body.restitution = 0.8;
    body.friction = 0.1;

    body.bounds = Rect(0.0, 0.0, width, height);
    return body;
}
def createFlipper(pivotX, pivotY, width, height, isLeft)
{
    var body = RigidBody();
    body.type = 1;
    body.pivot = Vec2(pivotX, pivotY);
    body.pos = Vec2(pivotX, pivotY);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;

    var hw = width / 2.0;
    var hh = height / 2.0;

    body.vertices = [];
    if (isLeft)
    {
        body.vertices.push(Vec2(0.0, -hh));
        body.vertices.push(Vec2(width, -hh));
        body.vertices.push(Vec2(width, hh));
        body.vertices.push(Vec2(0.0, hh));

        // Left flipper: -30° to +30° (ajustado para bater melhor)
        body.angle = 0.52;  
        body.lowerAngleLimit = -0.52; 
        body.upperAngleLimit = 0.52; 
    }
    else
    {
        body.vertices.push(Vec2(-width, -hh));
        body.vertices.push(Vec2(0.0, -hh));
        body.vertices.push(Vec2(0.0, hh));
        body.vertices.push(Vec2(-width, hh));

        // Right flipper
        body.angle = -0.52; 
        body.lowerAngleLimit = -0.52;
        body.upperAngleLimit = 0.52;  
    }

    body.bounds = Rect(0.0, 0.0, hw, hh);

    // --- CORREÇÃO DE FÍSICA ---
    // Usamos uma massa fixa baixa para o jogo ser rápido
    body.mass = 20.0; 
    
    // invMass = 0 diz ao motor de física para NÃO mover a posição (pino)
    // Mas invInertia > 0 diz que PODE rodar
    body.invMass = 1.0 / body.mass;

    
    // Momento de inércia para um retângulo a rodar numa ponta (Axis Theorem seria melhor, mas Box chega)
    // Inertia = m * (w^2 + h^2) / 12
    body.inertia = body.mass * (width * width + height * height) / 12.0;
    body.invInertia = 1.0 / body.inertia;

    body.restitution = 0.9; // Menos elástico para não ser caótico
    body.friction = 0.8;    // Muita frição para "agarrar" a bola
    body.color = YELLOW;
    body.isStatic = false;  
    body.isBumper = false;
    body.isFlipper = true;

    
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 2000000.0; 

    return body;
}

// ==========================================
// POLYGON HELPERS
// ==========================================
def getTransformedVertices(body)
{
    if (body.type != 1)
    {
        return [];
    }

    var transformed = [];
    var c = cos(body.angle);
    var s = sin(body.angle);

    if (body.isFlipper)
    {
        for (var i = 0; i < len(body.vertices); i = i + 1)
        {
            var v = body.vertices[i];
            var rx = v.x * c - v.y * s;
            var ry = v.x * s + v.y * c;
            transformed.push(Vec2(rx + body.pivot.x, ry + body.pivot.y));
        }
    }
    else
    {
        for (var i = 0; i < len(body.vertices); i = i + 1)
        {
            var v = body.vertices[i];
            var rx = v.x * c - v.y * s;
            var ry = v.x * s + v.y * c;
            transformed.push(Vec2(rx + body.pos.x, ry + body.pos.y));
        }
    }

    return transformed;
}

def calculateNormals(vertices)
{
    var normals = [];
    for (var i = 0; i < len(vertices); i = i + 1)
    {
        var v1 = vertices[i];
        var v2 = vertices[(i + 1) % len(vertices)];
        var edge = sub(v2, v1);
        var normal = normalize(perp(edge));
        normals.push(normal);
    }
    return normals;
}

def getSupport(vertices, dir)
{
    var bestProj = -999999.0;
    var bestVertex = vertices[0];
    for(var i = 0; i < len(vertices); i = i + 1)
    {
        var v = vertices[i];
        var proj = dot(v, dir);
        if (proj > bestProj)
        {
            bestProj = proj;
            bestVertex = v;
        }
    }
    return bestVertex;
}

def projectPolygon(vertices, axis)
{
    var min = dot(vertices[0], axis);
    var max = min;
    for (var i = 1; i < len(vertices); i = i + 1)
    {
        var p = dot(vertices[i], axis);
        if (p < min) min = p;
        if (p > max) max = p;
    }
    return [min, max];
}

def projectCircle(center, radius, axis)
{
    var p = dot(center, axis);
    return [p - radius, p + radius];
}

// ==========================================
// SAT COLLISION
// ==========================================
struct Manifold
{
    var hasCollision;
    var normal;
    var penetration;
    var contacts;
};

def checkCircleCircle(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var delta = sub(b.pos, a.pos);
    var distSq = lengthSq(delta);
    var radiusSum = a.radius + b.radius;

    if (distSq >= radiusSum * radiusSum)
    {
        return manifold;
    }

    var dist = sqrt(distSq);
    manifold.hasCollision = true;
    manifold.penetration = radiusSum - dist;

    if (dist > 0.0001)
    {
        manifold.normal = normalize(delta);
    }
    else
    {
        manifold.normal = Vec2(1.0, 0.0);
    }

    manifold.contacts = [];
    manifold.contacts.push(add(a.pos, scale(manifold.normal, a.radius)));
    return manifold;
}

def checkPolygonPolygon(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var vertsA = getTransformedVertices(a);
    var vertsB = getTransformedVertices(b);
    var normalsA = calculateNormals(vertsA);
    var normalsB = calculateNormals(vertsB);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normalsA); i = i + 1)
    {
        var axis = normalsA[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    for (var i = 0; i < len(normalsB); i = i + 1)
    {
        var axis = normalsB[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(b.pos, a.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    var dirToA = scale(manifold.normal, -1.0);
    var contactOnB = getSupport(vertsB, dirToA);

    manifold.contacts = [];
    manifold.contacts.push(contactOnB);
    return manifold;
}

def checkCirclePolygon(circle, poly)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var verts = getTransformedVertices(poly);
    var normals = calculateNormals(verts);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normals); i = i + 1)
    {
        var axis = normals[i];
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    var closestDist = 999999.0;
    var closestVert = verts[0];
    for (var i = 0; i < len(verts); i = i + 1)
    {
        var dist = lengthSq(sub(verts[i], circle.pos));
        if (dist < closestDist)
        {
            closestDist = dist;
            closestVert = verts[i];
        }
    }

    var toClosest = sub(closestVert, circle.pos);
    if (lengthSq(toClosest) > 0.0001)
    {
        var axis = normalize(toClosest);
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(poly.pos, circle.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    manifold.contacts = [];
    manifold.contacts.push(add(circle.pos, scale(bestAxis, circle.radius)));
    return manifold;
}

def checkCollision(a, b)
{
    if (a.type == 0 && b.type == 0)
    {
        return checkCircleCircle(a, b);
    }
    else if (a.type == 1 && b.type == 1)
    {
        return checkPolygonPolygon(a, b);
    }
    else if (a.type == 0 && b.type == 1)
    {
        return checkCirclePolygon(a, b);
    }
    else
    {
        var m = checkCirclePolygon(b, a);
        if (m.hasCollision)
        {
            m.normal = scale(m.normal, -1.0);
        }
        return m;
    }
}

// ==========================================
// COLLISION RESOLUTION
// ==========================================
def resolveCollisionImpulse(a, b, manifold)
{
    if (a.isStatic && b.isStatic)
    {
        return;
    }

    for (var c = 0; c < len(manifold.contacts); c = c + 1)
    {
        var contactPoint = manifold.contacts[c];

        var centerA = a.pos;
        var centerB = b.pos;
        if (a.isFlipper) centerA = a.pivot;
        if (b.isFlipper) centerB = b.pivot;

        var ra = sub(contactPoint, centerA);
        var rb = sub(contactPoint, centerB);

        var vaLinear = a.vel;
        var vbLinear = b.vel;
        var vaAngular = Vec2(-a.angularVel * ra.y, a.angularVel * ra.x);
        var vbAngular = Vec2(-b.angularVel * rb.y, b.angularVel * rb.x);

        var va = add(vaLinear, vaAngular);
        var vb = add(vbLinear, vbAngular);
        var rv = sub(vb, va);

        var velAlongNormal = dot(rv, manifold.normal);

        if (velAlongNormal > 0.0)
        {
            continue;
        }

        var e = min(a.restitution, b.restitution);

        if (a.isBumper || b.isBumper)
        {
            e = 1.5;
        }
        else if (abs(velAlongNormal) < 50.0)
        {
            e = 0.0;
        }

        var raCrossN = cross(ra, manifold.normal);
        var rbCrossN = cross(rb, manifold.normal);
        var invMassSum = a.invMass + b.invMass +
                        raCrossN * raCrossN * a.invInertia +
                        rbCrossN * rbCrossN * b.invInertia;

        var j = -(1.0 + e) * velAlongNormal;
        j = j / invMassSum;
        j = j / len(manifold.contacts);

        var impulse = scale(manifold.normal, j);

        if (!a.isStatic)
        {
            a.vel = sub(a.vel, scale(impulse, a.invMass));
            a.angularVel = a.angularVel - cross(ra, impulse) * a.invInertia;
        }

        if (!b.isStatic)
        {
            b.vel = add(b.vel, scale(impulse, b.invMass));
            b.angularVel = b.angularVel + cross(rb, impulse) * b.invInertia;
        }

        // Fricção
        rv = sub(add(vbLinear, Vec2(-b.angularVel * rb.y, b.angularVel * rb.x)),
                 add(vaLinear, Vec2(-a.angularVel * ra.y, a.angularVel * ra.x)));

        var tangent = sub(rv, scale(manifold.normal, dot(rv, manifold.normal)));
        if (lengthSq(tangent) > 0.0001)
        {
            tangent = normalize(tangent);
            var raCrossT = cross(ra, tangent);
            var rbCrossT = cross(rb, tangent);
            var invMassSumT = a.invMass + b.invMass +
                            raCrossT * raCrossT * a.invInertia +
                            rbCrossT * rbCrossT * b.invInertia;

            var jt = -dot(rv, tangent);
            jt = jt / invMassSumT;
            jt = jt / len(manifold.contacts);

            var mu = sqrt(a.friction * a.friction + b.friction * b.friction);
            var frictionImpulse;

            if (abs(jt) < j * mu)
            {
                frictionImpulse = scale(tangent, jt);
            }
            else
            {
                frictionImpulse = scale(tangent, -j * mu);
            }

            if (!a.isStatic)
            {
                a.vel = sub(a.vel, scale(frictionImpulse, a.invMass));
                a.angularVel = a.angularVel - cross(ra, frictionImpulse) * a.invInertia;
            }

            if (!b.isStatic)
            {
                b.vel = add(b.vel, scale(frictionImpulse, b.invMass));
                b.angularVel = b.angularVel + cross(rb, frictionImpulse) * b.invInertia;
            }
        }
    }
}

// ==========================================
// MOTOR SIMULATION 
// ==========================================
def applyMotor(flipper, dt)
{
    if (!flipper.isFlipper) return;

    var targetAngle = flipper.motorSpeed;
    
    var angleError = targetAngle - flipper.angle;
    var desiredAngularVel = angleError * 60.0; 
    var angularError = desiredAngularVel - flipper.angularVel;
    
    var torque = angularError * flipper.inertia * 150.0;
    
    // Clamp torque
    if (torque > flipper.maxMotorTorque) torque = flipper.maxMotorTorque;
    if (torque < -flipper.maxMotorTorque) torque = -flipper.maxMotorTorque;
    
    // Apply torque
    flipper.angularVel = flipper.angularVel + torque * flipper.invInertia * dt;
    
    // Limites (SEM zerar angularVel!)
    if (flipper.angle < flipper.lowerAngleLimit)
    {
        flipper.angle = flipper.lowerAngleLimit;
    }
    if (flipper.angle > flipper.upperAngleLimit)
    {
        flipper.angle = flipper.upperAngleLimit;
    }
}



// Constraint para manter flipper no pivot
def constrainFlipperToPivot(flipper)
{
    if (!flipper.isFlipper) return;

    // Flipper NÃO se move linearmente! Apenas roda
    flipper.pos = flipper.pivot;
    flipper.vel = Vec2(0.0, 0.0);
}

// ==========================================
// HELPERS
// ==========================================
def min(a, b)
{
    if (a < b) return a;
    return b;
}

def max(a, b)
{
    if (a > b) return a;
    return b;
}

def updateAABB(body)
{
    if (body.type == 0)
    {
        body.bounds.x = body.pos.x;
        body.bounds.y = body.pos.y;
        body.bounds.w = body.radius;
        body.bounds.h = body.radius;
    }
    else
    {
        var verts = getTransformedVertices(body);
        var minX = 999999.0;
        var maxX = -999999.0;
        var minY = 999999.0;
        var maxY = -999999.0;

        for(var i = 0; i < len(verts); i = i + 1)
        {
            var v = verts[i];
            if (v.x < minX) minX = v.x;
            if (v.x > maxX) maxX = v.x;
            if (v.y < minY) minY = v.y;
            if (v.y > maxY) maxY = v.y;
        }

        body.bounds.x = (minX + maxX) / 2.0;
        body.bounds.y = (minY + maxY) / 2.0;
        body.bounds.w = (maxX - minX) / 2.0;
        body.bounds.h = (maxY - minY) / 2.0;
    }
}

// ==========================================
// WORLD SETUP
// ==========================================
var IDS = 0;
var bodies = [];
var score = 0;
var ball;
var flipperLeft;
var flipperRight;

def createWorld()
{

// Paredes
IDS = IDS + 1;
var leftWall = createStaticBox(15, 400, 30, 800);
leftWall.id = IDS;
bodies.push(leftWall);

IDS = IDS + 1;
var rightWall = createStaticBox(585, 400, 30, 800);
rightWall.id = IDS;
bodies.push(rightWall);

IDS = IDS + 1;
var topWall = createStaticBox(300, 15, 600, 30);
topWall.id = IDS;
bodies.push(topWall);

// Paredes inclinadas
IDS = IDS + 1;
var leftSlant = createStaticBox(100, 100, 140, 15);
leftSlant.angle = 0.6;
leftSlant.id = IDS;
bodies.push(leftSlant);

IDS = IDS + 1;
var rightSlant = createStaticBox(500, 100, 140, 15);
rightSlant.angle = -0.6;
rightSlant.id = IDS;
bodies.push(rightSlant);

// Flippers CORRIGIDOS!
IDS = IDS + 1;
flipperLeft = createFlipper(170, 700, 120, 16, true);
flipperLeft.id = IDS;
bodies.push(flipperLeft);


IDS = IDS + 1;
flipperRight = createFlipper(430, 700, 120, 16, false);
flipperRight.id = IDS;
bodies.push(flipperRight);

// Bumpers
IDS = IDS + 1;
var bumper1 = createCircle(200, 280, 30, 1.0);
bumper1.isStatic = true;
bumper1.invMass = 0.0;
bumper1.invInertia = 0.0;
bumper1.color = RED;
bumper1.isBumper = true;
bumper1.id = IDS;
bodies.push(bumper1);

IDS = IDS + 1;
var bumper2 = createCircle(400, 280, 30, 1.0);
bumper2.isStatic = true;
bumper2.invMass = 0.0;
bumper2.invInertia = 0.0;
bumper2.color = RED;
bumper2.isBumper = true;
bumper2.id = IDS;
bodies.push(bumper2);

IDS = IDS + 1;
var bumper3 = createCircle(300, 400, 30, 1.0);
bumper3.isStatic = true;
bumper3.invMass = 0.0;
bumper3.invInertia = 0.0;
bumper3.color = RED;
bumper3.isBumper = true;

bumper3.id = IDS;
bodies.push(bumper3);

// Obstáculos
IDS = IDS + 1;
var obstacle1 = createStaticBox(150, 500, 50, 12);
obstacle1.angle = 0.5;
obstacle1.id = IDS;
obstacle1.restitution = 0.9;
obstacle1.color = PURPLE;
 
bodies.push(obstacle1);

IDS = IDS + 1;
var obstacle2 = createStaticBox(450, 500, 50, 12);
obstacle2.angle = -0.5;
obstacle2.restitution = 0.9;
obstacle2.id = IDS;
obstacle2.color = PURPLE;
 
bodies.push(obstacle2);

// Bola
IDS = IDS + 1;
ball = createCircle(300, 200, 12, 1.0);
ball.id = IDS;
ball.color = CYAN;
ball.restitution = 0.9;
ball.friction = 0.02;
ball.mass = 1.0;
ball.invMass = 1.0 / ball.mass; 
bodies.push(ball);
}

def renderWorld()
{
      for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];
        if (body.type == 0)
        {
            DrawCircle(body.pos.x, body.pos.y, body.radius, body.color);

            if (body.isBumper)
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 5, ORANGE);
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 8, ORANGE);
            }
            else
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius, WHITE);
            }
        }
        else
        {
            var verts = getTransformedVertices(body);
            for (var j = 0; j < len(verts); j = j + 1)
            {
                var v1 = verts[j];
                var v2 = verts[(j + 1) % len(verts)];
                DrawLineEx(v1.x, v1.y      ,v2.x, v2.y, 5.0, body.color);
            }

            if (body.isFlipper)
            {
                DrawCircle(body.pivot.x, body.pivot.y, 7, GREEN);
                DrawCircleLines(body.pivot.x, body.pivot.y, 10, WHITE);
            }
        }
    }
}




// ==========================================
// MAIN LOOP
// ==========================================
var screenRect = Rect();
screenRect.x = 300;
screenRect.y = 400;
screenRect.w = 300;
screenRect.h = 400;
createWorld();
var ballRef = ball;

while (!WindowShouldClose())
{
    var dt = 1.0 / 60.0;

   // Motor control
 
if (IsKeyDown(KEY_A) || IsKeyDown(KEY_LEFT))
{
    flipperLeft.motorSpeed = flipperLeft.lowerAngleLimit;  
}
else
{
    flipperLeft.motorSpeed = flipperLeft.upperAngleLimit;  
}

if (IsKeyDown(KEY_D) || IsKeyDown(KEY_RIGHT))
{
    flipperRight.motorSpeed = flipperRight.upperAngleLimit;   
}
else
{
    flipperRight.motorSpeed = flipperRight.lowerAngleLimit;   
}



    // Nova bola
    if (IsKeyPressed(KEY_SPACE))
    {
        ballRef.pos.x = 550.0;
        ballRef.pos.y = 100.0;
        ballRef.vel = Vec2(-100.0, 0.0);
        ballRef.angularVel = 0.0;
    }

    // Physics step
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];

        if (body.isFlipper)
        {
            // Apply motor
            applyMotor(body, dt);

            // Update rotation
            body.angle = body.angle + body.angularVel * dt;

            // Damping
            body.angularVel = body.angularVel * 0.98;

            // Constraint ao pivot
            constrainFlipperToPivot(body);
        }
        else if (!body.isStatic)
        {
            body.vel.y = body.vel.y + GRAVITY * dt;
            body.pos = add(body.pos, scale(body.vel, dt));
            body.angle = body.angle + body.angularVel * dt;
            body.vel = scale(body.vel, 0.998);
            body.angularVel = body.angularVel * 0.98;

            if (abs(body.angularVel) < 0.02)
            {
                body.angularVel = 0.0;
            }
        }

        updateAABB(body);
    }

    // QuadTree
    var qt = createQuadTree(screenRect, 4);
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        insertQT(qt, bodies[i]);
    }

    // Collision detection
    var contacts = [];
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var bodyA = bodies[i];
        var candidates = [];
        queryQT(qt, bodyA.bounds, candidates);

        for (var j = 0; j < len(candidates); j = j + 1)
        {
            var bodyB = candidates[j];

            if (bodyA.id != bodyB.id && bodyA.id < bodyB.id)
            {
                if (intersectsRect(bodyA.bounds, bodyB.bounds))
                {
                    var manifold = checkCollision(bodyA, bodyB);
                    if (manifold.hasCollision)
                    {
                        var c = Contact();
                        c.bodyA = bodyA;
                        c.bodyB = bodyB;
                        c.manifold = manifold;
                        contacts.push(c);

                        // Score
                        if ((bodyA.isBumper || bodyB.isBumper) && 
                            (bodyA.id == ballRef.id || bodyB.id == ballRef.id))
                        {
                            score = score + 100;
                        }
                    }
                }
            }
        }
    }

 
    for (var i = 0; i < len(contacts); i = i + 1)
    {
        var c = contacts[i];
        var a = c.bodyA;
        var b = c.bodyB;
        var manifold = c.manifold;

        // Flippers não movem linearmente!
        var aCanMove = !a.isStatic ;
        var bCanMove = !b.isStatic ;

        if (aCanMove || bCanMove)
        {
            var percent = 0.4;
            var slop = 0.05;

            var totalInvMass = 0.0;
            if (aCanMove) totalInvMass = totalInvMass + a.invMass;
            if (bCanMove) totalInvMass = totalInvMass + b.invMass;

            if (totalInvMass > 0.0001)
            {
                var correctionMag = max(manifold.penetration - slop, 0.0) / totalInvMass * percent;
                var correction = scale(manifold.normal, correctionMag);

                if (aCanMove)
                {
                    a.pos = sub(a.pos, scale(correction, a.invMass));
                }
                if (bCanMove)
                {
                    b.pos = add(b.pos, scale(correction, b.invMass));
                }
            }
        }
    }

    // Solver
    var solverIterations = 6;
    for (var iter = 0; iter < solverIterations; iter = iter + 1)
    {
        for (var i = 0; i < len(contacts); i = i + 1)
        {
            var c = contacts[i];
            resolveCollisionImpulse(c.bodyA, c.bodyB, c.manifold);
        }
    }

    // Render
    BeginDrawing();
    ClearBackground(Color(10, 10, 20, 255));
   
    renderWorld();
  

    // UI
    DrawText("FLIPPER!", 20, 20, 32, YELLOW);
    DrawText(format("SCORE: {}", score), 20, 60, 28, GREEN);
    DrawText("A/LEFT - Left Flipper", 350, 20, 18, WHITE);
    DrawText("D/RIGHT - Right Flipper", 350, 45, 18, WHITE);
    DrawText("SPACE - Launch Ball", 350, 70, 18, CYAN);
    DrawFPS(10, 95);

    EndDrawing();
}

CloseWindow();struct Rect
{
    var x, y, w, h; // center x/y, half-width, half-height
};

def pointInRect(rect, px, py)
{
    return px >= rect.x - rect.w &&
           px <= rect.x + rect.w &&
           py >= rect.y - rect.h &&
           py <= rect.y + rect.h;
}

def intersectsRect(r1, r2)
{
    return !(r2.x - r2.w > r1.x + r1.w ||
             r2.x + r2.w < r1.x - r1.w ||
             r2.y - r2.h > r1.y + r1.h ||
             r2.y + r2.h < r1.y - r1.h);
}

struct QuadTree
{
    var boundary;
    var capacity;
    var bodies;
    var divided;
    
    var nw;
    var ne;
    var sw;
    var se;
};

def createQuadTree(boundary, capacity)
{
    var qt = QuadTree();
    qt.boundary = boundary;
    qt.capacity = capacity;
    qt.bodies = [];
    qt.divided = false;
    return qt;
}

def subdivide(qt)
{
    var x = qt.boundary.x;
    var y = qt.boundary.y;
    var w = qt.boundary.w / 2.0;
    var h = qt.boundary.h / 2.0;
    
    var ne = Rect(); 
    ne.x = x + w; 
    ne.y = y - h; 
    ne.w = w; 
    ne.h = h;
    qt.ne = createQuadTree(ne, qt.capacity);
    
    var nw = Rect(); 
    nw.x = x - w; 
    nw.y = y - h; 
    nw.w = w; 
    nw.h = h;
    qt.nw = createQuadTree(nw, qt.capacity);
    
    var se = Rect(); 
    se.x = x + w; 
    se.y = y + h; 
    se.w = w; 
    se.h = h;
    qt.se = createQuadTree(se, qt.capacity);
    
    var sw = Rect(); 
    sw.x = x - w; 
    sw.y = y + h; 
    sw.w = w; 
    sw.h = h;
    qt.sw = createQuadTree(sw, qt.capacity);
    
    qt.divided = true;
}

def insertQT(qt, body)
{
    
    if (!intersectsRect(qt.boundary, body.bounds))
    {
        return false;
    }
    
    // Se tem espaço e não dividiu, guarda aqui
    if (len(qt.bodies) < qt.capacity && !qt.divided)
    {
        qt.bodies.push(body);
        return true;
    }
    
    // Precisa dividir
    if (!qt.divided)
    {
        subdivide(qt);
    }
    
    // Tenta inserir nos filhos
    // IMPORTANTE: Um body pode estar em MÚLTIPLOS nós se cruzar fronteiras!
    var inserted = false;
    
    if (insertQT(qt.ne, body)) inserted = true;
    if (insertQT(qt.nw, body)) inserted = true;
    if (insertQT(qt.se, body)) inserted = true;
    if (insertQT(qt.sw, body)) inserted = true;
    
    // Se não couber em nenhum filho completamente, fica no pai
    if (!inserted)
    {
        qt.bodies.push(body);
        inserted = true;
    }
    
    return inserted;
}

def queryQT(qt, range, found)
{
    if (!intersectsRect(qt.boundary, range))
    {
        return;
    }
    
    // Adicionar TODOS os bodies deste nó que intersectam a range
    for (var i = 0; i < len(qt.bodies); i = i + 1)
    {
        var body = qt.bodies[i];
        
        // Verifica AABB overlap, não só o centro!
        if (intersectsRect(range, body.bounds))
        {
            // Evitar duplicados (body pode estar em múltiplos nós)
            var alreadyFound = false;
            for (var j = 0; j < len(found); j = j + 1)
            {
                if (found[j].id == body.id)
                {
                    alreadyFound = true;
                }
            }
            
            if (!alreadyFound)
            {
                found.push(body);
            }
        }
    }
    
    if (qt.divided)
    {
        queryQT(qt.nw, range, found);
        queryQT(qt.ne, range, found);
        queryQT(qt.sw, range, found);
        queryQT(qt.se, range, found);
    }
}

def drawQuadTree(qt)
{
    var b = qt.boundary;
    DrawRectangleLines(b.x - b.w, b.y - b.h, b.w * 2, b.h * 2, Color(255, 0, 0, 100));
    
    if (qt.divided)
    {
        drawQuadTree(qt.nw);
        drawQuadTree(qt.ne);
        drawQuadTree(qt.sw);
        drawQuadTree(qt.se);
    }
}
// ==========================================
// VECTOR MATH
// ==========================================

struct Vec2
{
    var x, y;
};

def add(a, b)
{
    return Vec2(a.x + b.x, a.y + b.y);
}

def sub(a, b)
{
    return Vec2(a.x - b.x, a.y - b.y);
}

def scale(v, s)
{
    return Vec2(v.x * s, v.y * s);
}

def dot(a, b)
{
    return a.x * b.x + a.y * b.y;
}

def cross(a, b)
{
    return a.x * b.y - a.y * b.x;
}



def lengthSq(v)
{
    return v.x * v.x + v.y * v.y;
}

def length(v)
{
    return sqrt(lengthSq(v));
}

def normalize(v)
{
    var LEN = length(v);
    if (LEN < 0.0001)
    {
        return Vec2(0.0, 0.0);
    }
    return Vec2(v.x / LEN, v.y / LEN);
}

def perp(v)
{
    return Vec2(-v.y, v.x);
}//include "demos/basic.bu";
//include "demos/doom.bu";
include "demos/pinball.bu";
