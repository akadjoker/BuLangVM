require "raylib";

import math;
import raylib;

using raylib;

include "vec2.bu";
include "quadtree.bu";

InitWindow(600, 800, "PINBALL - Flippers Potentes");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var RED = Color(255, 100, 100, 255);
var GREEN = Color(100, 255, 100, 255);
var YELLOW = Color(255, 255, 100, 255);
var GRAY = Color(80, 80, 80, 255);
var ORANGE = Color(255, 165, 0, 255);
var PURPLE = Color(200, 100, 255, 255);
var CYAN = Color(0, 255, 255, 255);

var GRAVITY = 600.0;

// ==========================================
// RIGID BODY
// ==========================================
struct Contact
{
    var bodyA;
    var bodyB;
    var manifold;
};

struct RigidBody
{
    var type;
    var pos;
    var vel;
    var angle;
    var angularVel;
    var mass;
    var invMass;
    var inertia;
    var invInertia;
    var restitution;
    var friction;
    var radius;
    var vertices;
    var color;
    var isStatic;
    var bounds;
    var id;
    var isBumper;
    var isFlipper;
};

def createCircle(x, y, radius, density)
{
    var body = RigidBody();
    body.type = 0;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;
    body.radius = radius;
    var area = 3.14159 * radius * radius;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * radius * radius * 0.5;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.95;
    body.friction = 0.1;
    body.color = WHITE;
    body.isStatic = false;
    body.bounds = Rect(x, y, radius, radius);
    body.isBumper = false;
    body.isFlipper = false;
    return body;
}

def createBox(x, y, width, height, density)
{
    var body = RigidBody();
    body.type = 1;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;

    var hw = width / 2.0;
    var hh = height / 2.0;
    body.vertices = [];
    body.vertices.push(Vec2(-hw, -hh));
    body.vertices.push(Vec2(hw, -hh));
    body.vertices.push(Vec2(hw, hh));
    body.vertices.push(Vec2(-hw, hh));
    body.bounds = Rect(0.0, 0.0, hw, hh);

    var area = width * height;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * (width * width + height * height) / 12.0;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.0;
    body.friction = 0.7;
    body.color = GRAY;
    body.isStatic = false;
    body.isBumper = false;
    body.isFlipper = false;
    return body;
}

def createStaticBox(x, y, width, height)
{
    var body = createBox(x, y, width, height, 1.0);
    body.isStatic = true;
    body.invMass = 0.0;
    body.invInertia = 0.0;
    body.color = GRAY;
    return body;
}

// ==========================================
// POLYGON HELPERS
// ==========================================
def getTransformedVertices(body)
{
    if (body.type != 1)
    {
        return [];
    }

    var transformed = [];
    var c = cos(body.angle);
    var s = sin(body.angle);

    for (var i = 0; i < len(body.vertices); i = i + 1)
    {
        var v = body.vertices[i];
        var rx = v.x * c - v.y * s;
        var ry = v.x * s + v.y * c;
        transformed.push(Vec2(rx + body.pos.x, ry + body.pos.y));
    }

    return transformed;
}

def calculateNormals(vertices)
{
    var normals = [];
    for (var i = 0; i < len(vertices); i = i + 1)
    {
        var v1 = vertices[i];
        var v2 = vertices[(i + 1) % len(vertices)];
        var edge = sub(v2, v1);
        var normal = normalize(perp(edge));
        normals.push(normal);
    }
    return normals;
}

def projectPolygon(vertices, axis)
{
    var min = dot(vertices[0], axis);
    var max = min;
    for (var i = 1; i < len(vertices); i = i + 1)
    {
        var p = dot(vertices[i], axis);
        if (p < min) min = p;
        if (p > max) max = p;
    }
    return [min, max];
}

def projectCircle(center, radius, axis)
{
    var p = dot(center, axis);
    return [p - radius, p + radius];
}

// ==========================================
// SAT COLLISION
// ==========================================
struct Manifold
{
    var hasCollision;
    var normal;
    var penetration;
    var contacts;
};

def checkCircleCircle(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var delta = sub(b.pos, a.pos);
    var distSq = lengthSq(delta);
    var radiusSum = a.radius + b.radius;

    if (distSq >= radiusSum * radiusSum)
    {
        return manifold;
    }

    var dist = sqrt(distSq);
    manifold.hasCollision = true;
    manifold.penetration = radiusSum - dist;

    if (dist > 0.0001)
    {
        manifold.normal = normalize(delta);
    }
    else
    {
        manifold.normal = Vec2(1.0, 0.0);
    }

    manifold.contacts = [];
    manifold.contacts.push(add(a.pos, scale(manifold.normal, a.radius)));
    return manifold;
}

def checkPolygonPolygon(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var vertsA = getTransformedVertices(a);
    var vertsB = getTransformedVertices(b);
    var normalsA = calculateNormals(vertsA);
    var normalsB = calculateNormals(vertsB);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normalsA); i = i + 1)
    {
        var axis = normalsA[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    for (var i = 0; i < len(normalsB); i = i + 1)
    {
        var axis = normalsB[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(b.pos, a.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    manifold.contacts = [];
    manifold.contacts.push(b.pos);
    return manifold;
}

def checkCirclePolygon(circle, poly)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var verts = getTransformedVertices(poly);
    var normals = calculateNormals(verts);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normals); i = i + 1)
    {
        var axis = normals[i];
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    var closestDist = 999999.0;
    var closestVert = verts[0];
    for (var i = 0; i < len(verts); i = i + 1)
    {
        var dist = lengthSq(sub(verts[i], circle.pos));
        if (dist < closestDist)
        {
            closestDist = dist;
            closestVert = verts[i];
        }
    }

    var toClosest = sub(closestVert, circle.pos);
    if (lengthSq(toClosest) > 0.0001)
    {
        var axis = normalize(toClosest);
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(poly.pos, circle.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    manifold.contacts = [];
    manifold.contacts.push(add(circle.pos, scale(bestAxis, circle.radius)));
    return manifold;
}

def checkCollision(a, b)
{
    if (a.type == 0 && b.type == 0)
    {
        return checkCircleCircle(a, b);
    }
    else if (a.type == 1 && b.type == 1)
    {
        return checkPolygonPolygon(a, b);
    }
    else if (a.type == 0 && b.type == 1)
    {
        return checkCirclePolygon(a, b);
    }
    else
    {
        var m = checkCirclePolygon(b, a);
        if (m.hasCollision)
        {
            m.normal = scale(m.normal, -1.0);
        }
        return m;
    }
}

// ==========================================
// COLLISION RESOLUTION
// ==========================================
def resolveCollisionImpulse(a, b, manifold)
{
    if (a.isStatic && b.isStatic)
    {
        return;
    }

    for (var c = 0; c < len(manifold.contacts); c = c + 1)
    {
        var contactPoint = manifold.contacts[c];
        var ra = sub(contactPoint, a.pos);
        var rb = sub(contactPoint, b.pos);

        var vaLinear = a.vel;
        var vbLinear = b.vel;
        var vaAngular = Vec2(-a.angularVel * ra.y, a.angularVel * ra.x);
        var vbAngular = Vec2(-b.angularVel * rb.y, b.angularVel * rb.x);

        var va = add(vaLinear, vaAngular);
        var vb = add(vbLinear, vbAngular);
        var rv = sub(vb, va);

        var velAlongNormal = dot(rv, manifold.normal);

        if (velAlongNormal > 0.0)
        {
            continue;
        }

        var e = min(a.restitution, b.restitution);

        // BUMPER: bounce forte
        if (a.isBumper || b.isBumper)
        {
            e = 1.3;
        }
        else if (abs(velAlongNormal) < 50.0)
        {
            e = 0.0;
        }

        var raCrossN = cross(ra, manifold.normal);
        var rbCrossN = cross(rb, manifold.normal);
        var invMassSum = a.invMass + b.invMass +
                        raCrossN * raCrossN * a.invInertia +
                        rbCrossN * rbCrossN * b.invInertia;

        var j = -(1.0 + e) * velAlongNormal;
        j = j / invMassSum;
        j = j / len(manifold.contacts);

        var impulse = scale(manifold.normal, j);

        if (!a.isStatic)
        {
            a.vel = sub(a.vel, scale(impulse, a.invMass));
            a.angularVel = a.angularVel - cross(ra, impulse) * a.invInertia;
        }

        if (!b.isStatic)
        {
            b.vel = add(b.vel, scale(impulse, b.invMass));
            b.angularVel = b.angularVel + cross(rb, impulse) * b.invInertia;
        }

        // Fricção
        rv = sub(add(vbLinear, Vec2(-b.angularVel * rb.y, b.angularVel * rb.x)),
                 add(vaLinear, Vec2(-a.angularVel * ra.y, a.angularVel * ra.x)));

        var tangent = sub(rv, scale(manifold.normal, dot(rv, manifold.normal)));
        if (lengthSq(tangent) > 0.0001)
        {
            tangent = normalize(tangent);
            var raCrossT = cross(ra, tangent);
            var rbCrossT = cross(rb, tangent);
            var invMassSumT = a.invMass + b.invMass +
                            raCrossT * raCrossT * a.invInertia +
                            rbCrossT * rbCrossT * b.invInertia;

            var jt = -dot(rv, tangent);
            jt = jt / invMassSumT;
            jt = jt / len(manifold.contacts);

            var mu = sqrt(a.friction * a.friction + b.friction * b.friction);
            var frictionImpulse;

            if (abs(jt) < j * mu)
            {
                frictionImpulse = scale(tangent, jt);
            }
            else
            {
                frictionImpulse = scale(tangent, -j * mu);
            }

            if (!a.isStatic)
            {
                a.vel = sub(a.vel, scale(frictionImpulse, a.invMass));
                a.angularVel = a.angularVel - cross(ra, frictionImpulse) * a.invInertia;
            }

            if (!b.isStatic)
            {
                b.vel = add(b.vel, scale(frictionImpulse, b.invMass));
                b.angularVel = b.angularVel + cross(rb, frictionImpulse) * b.invInertia;
            }
        }
    }
}

// ==========================================
// HELPERS
// ==========================================
def min(a, b)
{
    if (a < b) return a;
    return b;
}

def max(a, b)
{
    if (a > b) return a;
    return b;
}

def updateAABB(body)
{
    if (body.type == 0)
    {
        body.bounds.x = body.pos.x;
        body.bounds.y = body.pos.y;
        body.bounds.w = body.radius;
        body.bounds.h = body.radius;
    }
    else
    {
        var verts = getTransformedVertices(body);
        var minX = 999999.0;
        var maxX = -999999.0;
        var minY = 999999.0;
        var maxY = -999999.0;

        for(var i = 0; i < len(verts); i = i + 1)
        {
            var v = verts[i];
            if (v.x < minX) minX = v.x;
            if (v.x > maxX) maxX = v.x;
            if (v.y < minY) minY = v.y;
            if (v.y > maxY) maxY = v.y;
        }

        body.bounds.x = (minX + maxX) / 2.0;
        body.bounds.y = (minY + maxY) / 2.0;
        body.bounds.w = (maxX - minX) / 2.0;
        body.bounds.h = (maxY - minY) / 2.0;
    }
}

// ==========================================
// PINBALL SETUP
// ==========================================
var bodies = [];
var IDS = 0;
var score = 0;

// Paredes
IDS = IDS + 1;
var leftWall = createStaticBox(15, 400, 30, 800);
leftWall.id = IDS;
bodies.push(leftWall);

IDS = IDS + 1;
var rightWall = createStaticBox(585, 400, 30, 800);
rightWall.id = IDS;
bodies.push(rightWall);

IDS = IDS + 1;
var topWall = createStaticBox(300, 15, 600, 30);
topWall.id = IDS;
bodies.push(topWall);

IDS = IDS + 1;
var bottomWall = createStaticBox(300, 785, 600, 30);
bottomWall.id = IDS;
bodies.push(bottomWall);

// Paredes inclinadas
IDS = IDS + 1;
var leftSlant = createStaticBox(100, 100, 140, 15);
leftSlant.angle = 0.6;
leftSlant.id = IDS;
bodies.push(leftSlant);

IDS = IDS + 1;
var rightSlant = createStaticBox(500, 100, 140, 15);
rightSlant.angle = -0.6;
rightSlant.id = IDS;
bodies.push(rightSlant);

// Flippers (MAIORES e mais POTENTES!)
IDS = IDS + 1;
var flipperLeft = createStaticBox(180, 680, 180, 18);
flipperLeft.angle = 0.5;
flipperLeft.id = IDS;
flipperLeft.color = YELLOW;
flipperLeft.isFlipper = true;
flipperLeft.restitution = 1.0;
bodies.push(flipperLeft);

IDS = IDS + 1;
var flipperRight = createStaticBox(420, 680, 180, 18);
flipperRight.angle = -0.5;
flipperRight.id = IDS;
flipperRight.color = YELLOW;
flipperRight.isFlipper = true;
flipperRight.restitution = 1.0;
bodies.push(flipperRight);

// Bumpers
IDS = IDS + 1;
var bumper1 = createCircle(200, 280, 30, 1.0);
bumper1.isStatic = true;
bumper1.invMass = 0.0;
bumper1.invInertia = 0.0;
bumper1.color = RED;
bumper1.isBumper = true;
bumper1.id = IDS;
bodies.push(bumper1);

IDS = IDS + 1;
var bumper2 = createCircle(400, 280, 30, 1.0);
bumper2.isStatic = true;
bumper2.invMass = 0.0;
bumper2.invInertia = 0.0;
bumper2.color = RED;
bumper2.isBumper = true;
bumper2.id = IDS;
bodies.push(bumper2);

IDS = IDS + 1;
var bumper3 = createCircle(300, 400, 30, 1.0);
bumper3.isStatic = true;
bumper3.invMass = 0.0;
bumper3.invInertia = 0.0;
bumper3.color = RED;
bumper3.isBumper = true;
bumper3.id = IDS;
bodies.push(bumper3);

// Obstáculos
IDS = IDS + 1;
var obstacle1 = createStaticBox(150, 500, 50, 12);
obstacle1.angle = 0.5;
obstacle1.id = IDS;
obstacle1.color = PURPLE;
bodies.push(obstacle1);

IDS = IDS + 1;
var obstacle2 = createStaticBox(450, 500, 50, 12);
obstacle2.angle = -0.5;
obstacle2.id = IDS;
obstacle2.color = PURPLE;
bodies.push(obstacle2);

// Bola
IDS = IDS + 1;
var ball = createCircle(550, 600, 10, 1.0);
ball.id = IDS;
ball.color = CYAN;
ball.restitution = 0.6;
ball.friction = 0.2;
bodies.push(ball);

var ballRef = ball;

// ==========================================
// MAIN LOOP
// ==========================================
var screenRect = Rect();
screenRect.x = 300;
screenRect.y = 400;
screenRect.w = 300;
screenRect.h = 400;

var flipperLeftRestAngle = 0.5;
var flipperRightRestAngle = -0.5;
var flipperSpeed = 30.0;  // MUITO MAIS RÁPIDO!
var maxVelocity = 800.0;

while (!WindowShouldClose())
{
    var dt = 1.0 / 60.0;

    // Controle dos flippers - MAIOR RANGE!
    if (IsKeyDown(KEY_LEFT) || IsKeyDown(KEY_A))
    {
        if (flipperLeft.angle > -1.0)  // Range aumentado!
        {
            flipperLeft.angle = flipperLeft.angle - flipperSpeed * dt;
        }
    }
    else
    {
        if (flipperLeft.angle < flipperLeftRestAngle)
        {
            flipperLeft.angle = flipperLeft.angle + flipperSpeed * dt * 3.5;
            if (flipperLeft.angle > flipperLeftRestAngle)
            {
                flipperLeft.angle = flipperLeftRestAngle;
            }
        }
    }

    if (IsKeyDown(KEY_RIGHT) || IsKeyDown(KEY_D))
    {
        if (flipperRight.angle < 1.0)  // Range aumentado!
        {
            flipperRight.angle = flipperRight.angle + flipperSpeed * dt;
        }
    }
    else
    {
        if (flipperRight.angle > flipperRightRestAngle)
        {
            flipperRight.angle = flipperRight.angle - flipperSpeed * dt * 3.5;
            if (flipperRight.angle < flipperRightRestAngle)
            {
                flipperRight.angle = flipperRightRestAngle;
            }
        }
    }

    // Lançar nova bola
    if (IsKeyPressed(KEY_SPACE))
    {
        ballRef.pos.x = 550.0;
        ballRef.pos.y = 100.0;
        ballRef.vel = Vec2(-100.0, 0.0);
        ballRef.angularVel = 0.0;
    }

    // Physics step
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];
        if (!body.isStatic)
        {
            body.vel.y = body.vel.y + GRAVITY * dt;

            // Limita velocidade máxima
            var velSq = lengthSq(body.vel);
            if (velSq > maxVelocity * maxVelocity)
            {
                body.vel = scale(normalize(body.vel), maxVelocity);
            }

            body.pos = add(body.pos, scale(body.vel, dt));
            body.angle = body.angle + body.angularVel * dt;
            body.vel = scale(body.vel, 0.999);
            body.angularVel = body.angularVel * 0.98;

            if (abs(body.angularVel) < 0.02)
            {
                body.angularVel = 0.0;
            }
        }
        updateAABB(body);
    }

    // QuadTree
    var qt = createQuadTree(screenRect, 4);
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        insertQT(qt, bodies[i]);
    }

    // Collision detection
    var contacts = [];
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var bodyA = bodies[i];
        var candidates = [];
        queryQT(qt, bodyA.bounds, candidates);

        for (var j = 0; j < len(candidates); j = j + 1)
        {
            var bodyB = candidates[j];

            if (bodyA.id != bodyB.id && bodyA.id < bodyB.id)
            {
                if (intersectsRect(bodyA.bounds, bodyB.bounds))
                {
                    var manifold = checkCollision(bodyA, bodyB);
                    if (manifold.hasCollision)
                    {
                        var c = Contact();
                        c.bodyA = bodyA;
                        c.bodyB = bodyB;
                        c.manifold = manifold;
                        contacts.push(c);

                        // Score
                        if ((bodyA.isBumper || bodyB.isBumper) && 
                            (bodyA.id == ballRef.id || bodyB.id == ballRef.id))
                        {
                            score = score + 100;
                        }
                    }
                }
            }
        }
    }

    // Positional correction
    for (var i = 0; i < len(contacts); i = i + 1)
    {
        var c = contacts[i];
        var a = c.bodyA;
        var b = c.bodyB;
        var manifold = c.manifold;

        if (!a.isStatic || !b.isStatic)
        {
            var percent = 0.4;
            var slop = 0.05;
            var correctionMag = max(manifold.penetration - slop, 0.0) / (a.invMass + b.invMass) * percent;
            var correction = scale(manifold.normal, correctionMag);

            if (!a.isStatic)
            {
                a.pos = sub(a.pos, scale(correction, a.invMass));
            }
            if (!b.isStatic)
            {
                b.pos = add(b.pos, scale(correction, b.invMass));
            }
        }
    }

    // Solver
    var solverIterations = 6;
    for (var iter = 0; iter < solverIterations; iter = iter + 1)
    {
        for (var i = 0; i < len(contacts); i = i + 1)
        {
            var c = contacts[i];
            resolveCollisionImpulse(c.bodyA, c.bodyB, c.manifold);
        }
    }

    // Render
    BeginDrawing();
    ClearBackground(Color(10, 10, 20, 255));

    // Desenhar bodies
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];
        if (body.type == 0)
        {
            DrawCircle(body.pos.x, body.pos.y, body.radius, body.color);

            if (body.isBumper)
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 5, ORANGE);
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 8, ORANGE);
            }
            else
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius, WHITE);
            }
        }
        else
        {
            var verts = getTransformedVertices(body);
            for (var j = 0; j < len(verts); j = j + 1)
            {
                var v1 = verts[j];
                var v2 = verts[(j + 1) % len(verts)];
                //DrawLineEx(Vector2(v1.x, v1.y), Vector2(v2.x, v2.y), 5.0, body.color);
                     DrawLine(v1.x, v1.y, v2.x, v2.y, body.color);
            }
        }
    }

    // UI
    DrawText("PINBALL", 20, 20, 40, YELLOW);
    DrawText(format("SCORE: {}", score), 20, 70, 30, GREEN);
    DrawText("A/LEFT - Left Flipper", 330, 730, 18, WHITE);
    DrawText("D/RIGHT - Right Flipper", 330, 755, 18, WHITE);
    DrawText("SPACE - Launch Ball", 20, 730, 18, CYAN);

    DrawFPS(10, 755);

    EndDrawing();
}

CloseWindow();