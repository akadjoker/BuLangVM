require "raylib";
import math;
import raylib;
import file;
using raylib;

// ============================================
// NEURAL NETWORK
// ============================================

class NeuralNetwork
{
    var input_size;
    var hidden_size;
    var output_size;
    
    var weights_ih; // Input -> Hidden
    var weights_ho; // Hidden -> Output
    var bias_h;
    var bias_o;
    
    def init(inputs, hidden, outputs)
    {
        self.input_size = inputs;
        self.hidden_size = hidden;
        self.output_size = outputs;
        
        // Initialize weights randomly
        self.weights_ih = [];
        for (var i = 0; i < inputs; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < hidden; j = j + 1)
            {
                row.push((math.rand(200) - 100) / 100.0); // -1 to 1
            }
            self.weights_ih.push(row);
        }
        
        self.weights_ho = [];
        for (var i = 0; i < hidden; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < outputs; j = j + 1)
            {
                row.push((math.rand(200) - 100) / 100.0);
            }
            self.weights_ho.push(row);
        }
        
        // Biases
        self.bias_h = [];
        for (var i = 0; i < hidden; i = i + 1)
        {
            self.bias_h.push((math.rand(200) - 100) / 100.0);
        }
        
        self.bias_o = [];
        for (var i = 0; i < outputs; i = i + 1)
        {
            self.bias_o.push((math.rand(200) - 100) / 100.0);
        }
    }
    
    def sigmoid(x)
    {
        return 1.0 / (1.0 + exp(-x));
    }
    
    def predict(inputs)
    {
        // Input -> Hidden
        var hidden = [];
        for (var j = 0; j < self.hidden_size; j = j + 1)
        {
            var sum = self.bias_h[j];
            for (var i = 0; i < self.input_size; i = i + 1)
            {
                sum = sum + inputs[i] * self.weights_ih[i][j];
            }
            hidden.push(self.sigmoid(sum));
        }
        
        // Hidden -> Output
        var outputs = [];
        for (var j = 0; j < self.output_size; j = j + 1)
        {
            var sum = self.bias_o[j];
            for (var i = 0; i < self.hidden_size; i = i + 1)
            {
                sum = sum + hidden[i] * self.weights_ho[i][j];
            }
            outputs.push(self.sigmoid(sum));
        }
        
        return outputs;
    }
    
    def copy()
    {
        var nn = NeuralNetwork(self.input_size, self.hidden_size, self.output_size);
        
        // Deep copy weights
        for (var i = 0; i < len(self.weights_ih); i = i + 1)
        {
            for (var j = 0; j < len(self.weights_ih[i]); j = j + 1)
            {
                nn.weights_ih[i][j] = self.weights_ih[i][j];
            }
        }
        
        for (var i = 0; i < len(self.weights_ho); i = i + 1)
        {
            for (var j = 0; j < len(self.weights_ho[i]); j = j + 1)
            {
                nn.weights_ho[i][j] = self.weights_ho[i][j];
            }
        }
        
        for (var i = 0; i < len(self.bias_h); i = i + 1)
        {
            nn.bias_h[i] = self.bias_h[i];
        }
        
        for (var i = 0; i < len(self.bias_o); i = i + 1)
        {
            nn.bias_o[i] = self.bias_o[i];
        }
        
        return nn;
    }
    
    def mutate(rate)
    {
        // Mutate weights_ih
        for (var i = 0; i < len(self.weights_ih); i = i + 1)
        {
            for (var j = 0; j < len(self.weights_ih[i]); j = j + 1)
            {
                if (math.rand(100) < rate * 100)
                {
                    self.weights_ih[i][j] = self.weights_ih[i][j] + (math.rand(200) - 100) / 500.0;
                }
            }
        }
        
        // Mutate weights_ho
        for (var i = 0; i < len(self.weights_ho); i = i + 1)
        {
            for (var j = 0; j < len(self.weights_ho[i]); j = j + 1)
            {
                if (math.rand(100) < rate * 100)
                {
                    self.weights_ho[i][j] = self.weights_ho[i][j] + (math.rand(200) - 100) / 500.0;
                }
            }
        }
        
        // Mutate biases
        for (var i = 0; i < len(self.bias_h); i = i + 1)
        {
            if (math.rand(100) < rate * 100)
            {
                self.bias_h[i] = self.bias_h[i] + (math.rand(200) - 100) / 500.0;
            }
        }
        
        for (var i = 0; i < len(self.bias_o); i = i + 1)
        {
            if (math.rand(100) < rate * 100)
            {
                self.bias_o[i] = self.bias_o[i] + (math.rand(200) - 100) / 500.0;
            }
        }
    }
    
    def save_to_file(filename)
    {
        var f = file.open(filename, "w");
        
        // Salvar dimensÃµes
        file.write_int(f, self.input_size);
        file.write_int(f, self.hidden_size);
        file.write_int(f, self.output_size);
        
        // Salvar weights_ih
        for (var i = 0; i < len(self.weights_ih); i = i + 1)
        {
            for (var j = 0; j < len(self.weights_ih[i]); j = j + 1)
            {
                file.write_double(f, self.weights_ih[i][j]);
            }
        }
        
        // Salvar weights_ho
        for (var i = 0; i < len(self.weights_ho); i = i + 1)
        {
            for (var j = 0; j < len(self.weights_ho[i]); j = j + 1)
            {
                file.write_double(f, self.weights_ho[i][j]);
            }
        }
        
        // Salvar bias_h
        for (var i = 0; i < len(self.bias_h); i = i + 1)
        {
            file.write_double(f, self.bias_h[i]);
        }
        
        // Salvar bias_o
        for (var i = 0; i < len(self.bias_o); i = i + 1)
        {
            file.write_double(f, self.bias_o[i]);
        }
        
        file.close(f);
    }
    
    def load_from_file(filename)
    {
        var f = file.open(filename, "r");
        
        // Carregar dimensÃµes
        self.input_size = file.read_int(f);
        self.hidden_size = file.read_int(f);
        self.output_size = file.read_int(f);
        
        // Carregar weights_ih
        self.weights_ih = [];
        for (var i = 0; i < self.input_size; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < self.hidden_size; j = j + 1)
            {
                row.push(file.read_double(f));
            }
            self.weights_ih.push(row);
        }
        
        // Carregar weights_ho
        self.weights_ho = [];
        for (var i = 0; i < self.hidden_size; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < self.output_size; j = j + 1)
            {
                row.push(file.read_double(f));
            }
            self.weights_ho.push(row);
        }
        
        // Carregar bias_h
        self.bias_h = [];
        for (var i = 0; i < self.hidden_size; i = i + 1)
        {
            self.bias_h.push(file.read_double(f));
        }
        
        // Carregar bias_o
        self.bias_o = [];
        for (var i = 0; i < self.output_size; i = i + 1)
        {
            self.bias_o.push(file.read_double(f));
        }
        
        file.close(f);
    }
}

// ============================================
// PONG GAME
// ============================================

class Paddle
{
    var x, y;
    var width, height;
    var speed;
    var score;
    var velocity; // Smooth movement
    
    def init(x, y)
    {
        self.x = x;
        self.y = y;
        self.width = 15;
        self.height = 80;
        self.speed = 400;
        self.score = 0;
        self.velocity = 0;
    }
    
    def update(dir, dt)
    {
        // Smooth acceleration/deceleration (no more jittery movement)
        var target_velocity = dir * self.speed;
        var acceleration = 800; // pixels/s^2 - smoothing acceleration (reduced for more noticeable smoothing)
        
        // Lerp velocity towards target
        if (self.velocity < target_velocity)
        {
            self.velocity = self.velocity + acceleration * dt;
            if (self.velocity > target_velocity) self.velocity = target_velocity;
        }
        else if (self.velocity > target_velocity)
        {
            self.velocity = self.velocity - acceleration * dt;
            if (self.velocity < target_velocity) self.velocity = target_velocity;
        }
        
        // Update position with smooth velocity
        self.y = self.y + self.velocity * dt;
        
        // Clamp to bounds
        if (self.y < 0) self.y = 0;
        if (self.y > 600 - self.height) self.y = 600 - self.height;
    }
    
    def draw()
    {
        DrawRectangle(self.x, self.y, self.width, self.height, Color(255, 255, 255, 255));
    }
}

class Ball
{
    var x, y;
    var vx, vy;
    var size;
    var speed;
    
    def init()
    {
        self.size = 10;
        self.speed = 300;
        self.x = 400;
        self.y = 300;
        
        var angle = (floor(math.rand(60)) - 30) * 3.14159 / 180.0;
        var dir = 1.0;
        if (math.rand(2) == 0) dir = -1;
        
        self.vx = cos(angle) * self.speed * dir;
        self.vy = sin(angle) * self.speed;
    }
    
    def reset()
    {
        self.x = 400;
        self.y = 300;
        
        var angle = (floor(math.rand(60)) - 30) * 3.14159 / 180.0;
        var dir = 1.0;
        if (math.rand(2) == 0) dir = -1;
        
        self.vx = cos(angle) * self.speed * dir;
        self.vy = sin(angle) * self.speed;
    }
    
    def update(dt, paddle_left, paddle_right)
    {
        self.x = self.x + self.vx * dt;
        self.y = self.y + self.vy * dt;
        
        // Top/bottom bounce
        if (self.y < 0 || self.y > 600 - self.size)
        {
            self.vy = -self.vy;
        }
        
        // Paddle collision
        if (self.x < paddle_left.x + paddle_left.width &&
            self.x + self.size > paddle_left.x &&
            self.y < paddle_left.y + paddle_left.height &&
            self.y + self.size > paddle_left.y)
        {
            self.vx = abs(self.vx);
            var hitPos = (self.y - paddle_left.y) / paddle_left.height - 0.5;
            self.vy = hitPos * 400;
        }
        
        if (self.x < paddle_right.x + paddle_right.width &&
            self.x + self.size > paddle_right.x &&
            self.y < paddle_right.y + paddle_right.height &&
            self.y + self.size > paddle_right.y)
        {
            self.vx = -abs(self.vx);
            var hitPos = (self.y - paddle_right.y) / paddle_right.height - 0.5;
            self.vy = hitPos * 400;
        }
        
        // Score
        if (self.x < 0)
        {
            paddle_right.score = paddle_right.score + 1;
            self.reset();
            return 1; // Right scored
        }
        
        if (self.x > 800)
        {
            paddle_left.score = paddle_left.score + 1;
            self.reset();
            return -1; // Left scored
        }
        
        return 0;
    }
    
    def draw()
    {
        DrawRectangle(self.x, self.y, self.size, self.size, Color(255, 255, 255, 255));
    }
}

// ============================================
// AI AGENT
// ============================================

class Agent
{
    var brain;
    var fitness;
    var paddle;
    var ball;
    var games_played;
    var total_hits;
    
    def init()
    {
        // Inputs: paddle_y, ball_x, ball_y, ball_vx, ball_vy (normalized)
        // Outputs: up, down, stay
        self.brain = NeuralNetwork(5, 12, 3);  // Increased hidden neurons from 6 to 12
        self.fitness = 0;
        self.games_played = 0;
        self.total_hits = 0;
    }
    
    def think(paddle, ball)
    {
        // Normalize inputs
        var inputs = [
            paddle.y / 600.0,
            ball.x / 800.0,
            ball.y / 600.0,
            ball.vx / 400.0,
            ball.vy / 400.0
        ];
        
        var outputs = self.brain.predict(inputs);
        
        // Get action (up, down) - removed STAY to force movement
        if (outputs[0] > outputs[1])
        {
            return -1; // Up
        }
        else
        {
            return 1; // Down
        }
    }
    
    def getInputs(paddle, ball)
    {
        return [
            paddle.y / 600.0,
            ball.x / 800.0,
            ball.y / 600.0,
            ball.vx / 400.0,
            ball.vy / 400.0
        ];
    }
    
    def getMaxOutput(outputs)
    {
        var maxVal = outputs[0];
        var maxIdx = 0;
        for (var i = 1; i < len(outputs); i = i + 1)
        {
            if (outputs[i] > maxVal)
            {
                maxVal = outputs[i];
                maxIdx = i;
            }
        }
        return maxVal;
    }
    
    def copy()
    {
        var agent = Agent();
        agent.brain = self.brain.copy();
        return agent;
    }
    
    def mutate(rate)
    {
        self.brain.mutate(rate);
    }
}

// ============================================
// NEURAL NETWORK VISUALIZATION
// ============================================

class NetworkVisualizer
{
    var nn;
    var x, y;
    var width, height;
    var last_inputs;
    var last_hidden;
    var last_outputs;
    
    def init(neural_net, pos_x, pos_y, w, h)
    {
        self.nn = neural_net;
        self.x = pos_x;
        self.y = pos_y;
        self.width = w;
        self.height = h;
        self.last_inputs = [];
        self.last_hidden = [];
        self.last_outputs = [];
    }
    
    def update(inputs)
    {
        self.last_inputs = inputs;
        
        // Calculate hidden layer activations
        self.last_hidden = [];
        for (var j = 0; j < self.nn.hidden_size; j = j + 1)
        {
            var sum = self.nn.bias_h[j];
            for (var i = 0; i < self.nn.input_size; i = i + 1)
            {
                sum = sum + inputs[i] * self.nn.weights_ih[i][j];
            }
            self.last_hidden.push(self.nn.sigmoid(sum));
        }
        
        // Calculate output layer activations
        self.last_outputs = [];
        for (var j = 0; j < self.nn.output_size; j = j + 1)
        {
            var sum = self.nn.bias_o[j];
            for (var i = 0; i < self.nn.hidden_size; i = i + 1)
            {
                sum = sum + self.last_hidden[i] * self.nn.weights_ho[i][j];
            }
            self.last_outputs.push(self.nn.sigmoid(sum));
        }
    }
    
    def draw()
    {
        var layer_spacing = self.width / 4;
        var input_x = self.x + layer_spacing;
        var hidden_x = self.x + layer_spacing * 2;
        var output_x = self.x + layer_spacing * 3;
        
        var node_radius = 10;
        
        // Draw connections first (behind nodes)
        self.drawConnections(input_x, hidden_x, output_x, node_radius);
        
        // Draw nodes
        self.drawLayer(self.last_inputs, input_x, "INPUT", node_radius);
        self.drawLayer(self.last_hidden, hidden_x, "HIDDEN", node_radius);
        self.drawLayer(self.last_outputs, output_x, "OUTPUT", node_radius);
        
        // Draw title
        DrawText("NEURAL NETWORK", self.x + 60, self.y - 25, 14, Color(255, 255, 255, 255));
    }
    
    def drawLayer(activations, x, l, radius)
    {
        var spacing = self.height / (len(activations) + 1);
        
        for (var i = 0; i < len(activations); i = i + 1)
        {
            var y = self.y + spacing * (i + 1);
            var activation = activations[i];
            
            // Color based on activation (blue to red)
            var r = floor(activation * 255);
            var b = floor((1.0 - activation) * 255);
            var color = Color(r, 100, b, 255);
            
            // Outer glow if highly activated
            if (activation > 0.7)
            {
                DrawCircle(x, y, radius + 3, Color(r, 200, 0, 80));
            }
            
            // Draw node
            DrawCircle(x, y, radius, color);
            DrawCircleLines(x, y, radius, Color(255, 255, 255, 150));
        }
    }
    
    def drawConnections(input_x, hidden_x, output_x, radius)
    {
        var input_spacing = self.height / (len(self.last_inputs) + 1);
        var hidden_spacing = self.height / (len(self.last_hidden) + 1);
        var output_spacing = self.height / (len(self.last_outputs) + 1);
        
        // Input -> Hidden connections
        for (var i = 0; i < len(self.last_inputs); i = i + 1)
        {
            var y1 = self.y + input_spacing * (i + 1);
            
            for (var j = 0; j < len(self.last_hidden); j = j + 1)
            {
                var y2 = self.y + hidden_spacing * (j + 1);
                
                var weight = self.nn.weights_ih[i][j];
                var strength = abs(weight);
                var thickness = strength * 2.5;
                if (thickness < 0.5) thickness = 0.5;
                if (thickness > 2.5) thickness = 2.5;
                
                var alpha = floor(strength * 100);
                if (alpha > 100) alpha = 100;
                
                var color = Color(255, 100, 100, alpha);
                if (weight > 0)
                {
                    color = Color(100, 200, 100, alpha);
                }
                
                if (strength > 0.05)
                {
                    DrawLineEx(
                        input_x + radius, y1,
                        hidden_x - radius, y2,
                        thickness,
                        color
                    );
                }
            }
        }
        
        // Hidden -> Output connections
        for (var i = 0; i < len(self.last_hidden); i = i + 1)
        {
            var y1 = self.y + hidden_spacing * (i + 1);
            
            for (var j = 0; j < len(self.last_outputs); j = j + 1)
            {
                var y2 = self.y + output_spacing * (j + 1);
                
                var weight = self.nn.weights_ho[i][j];
                var strength = abs(weight);
                var thickness = strength * 2.5;
                if (thickness < 0.5) thickness = 0.5;
                if (thickness > 2.5) thickness = 2.5;
                
                var alpha = floor(strength * 100);
                if (alpha > 100) alpha = 100;
                
                var color = Color(255, 100, 100, alpha);
                if (weight > 0)
                {
                    color = Color(100, 200, 100, alpha);
                }
                
                if (strength > 0.05)
                {
                    DrawLineEx(
                        hidden_x + radius, y1,
                        output_x - radius, y2,
                        thickness,
                        color
                    );
                }
            }
        }
    }
}

// ============================================
// STATS GRAPH
// ============================================

class StatsGraph
{
    var fitness_history;
    var max_history;
    var x, y, width, height;
    
    def init(pos_x, pos_y, w, h)
    {
        self.fitness_history = [];
        self.max_history = 100;
        self.x = pos_x;
        self.y = pos_y;
        self.width = w;
        self.height = h;
    }
    
    def add(fitness)
    {
        self.fitness_history.push(fitness);
        
        if (len(self.fitness_history) > self.max_history)
        {
            var new_history = [];
            for (var i = 1; i < len(self.fitness_history); i = i + 1)
            {
                new_history.push(self.fitness_history[i]);
            }
            self.fitness_history = new_history;
        }
    }
    
    def draw()
    {
        // Background
        DrawRectangle(self.x, self.y, self.width, self.height, Color(20, 20, 30, 200));
        DrawRectangleLines(self.x, self.y, self.width, self.height, Color(100, 100, 150, 255));
        
        // Title
        DrawText("FITNESS EVOLUTION", self.x + 10, self.y + 5, 12, Color(255, 255, 255, 255));
        
        if (len(self.fitness_history) < 2)
        {
            return;
        }
        
        // Find max for scaling
        var max_fitness = self.fitness_history[0];
        for (var i = 1; i < len(self.fitness_history); i = i + 1)
        {
            if (self.fitness_history[i] > max_fitness)
            {
                max_fitness = self.fitness_history[i];
            }
        }
        
        if (max_fitness < 1) max_fitness = 1;
        
        // Draw graph
        var graph_height = self.height - 40;
        var point_spacing = self.width / self.max_history;
        
        for (var i = 0; i < len(self.fitness_history) - 1; i = i + 1)
        {
            var x1 = self.x + i * point_spacing;
            var y1 = self.y + self.height - 20 - (self.fitness_history[i] / max_fitness * graph_height);
            
            var x2 = self.x + (i + 1) * point_spacing;
            var y2 = self.y + self.height - 20 - (self.fitness_history[i + 1] / max_fitness * graph_height);
            
            var color = Color(100, 200, 100, 255);
            
            DrawLineEx(x1, y1, x2, y2, 2, color);
            DrawCircle(x2, y2, 2, Color(255, 255, 100, 255));
        }
        
        // Draw max value
        DrawText(format("Max: {}", floor(max_fitness)), self.x + 10, self.y + self.height - 15, 10, Color(0, 255, 0, 255));
    }
}

// ============================================
// GENETIC ALGORITHM
// ============================================

class GeneticAlgorithm
{
    var population;
    var population_size;
    var generation;
    var best_fitness;
    var best_agent;
    
    def init(pop_size)
    {
        self.population_size = pop_size;
        self.population = [];
        self.generation = 0;
        self.best_fitness = 0;
        self.best_agent = Agent(); // Initialize best_agent
        
        for (var i = 0; i < pop_size; i = i + 1)
        {
            self.population.push(Agent());
        }
    }
    
    def evolve()
    {
        // Sort by fitness
        for (var i = 0; i < len(self.population) - 1; i = i + 1)
        {
            for (var j = i + 1; j < len(self.population); j = j + 1)
            {
                if (self.population[j].fitness > self.population[i].fitness)
                {
                    var temp = self.population[i];
                    self.population[i] = self.population[j];
                    self.population[j] = temp;
                }
            }
        }
        
        // Track best
        self.best_fitness = self.population[0].fitness;
        self.best_agent = self.population[0].copy();
        
        // Create new generation
        var new_pop = [];
        
        // Keep top 20%
        var elite_count = self.population_size / 5;
        for (var i = 0; i < elite_count; i = i + 1)
        {
            new_pop.push(self.population[i].copy());
        }
        
        // Breed rest
        while (len(new_pop) < self.population_size)
        {
            // Select parents (top 50%)
            var parent1 = self.population[math.rand(self.population_size / 2)];
            var child = parent1.copy();
            
            // Adaptive mutation: higher in early generations
            var mutation_rate = 0.3; // 30% base rate
            if (self.generation < 10)
            {
                mutation_rate = 0.5; // 50% in first generations (explore more)
            }
            
            child.mutate(mutation_rate);
            new_pop.push(child);
        }
        
        self.population = new_pop;
        self.generation = self.generation + 1;
    }
}

// ============================================
// MAIN
// ============================================

// ============================================
// TRAINING CONFIG - OFFLINE (SEM VISUALIZAÃ‡ÃƒO)
// ============================================
var TRAINING_MODE = true;
var VISUAL_TRAINING = false;  // Desativar visualizaÃ§Ã£o para treino RÃPIDO
var GAMES_PER_GENERATION = 2;
var MAX_GAME_TIME = 15.0;

var ga = GeneticAlgorithm(10);

print("âš¡ Modo treino OFFLINE (SEM visualizaÃ§Ã£o) - Performance MÃXIMA!");
print("Treinando 150 geraÃ§Ãµes...");

// NÃƒO inicializar Raylib em modo offline

// Carregar pesos treinados anteriormente se existirem
if (file.exists("pong_weights.nn"))
{
    ga.best_agent.brain.load_from_file("pong_weights.nn");
    TRAINING_MODE = false;
    print("âœ… Pesos carregados! Modo visualizaÃ§Ã£o ativado.");
}
else
{
    print("âš ï¸ Nenhum modelo treinado encontrado. Iniciando treino novo...");
    TRAINING_MODE = true;
}

var current_agent_idx = 0;
var current_game = 0;
var game_time = 0.0;

var paddle_ai = Paddle(30, 260);
var paddle_opponent = Paddle(755, 260);
var ball = Ball();

var WHITE = Color(255, 255, 255, 255);
var GREEN = Color(0, 255, 0, 255);
var RED = Color(255, 0, 0, 255);
var BLUE = Color(100, 150, 255, 255);

// Visualizers (criados apenas em modo visual)
var network_viz = nil;
var stats_graph = nil;

if (VISUAL_TRAINING)
{
    network_viz = NetworkVisualizer(ga.population[0].brain, 450, 100, 320, 400);
    stats_graph = StatsGraph(450, 510, 320, 80);
}

// Janela sÃ³ serÃ¡ inicializada depois do treino (PLAY_MODE)
// Durante treino, nenhuma renderizaÃ§Ã£o = performance mÃ¡xima

// ===== TRAINING LOOP (with visual feedback) =====
while (TRAINING_MODE && ga.generation < 150)
{
    // Training with visual feedback
    for (var fast = 0; fast < 10; fast = fast + 1)
    {
        game_time = game_time + 0.016; // Simulate fixed 16ms frame
        
        // AI thinks and moves
        var agent = ga.population[current_agent_idx];
        var action = agent.think(paddle_ai, ball);
        paddle_ai.update(action, 0.016);
        
        // Simple opponent AI
        var diff = ball.y - (paddle_opponent.y + paddle_opponent.height / 2);
        if (diff > 5) paddle_opponent.update(1, 0.016);
        if (diff < -5) paddle_opponent.update(-1, 0.016);
        
        // Update ball
        var result = ball.update(0.016, paddle_ai, paddle_opponent);
        
        // ===== IMPROVED FITNESS CALCULATION =====
        
        // 1. Base reward (very small)
        agent.fitness = agent.fitness + 0.001;
        
        // 2. Reward for being close to the ball (DOMINANT)
        var paddle_center = paddle_ai.y + paddle_ai.height / 2;
        var distance = abs(paddle_center - ball.y);
        var proximity_reward = (100.0 - distance) / 100.0;
        if (proximity_reward < 0) proximity_reward = 0;
        agent.fitness = agent.fitness + proximity_reward * 10.0;
        
        // 3. Reward for moving in correct direction
        if (paddle_center < ball.y && action == 1)
        {
            agent.fitness = agent.fitness + 5.0;
        }
        if (paddle_center > ball.y && action == -1)
        {
            agent.fitness = agent.fitness + 5.0;
        }
        
        // 4. Penalty for moving in wrong direction
        if (paddle_center > ball.y && action == 1)
        {
            agent.fitness = agent.fitness - 2.0;
        }
        if (paddle_center < ball.y && action == -1)
        {
            agent.fitness = agent.fitness - 2.0;
        }
        
        // 5. Big reward for hitting the ball
        if (result == -1)
        {
            agent.fitness = agent.fitness + 500;
            agent.total_hits = agent.total_hits + 1;
        }
        
        // 6. Penalty for losing a point
        if (result == 1)
        {
            agent.fitness = agent.fitness - 100;
        }
        
        // Next game/agent
        if (game_time > MAX_GAME_TIME || result != 0)
        {
            game_time = 0.0;
            current_game = current_game + 1;
            ball.reset();
            paddle_ai.y = 260;
            paddle_opponent.y = 260;
            
            if (current_game >= GAMES_PER_GENERATION)
            {
                current_game = 0;
                agent.games_played = GAMES_PER_GENERATION;
                current_agent_idx = current_agent_idx + 1;
                
                // Reset fitness for next agent
                if (current_agent_idx < ga.population_size)
                {
                    ga.population[current_agent_idx].fitness = 0;
                }
                
                if (current_agent_idx >= ga.population_size)
                {
                    // Evolve!
                    ga.evolve();
                    current_agent_idx = 0;
                    
                    // Gravar os pesos do melhor agente
                    ga.best_agent.brain.save_to_file("pong_weights.nn");
                    print(format("âœ… GeraÃ§Ã£o {} completa! Fitness: {}", ga.generation, ga.best_fitness));
                    
                    // Update graph with new fitness value
                    if (stats_graph != nil)
                    {
                        stats_graph.add(ga.best_fitness);
                    }
                }
            }
        }
        
        // VISUAL TRAINING - Renderizar a cada frame
        if (VISUAL_TRAINING && !WindowShouldClose())
        {
            BeginDrawing();
            ClearBackground(Color(0, 0, 0, 255));
            
            // Draw game (left side)
            paddle_ai.draw();
            paddle_opponent.draw();
            ball.draw();
            
            // Center line
            for (var i = 0; i < 600; i = i + 20)
            {
                DrawRectangle(397, i, 6, 10, Color(100, 100, 100, 255));
            }
            
            // UI - Game info (left side)
            DrawText("ðŸŽ“ TREINO VISUAL", 80, 20, 20, GREEN);
            DrawText(format("GeraÃ§Ã£o: {} | Fitness: {}", ga.generation, floor(ga.best_fitness)), 20, 45, 14, BLUE);
            DrawText(format("Agente: {}/{}", current_agent_idx + 1, ga.population_size), 20, 65, 12, BLUE);
            DrawText(format("Jogo: {}/{}", current_game + 1, GAMES_PER_GENERATION), 20, 80, 12, BLUE);
            
            // Show current agent fitness
            var current_fitness = floor(ga.population[current_agent_idx].fitness * 100) / 100.0;
            DrawText(format("Fitness: {}", current_fitness), 20, 95, 12, WHITE);
            DrawText(format("Hits: {}", ga.population[current_agent_idx].total_hits), 20, 110, 12, WHITE);
            
            // AI scores
            DrawText(format("IA: {} | Jogador: {}", paddle_ai.score, paddle_opponent.score), 120, 560, 14, WHITE);
            
            // Draw neural network visualization
            if (network_viz != nil)
            {
                var agent = ga.population[current_agent_idx];
                var inputs = agent.getInputs(paddle_ai, ball);
                network_viz.update(inputs);
                network_viz.draw();
                
                // Draw input labels
                var input_labels = ["Paddle Y", "Ball X", "Ball Y", "Ball VX", "Ball VY"];
                var input_spacing = network_viz.height / (len(input_labels) + 1);
                for (var i = 0; i < len(input_labels); i = i + 1)
                {
                    var node_y = network_viz.y + input_spacing * (i + 1);
                    DrawText(input_labels[i], network_viz.x - 100, node_y - 6, 9, Color(150, 150, 150, 255));
                }
                
                // Draw output labels
                var output_labels = ["UP", "DOWN", "STAY"];
                var output_spacing = network_viz.height / (len(output_labels) + 1);
                for (var i = 0; i < len(output_labels); i = i + 1)
                {
                    var node_y = network_viz.y + output_spacing * (i + 1);
                    var color = Color(150, 150, 150, 255);
                    
                    // Highlight chosen action
                    if (network_viz.last_outputs[i] == agent.getMaxOutput(network_viz.last_outputs))
                    {
                        color = Color(0, 255, 0, 255);
                        DrawText(">>>", network_viz.x + network_viz.width + 10, node_y - 6, 12, color);
                    }
                    
                    DrawText(output_labels[i], network_viz.x + network_viz.width + 40, node_y - 6, 10, color);
                }
            }
            
            // Draw fitness graph
            if (stats_graph != nil)
            {
                stats_graph.draw();
            }
            
            DrawFPS(700, 20);
            
            EndDrawing();
        }
    }
}

// Fechar janela de treino se estava visual
if (VISUAL_TRAINING)
{
    CloseWindow();
}

// After training, switch to play mode
TRAINING_MODE = false;
print("ðŸŽ® Treino completo! Iniciando modo visualizaÃ§Ã£o...");

// Initialize graphics AFTER training (if it wasn't already initialized)
if (!VISUAL_TRAINING)
{
    InitWindow(800, 600, "BuLang AI Pong - Trained AI");
}
else
{
    // Reinitialize window for play mode
    InitWindow(800, 600, "BuLang AI Pong - Trained AI");
}
SetTargetFPS(60);

// ===== PLAY LOOP (with graphics) =====
while (!WindowShouldClose())
{
    var dt = GetFrameTime();
    
    // PLAY MODE - watch best agent
    var action = ga.best_agent.think(paddle_ai, ball);
    paddle_ai.update(action, dt);
    
    // Player controls right paddle
    if (IsKeyDown(KEY_UP)) paddle_opponent.update(-1, dt);
    else if (IsKeyDown(KEY_DOWN)) paddle_opponent.update(1, dt);
    else paddle_opponent.update(0, dt); // Allow smooth deceleration when no key pressed
    
    // Update ball and check for scoring
    var score_result = ball.update(dt, paddle_ai, paddle_opponent);
    
    // Reset paddles on new point
    if (score_result != 0)
    {
        paddle_ai.y = 260;
        paddle_opponent.y = 260;
    }
    
    // ============================================
    // RENDER
    // ============================================
    
    BeginDrawing();
    ClearBackground(Color(0, 0, 0, 255));
    
    // Draw game
    paddle_ai.draw();
    paddle_opponent.draw();
    ball.draw();
    
    // Center line
    for (var i = 0; i < 600; i = i + 20)
    {
        DrawRectangle(397, i, 6, 10, Color(100, 100, 100, 255));
    }
    
    // UI
    DrawText("ðŸŽ® PLAY MODE - Best AI vs You", 200, 20, 20, GREEN);
    DrawText(format("Generation: {} | Fitness: {}", ga.generation, ga.best_fitness), 20, 45, 16, BLUE);
    DrawText("Arrow Keys to play!", 300, 560, 16, WHITE);
    
    // Debug: show action
    var action_text = "STAY";
    if (action == -1) action_text = "UP";
    if (action == 1) action_text = "DOWN";
    DrawText(format("AI Action: {}", action_text), 20, 70, 14, WHITE);
    DrawText(format("AI Y: {} | Ball Y: {}", floor(paddle_ai.y), floor(ball.y)), 20, 90, 14, WHITE);
    
    DrawFPS(700, 20);
    
    EndDrawing();
}

CloseWindow();