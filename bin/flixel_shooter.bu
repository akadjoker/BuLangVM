
require "raylib";
import math;
import raylib;
using raylib;

include "flixel.bu";
 

// ============================================
// TRAJECTORY SYSTEM
// ============================================

class TrajectorySection
{
    var images_per_section;
    var speed_x, speed_y;
    var accel_x, accel_y;
    
    def init(images, sx, sy, ax, ay)
    {
        self.images_per_section = images;
        self.speed_x = sx;
        self.speed_y = sy;
        self.accel_x = ax;
        self.accel_y = ay;
    }
}

class Trajectory
{
    var x_ini, y_ini;
    var sections;
    
    def init(x, y)
    {
        self.x_ini = x;
        self.y_ini = y;
        self.sections = [];
    }
    
    def addSection(images, sx, sy, ax, ay)
    {
        self.sections.push(TrajectorySection(images, sx, sy, ax, ay));
    }
}


// ============================================
// TRAJECTORY DEFINITIONS (do DIV!)
// ============================================

def createTrajectories()
{
    var trajectories = [];
    
    // Pattern 0: Zigzag vertical (do DIV trajectory 0)
    var t0 = Trajectory(630, 240);
    t0.addSection(12, 0, -8, 0, 0);    // Sobe
    t0.addSection(24, 0, 8, 0, 0);     // Desce
    t0.addSection(12, 0, -8, 0, 0);    // Sobe
    t0.addSection(15, -32, -15, 0, 1); // Diagonal com accel
    t0.addSection(30, 16, 0, 0, 0);    // Move horizontalmente
    t0.addSection(12, 0, 8, 0, 0);     // Desce
    t0.addSection(15, -32, 15, 0, -1); // Diagonal inversa
    t0.addSection(30, 16, 0, 0, 0);    // Move horizontalmente
    t0.addSection(12, 0, -8, 0, 0);    // Sobe
    t0.addSection(30, -16, 0, 0, 0);   // Move esquerda
    t0.addSection(30, 16, 0, 0, 0);    // Move direita
    t0.addSection(15, -32, 15, 0, -1); // Diagonal
    t0.addSection(24, 0, -8, 0, 0);    // Sobe
    t0.addSection(30, 16, 0, 0, 0);    // Move direita
    t0.addSection(15, -32, 15, 0, -1); // Diagonal
    t0.addSection(30, 16, 0, 0, 0);    // Move direita
    t0.addSection(15, -32, -15, 0, 1); // Diagonal inversa
    t0.addSection(12, 0, 8, 0, 0);     // Desce
    t0.addSection(30, 16, 0, 0, 0);    // Move direita
    trajectories.push(t0);
    
    // Pattern 1: Entrada rápida horizontal (DIV trajectory 1)
    var t1 = Trajectory(650, 280);
    t1.addSection(80, -35, 0, 1, 0); // Vem da direita com aceleração
    trajectories.push(t1);
    
    // Pattern 2: Movimento ondulado (DIV trajectory 2)
    var t2 = Trajectory(300, 20);
    t2.addSection(18, 1, 1, 1, 1);     // Diagonal lenta
    t2.addSection(30, 15, 15, -5, 1);  // Acelera e desacelera
    trajectories.push(t2);
    
    // Pattern 3: Onda sinusoidal (DIV trajectory 3)
    var t3 = Trajectory(0, 60);
    t3.addSection(22, 25, 0, 0, 0);    // Move direita rápido
    t3.addSection(5, 0, 10, 0, 0);     // Desce
    t3.addSection(20, -25, 10, 0, 0);  // Esquerda + desce
    t3.addSection(20, 0, -10, 0, 0);   // Sobe
    t3.addSection(20, 25, 10, 0, 0);   // Direita + desce
    t3.addSection(5, 0, 10, 0, 0);     // Desce
    t3.addSection(20, -25, 0, -1, 0);  // Esquerda com desaceleração
    trajectories.push(t3);
    
    // Pattern 4: Espiral de entrada (DIV trajectory 4)
    var t4 = Trajectory(630, 150);
    t4.addSection(5, -8, 0, 0, 0);     // Entra
    t4.addSection(8, -6, -9, 0, 0);    // Curva 1
    t4.addSection(16, -7, 9, 0, 0);    // Curva 2
    t4.addSection(16, -6, -9, 0, 0);   // Curva 3
    t4.addSection(16, -7, 9, 0, 0);    // Curva 4
    t4.addSection(20, -10, 0, -2, 0);  // Sai com desaceleração
    trajectories.push(t4);
    
    // Pattern 5: Espiral inversa (DIV trajectory 5)
    var t5 = Trajectory(630, 200);
    t5.addSection(5, -8, 0, 0, 0);     // Entra
    t5.addSection(8, -6, 9, 0, 0);     // Curva baixo 1
    t5.addSection(16, -7, -9, 0, 0);   // Curva cima 2
    t5.addSection(16, -6, 9, 0, 0);    // Curva baixo 3
    t5.addSection(16, -7, -9, 0, 0);   // Curva cima 4
    t5.addSection(20, -10, 0, -2, 0);  // Sai
    trajectories.push(t5);
    
    // Pattern 6: S-shape (DIV trajectory 6)
    var t6 = Trajectory(630, 250);
    t6.addSection(26, -15, 0, 0, 0);   // Move esquerda
    t6.addSection(12, -12, -10, 2, 0); // Curva cima com accel
    t6.addSection(12, 15, 0, 0, 0);    // Direita
    t6.addSection(12, 12, 10, -2, 0);  // Curva baixo com desaccel
    t6.addSection(20, -15, 0, -1, 0);  // Sai esquerda
    trajectories.push(t6);
    
    // Pattern 7: Loop vertical (DIV trajectory 7)
    var t7 = Trajectory(630, 110);
    t7.addSection(10, 0, 10, 0, 0);    // Desce
    t7.addSection(32, -10, 0, 0, 0);   // Esquerda
    t7.addSection(8, -10, 10, 0, 0);   // Diagonal baixo-esq
    t7.addSection(8, 10, 10, 0, 0);    // Diagonal baixo-dir
    t7.addSection(34, 10, 0, 0, 0);    // Direita
    t7.addSection(8, 0, -10, 0, 0);    // Sobe
    t7.addSection(40, -10, 0, -1, 0);  // Sai esquerda
    trajectories.push(t7);
    
    // Pattern 8: Ziguezague agressivo (DIV trajectory 8)
    var t8 = Trajectory(630, 0);
    t8.addSection(25, -10, 25, 0, -1); // Diagonal com desaccel
    t8.addSection(20, -20, -10, 2, 0); // Curva cima
    t8.addSection(20, 20, 10, -2, 0);  // Curva baixo
    t8.addSection(20, -20, -10, 2, 0); // Curva cima
    t8.addSection(20, 20, 10, -2, 0);  // Curva baixo
    t8.addSection(20, -20, -10, 2, 0); // Curva cima
    t8.addSection(20, 20, 10, -2, 0);  // Curva baixo
    t8.addSection(30, -10, 0, -2, 0);  // Sai
    trajectories.push(t8);
    
    // Pattern 9: Onda sinusoidal 2 (DIV trajectory 9)
    var t9 = Trajectory(0, 220);
    t9.addSection(22, 25, 0, 0, 0);    // Move direita
    t9.addSection(5, 0, 10, 0, 0);     // Desce
    t9.addSection(20, -25, 10, 0, 0);  // Esquerda + desce
    t9.addSection(20, 0, -10, 0, 0);   // Sobe
    t9.addSection(20, 25, 10, 0, 0);   // Direita + desce
    t9.addSection(5, 0, 10, 0, 0);     // Desce
    t9.addSection(20, -25, 0, -1, 0);  // Sai esquerda
    trajectories.push(t9);
    
    // Pattern 10: Espiral complexa (DIV trajectory 10)
    var t10 = Trajectory(640, 140);
    t10.addSection(8, -10, 0, 0, 3);    // Entra com accel Y
    t10.addSection(16, -10, 21, 0, -3); // Grande curva 1
    t10.addSection(16, -10, -24, 0, 3); // Grande curva 2
    t10.addSection(16, -10, 21, 0, -3); // Grande curva 3
    t10.addSection(16, -10, -24, 0, 3); // Grande curva 4
    t10.addSection(16, -10, 21, 0, -3); // Grande curva 5
    trajectories.push(t10);
    
    return trajectories;
}// ============================================
// ANIMATION SYSTEM
// ============================================

class Animation
{
    var frames;
    var current_frame;
    var frame_time;
    var elapsed;
    
    def init(frame_indices, fps)
    {
        self.frames = frame_indices;
        self.current_frame = 0;
        self.frame_time = 1.0 / fps;
        self.elapsed = 0.0;
    }
    
    def update(dt)
    {
        self.elapsed = self.elapsed + dt;
        
        if (self.elapsed >= self.frame_time)
        {
            self.elapsed = self.elapsed - self.frame_time;
            self.current_frame = self.current_frame + 1;
            
            if (self.current_frame >= len(self.frames))
            {
                self.current_frame = 0;
            }
        }
    }
    
    def getCurrentFrame()
    {
        return self.frames[self.current_frame];
    }
}

// ============================================
// ENEMY SYSTEM
// ============================================

class Enemy : Object
{
    var type;
    var trajectory;
    var animation;
    
    var current_section;
    var images_counter; // Conta imagens na secção atual
    
    var speed_x, speed_y;
    var accel_x, accel_y;
    
    var health;
    var points;
    
    def init(enemy_type, traj, group)
    {
        self.type = enemy_type;
        self.trajectory = traj;
        
        // Initialize from trajectory
        self.x = traj.x_ini;
        self.y = traj.y_ini;
        self.width = 32;
        self.height = 32;
        
        // Setup first section
        self.current_section = 0;
        self.images_counter = 0;
        self.loadSection();
        
        // Stats
        self.health = enemy_type + 1;
        if (enemy_type == 5) self.health = 40;
        self.points = (enemy_type + 3) * 50;
        
        self.exists = true;
        self.active = true;
        
        // Animation
        var anim_frames = [0, 1, 2, 3, 4, 5, 6, 7];
        self.animation = Animation(anim_frames, 12.0);
    }
    
    def loadSection()
    {
        if (self.current_section < len(self.trajectory.sections))
        {
            var section = self.trajectory.sections[self.current_section];
            self.speed_x = section.speed_x;
            self.speed_y = section.speed_y;
            self.accel_x = section.accel_x;
            self.accel_y = section.accel_y;
        }
    }
    
    def update(elapsed)
    {
        if (!self.active || !self.exists)
        {
            return;
        }
        
        // Update animation
        self.animation.update(elapsed);
        
        // Apply acceleration (como no DIV!)
        self.speed_x = self.speed_x + self.accel_x;
        self.speed_y = self.speed_y + self.accel_y;
        
        // Update position
        self.x = self.x + self.speed_x;
        self.y = self.y + self.speed_y;
        
        // Section progression (conta CADA frame!)
        self.images_counter = self.images_counter + 1;
        
        var section = self.trajectory.sections[self.current_section];
        if (self.images_counter >= section.images_per_section)
        {
            self.images_counter = 0;
            self.current_section = self.current_section + 1;
            
            // Loop trajectory
            if (self.current_section >= len(self.trajectory.sections))
            {
                self.current_section = 0;
            }
            
            self.loadSection();
        }
        
        // Out of bounds
        if (self.x < -50 || self.x > 850 || self.y < -50 || self.y > 650)
        {
            self.exists = false;
        }
    }
    
 
    def takeDamage(amount)
    {
        self.health = self.health - amount;
        
        if (self.health <= 0)
        {
            self.exists = false;
            return true; // Dead
        }
        
        return false;
    }
    
    def draw()
    {
        if (!self.exists)
        {
            return;
        }
        
        // Draw based on animation frame
        var color = Color(255, 100, 100, 255);
        
        // Type-based colors
        if (self.type == 0) color = Color(255, 100, 100, 255);
        if (self.type == 1) color = Color(100, 255, 100, 255);
        if (self.type == 2) color = Color(100, 100, 255, 255);
        if (self.type == 3) color = Color(255, 255, 100, 255);
        if (self.type == 4) color = Color(255, 100, 255, 255);
        
        DrawRectangle(self.x, self.y, self.width, self.height, color);
        DrawRectangleLines(self.x, self.y, self.width, self.height, Color(255, 255, 255, 180));
        
        // Health bar
        var bar_width = (self.width * self.health) / (self.type + 1);
        DrawRectangle(self.x, self.y - 5, bar_width, 3, Color(0, 255, 0, 255));
    }
}

// ============================================
// BULLET SYSTEM
// ============================================

class Bullet : Object
{
    var damage;
    var owner; // "player" or "enemy"
    
    def init(x, y, vx, vy, dmg, owner_type)
    {
        self.x = x;
        self.y = y;
        self.width = 4;
        self.height = 8;
        self.velocityX = vx;
        self.velocityY = vy;
        self.damage = dmg;
        self.owner = owner_type;
        self.exists = true;
        self.active = true;
    }
    
    def update(elapsed)
    {
        self.x = self.x + self.velocityX;
        self.y = self.y + self.velocityY;
        
        // Out of bounds
        if (self.x < 0 || self.x > 800 || self.y < 0 || self.y > 600)
        {
            self.exists = false;
        }
    }
    
    def draw()
    {
        var color = Color(255, 255, 0, 255);
        if (self.owner == "enemy")
        {
            color = Color(255, 0, 0, 255);
        }
        
        DrawRectangle(self.x, self.y, self.width, self.height, color);
    }
}

// ============================================
// PLAYER SHIP
// ============================================

class Player : Object
{
    var health;
    var max_health;
    var fire_cooldown;
    var fire_rate;
    
    def init(x, y)
    {
        self.x = x;
        self.y = y;
        self.width = 32;
        self.height = 32;
        self.velocityX = 0.0;
        self.velocityY = 0.0;
        self.maxVelocityX = 300.0;
        self.maxVelocityY = 300.0;
        self.health = 5;
        self.max_health = 5;
        self.fire_cooldown = 0.0;
        self.fire_rate = 0.15; // Seconds between shots
        self.exists = true;
        self.active = true;
    }
    
    def update(elapsed)
    {
        // Update fire cooldown
        if (self.fire_cooldown > 0.0)
        {
            self.fire_cooldown = self.fire_cooldown - elapsed;
        }
        
        // Update position
        self.x = self.x + self.velocityX * elapsed;
        self.y = self.y + self.velocityY * elapsed;
        
        // Screen bounds
        if (self.x < 0) self.x = 0;
        if (self.x > 800 - self.width) self.x = 800 - self.width;
        if (self.y < 0) self.y = 0;
        if (self.y > 600 - self.height) self.y = 600 - self.height;
    }
    
    def canFire()
    {
        return self.fire_cooldown <= 0.0;
    }
    
    def fire()
    {
        self.fire_cooldown = self.fire_rate;
    }
    
    def takeDamage(amount)
    {
        self.health = self.health - amount;
        return self.health <= 0;
    }
    
    def draw()
    {
        DrawRectangle(self.x, self.y, self.width, self.height, Color(0, 255, 0, 255));
        DrawTriangle(
            Vector2(self.x + self.width/2, self.y - 5),
            Vector2(self.x, self.y),
            Vector2(self.x + self.width, self.y),
            Color(0, 200, 0, 255)
        );
    }
}

// ============================================
// GAME SETUP
// ============================================

InitWindow(800, 600, "BuLang Shooter");
SetTargetFPS(30);
 

var trajectories = createTrajectories();

var player = Player(400, 500);
var enemies = Group();
var bullets = Group();

// Spawn com diferentes patterns
enemies.add(Enemy(0, trajectories[0], 0)); // Zigzag
enemies.add(Enemy(1, trajectories[4], 0)); // Espiral
enemies.add(Enemy(2, trajectories[8], 0)); // Ziguezague agressivo

var score = 0;
var spawn_timer = 0.0;
var wave = 0;

while (!WindowShouldClose())
{
    var dt = GetFrameTime();
    
    // ============================================
    // INPUT
    // ============================================
    
    player.velocityX = 0;
    player.velocityY = 0;
    
    if (IsKeyDown(KEY_RIGHT)) player.velocityX = player.maxVelocityX;
    if (IsKeyDown(KEY_LEFT)) player.velocityX = -player.maxVelocityX;
    if (IsKeyDown(KEY_UP)) player.velocityY = -player.maxVelocityY;
    if (IsKeyDown(KEY_DOWN)) player.velocityY = player.maxVelocityY;
    
    if (IsKeyDown(KEY_SPACE) && player.canFire())
    {
        bullets.add(Bullet(player.x + player.width/2 - 2, player.y, 0, -10, 1, "player"));
        player.fire();
    }
    
    // ============================================
    // UPDATE
    // ============================================
    
    player.update(dt);
    enemies.update(dt);
    bullets.update(dt);
    
    // Spawn timer
    spawn_timer = spawn_timer + dt;
    if (spawn_timer > 3.0 && len(enemies.members) < 28)
    {
        var pattern_id = math.rand(11); // 0-10
        var enemy_type = math.rand(5);  // 0-4
        
        enemies.add(Enemy(enemy_type, trajectories[pattern_id], wave));
        spawn_timer = 0.0;
    }
    
    // ============================================
    // COLLISIONS
    // ============================================
    
    // Bullets vs Enemies
    for (var i = 0; i < len(bullets.members); i = i + 1)
    {
        var bullet = bullets.members[i];
        if (!bullet.exists || bullet.owner != "player") continue;
        
        for (var j = 0; j < len(enemies.members); j = j + 1)
        {
            var enemy = enemies.members[j];
            if (!enemy.exists) continue;
            
            if (checkOverlap(bullet, enemy))
            {
                bullet.exists = false;
                if (enemy.takeDamage(bullet.damage))
                {
                    score = score + enemy.points;
                }
                break;
            }
        }
    }
    
    // Player vs Enemies
    for (var i = 0; i < len(enemies.members); i = i + 1)
    {
        var enemy = enemies.members[i];
        if (!enemy.exists) continue;
        
        if (checkOverlap(player, enemy))
        {
            enemy.exists = false;
            if (player.takeDamage(1))
            {
                // Game Over
            }
        }
    }
    
    // ============================================
    // RENDER
    // ============================================
    
    BeginDrawing();
    ClearBackground(Color(0, 0, 20, 255));
    
    player.draw();
    enemies.draw();
    bullets.draw();
    
    // UI
    DrawText(format("Score: {}", score), 10, 10, 20, Color(255, 255, 0, 255));
    DrawText(format("Health: {}", player.health), 10, 35, 20, Color(0, 255, 0, 255));
    DrawText(format("Enemies: {}", len(enemies.members)), 10, 60, 16, Color(200, 200, 200, 255));
    DrawFPS(700, 10);
    
    EndDrawing();
}

CloseWindow();