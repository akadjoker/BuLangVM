require "raylib";

import math;
import raylib;

using raylib;

include "vec2.bu";
include "quadtree.bu";

InitWindow(600, 800, "BULang PINBALL - Flippers");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var RED = Color(255, 100, 100, 255);
var GREEN = Color(100, 255, 100, 255);
var YELLOW = Color(255, 255, 100, 255);
var GRAY = Color(80, 80, 80, 255);
var ORANGE = Color(255, 165, 0, 255);
var PURPLE = Color(200, 100, 255, 255);
var CYAN = Color(0, 255, 255, 255);

var GRAVITY = 600.0;

// ==========================================
// RIGID BODY
// ==========================================
struct Contact
{
    var bodyA;
    var bodyB;
    var manifold;
};

struct RigidBody
{
    var type;
    var pos;
    var vel;
    var angle;
    var angularVel;
    var mass;
    var invMass;
    var inertia;
    var invInertia;
    var restitution;
    var friction;
    var radius;
    var vertices;
    var color;
    var isStatic;
    var bounds;
    var id;
    var isBumper;
    var isFlipper;
    var pivot;
    var motorSpeed;
    var maxMotorTorque;
    var lowerAngleLimit;
    var upperAngleLimit;
};

def createCircle(x, y, radius, density)
{
    var body = RigidBody();
    body.type = 0;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;
    body.radius = radius;
    var area = 3.14159 * radius * radius;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * radius * radius * 0.5;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.7;
    body.friction = 0.2;
    body.color = WHITE;
    body.isStatic = false;
    body.bounds = Rect(x, y, radius, radius);
    body.isBumper = false;
    body.isFlipper = false;
    body.pivot = Vec2(0.0, 0.0);
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 0.0;
    body.lowerAngleLimit = 0.0;
    body.upperAngleLimit = 0.0;
    return body;
}

def createBox(x, y, width, height, density)
{
    var body = RigidBody();
    body.type = 1;
    body.pos = Vec2(x, y);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;

    var hw = width / 2.0;
    var hh = height / 2.0;
    body.vertices = [];
    body.vertices.push(Vec2(-hw, -hh));
    body.vertices.push(Vec2(hw, -hh));
    body.vertices.push(Vec2(hw, hh));
    body.vertices.push(Vec2(-hw, hh));

    var area = width * height;
    body.mass = area * density;
    body.invMass = 1.0 / body.mass;
    body.inertia = body.mass * (width * width + height * height) / 12.0 * 3.0;
    body.invInertia = 1.0 / body.inertia;
    body.restitution = 0.0;
    body.friction = 0.7;
    body.color = GRAY;
    body.isStatic = false;
    body.bounds = Rect(0.0, 0.0, hw, hh);
    body.isBumper = false;
    body.isFlipper = false;
    body.pivot = Vec2(0.0, 0.0);
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 0.0;
    body.lowerAngleLimit = 0.0;
    body.upperAngleLimit = 0.0;
    return body;
}

def createStaticBox(x, y, width, height)
{
    var body = createBox(x, y, width, height, 1.0);
    body.isStatic = true;
    body.invMass = 0.0;
    body.invInertia = 0.0;
    body.color = GRAY;
    body.restitution = 0.8;
    body.friction = 0.1;

    body.bounds = Rect(0.0, 0.0, width, height);
    return body;
}
def createFlipper(pivotX, pivotY, width, height, isLeft)
{
    var body = RigidBody();
    body.type = 1;
    body.pivot = Vec2(pivotX, pivotY);
    body.pos = Vec2(pivotX, pivotY);
    body.vel = Vec2(0.0, 0.0);
    body.angle = 0.0;
    body.angularVel = 0.0;
    body.id = 0;

    var hw = width / 2.0;
    var hh = height / 2.0;

    body.vertices = [];
    if (isLeft)
    {
        body.vertices.push(Vec2(0.0, -hh));
        body.vertices.push(Vec2(width, -hh));
        body.vertices.push(Vec2(width, hh));
        body.vertices.push(Vec2(0.0, hh));

        // Left flipper: -30° to +30° (ajustado para bater melhor)
        body.angle = 0.52;  
        body.lowerAngleLimit = -0.52; 
        body.upperAngleLimit = 0.52; 
    }
    else
    {
        body.vertices.push(Vec2(-width, -hh));
        body.vertices.push(Vec2(0.0, -hh));
        body.vertices.push(Vec2(0.0, hh));
        body.vertices.push(Vec2(-width, hh));

        // Right flipper
        body.angle = -0.52; 
        body.lowerAngleLimit = -0.52;
        body.upperAngleLimit = 0.52;  
    }

    body.bounds = Rect(0.0, 0.0, hw, hh);

    // --- CORREÇÃO DE FÍSICA ---
    // Usamos uma massa fixa baixa para o jogo ser rápido
    body.mass = 20.0; 
    
    // invMass = 0 diz ao motor de física para NÃO mover a posição (pino)
    // Mas invInertia > 0 diz que PODE rodar
    body.invMass = 1.0 / body.mass;

    
    // Momento de inércia para um retângulo a rodar numa ponta (Axis Theorem seria melhor, mas Box chega)
    // Inertia = m * (w^2 + h^2) / 12
    body.inertia = body.mass * (width * width + height * height) / 12.0;
    body.invInertia = 1.0 / body.inertia;

    body.restitution = 0.9; // Menos elástico para não ser caótico
    body.friction = 0.8;    // Muita frição para "agarrar" a bola
    body.color = YELLOW;
    body.isStatic = false;  
    body.isBumper = false;
    body.isFlipper = true;

    
    body.motorSpeed = 0.0;
    body.maxMotorTorque = 2000000.0; 

    return body;
}

// ==========================================
// POLYGON HELPERS
// ==========================================
def getTransformedVertices(body)
{
    if (body.type != 1)
    {
        return [];
    }

    var transformed = [];
    var c = cos(body.angle);
    var s = sin(body.angle);

    if (body.isFlipper)
    {
        for (var i = 0; i < len(body.vertices); i = i + 1)
        {
            var v = body.vertices[i];
            var rx = v.x * c - v.y * s;
            var ry = v.x * s + v.y * c;
            transformed.push(Vec2(rx + body.pivot.x, ry + body.pivot.y));
        }
    }
    else
    {
        for (var i = 0; i < len(body.vertices); i = i + 1)
        {
            var v = body.vertices[i];
            var rx = v.x * c - v.y * s;
            var ry = v.x * s + v.y * c;
            transformed.push(Vec2(rx + body.pos.x, ry + body.pos.y));
        }
    }

    return transformed;
}

def calculateNormals(vertices)
{
    var normals = [];
    for (var i = 0; i < len(vertices); i = i + 1)
    {
        var v1 = vertices[i];
        var v2 = vertices[(i + 1) % len(vertices)];
        var edge = sub(v2, v1);
        var normal = normalize(perp(edge));
        normals.push(normal);
    }
    return normals;
}

def getSupport(vertices, dir)
{
    var bestProj = -999999.0;
    var bestVertex = vertices[0];
    for(var i = 0; i < len(vertices); i = i + 1)
    {
        var v = vertices[i];
        var proj = dot(v, dir);
        if (proj > bestProj)
        {
            bestProj = proj;
            bestVertex = v;
        }
    }
    return bestVertex;
}

def projectPolygon(vertices, axis)
{
    var min = dot(vertices[0], axis);
    var max = min;
    for (var i = 1; i < len(vertices); i = i + 1)
    {
        var p = dot(vertices[i], axis);
        if (p < min) min = p;
        if (p > max) max = p;
    }
    return [min, max];
}

def projectCircle(center, radius, axis)
{
    var p = dot(center, axis);
    return [p - radius, p + radius];
}

// ==========================================
// SAT COLLISION
// ==========================================
struct Manifold
{
    var hasCollision;
    var normal;
    var penetration;
    var contacts;
};

def checkCircleCircle(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var delta = sub(b.pos, a.pos);
    var distSq = lengthSq(delta);
    var radiusSum = a.radius + b.radius;

    if (distSq >= radiusSum * radiusSum)
    {
        return manifold;
    }

    var dist = sqrt(distSq);
    manifold.hasCollision = true;
    manifold.penetration = radiusSum - dist;

    if (dist > 0.0001)
    {
        manifold.normal = normalize(delta);
    }
    else
    {
        manifold.normal = Vec2(1.0, 0.0);
    }

    manifold.contacts = [];
    manifold.contacts.push(add(a.pos, scale(manifold.normal, a.radius)));
    return manifold;
}

def checkPolygonPolygon(a, b)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var vertsA = getTransformedVertices(a);
    var vertsB = getTransformedVertices(b);
    var normalsA = calculateNormals(vertsA);
    var normalsB = calculateNormals(vertsB);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normalsA); i = i + 1)
    {
        var axis = normalsA[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    for (var i = 0; i < len(normalsB); i = i + 1)
    {
        var axis = normalsB[i];
        var projA = projectPolygon(vertsA, axis);
        var projB = projectPolygon(vertsB, axis);
        if (projA[1] < projB[0] || projB[1] < projA[0]) return manifold;
        var overlap = min(projA[1], projB[1]) - max(projA[0], projB[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(b.pos, a.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    var dirToA = scale(manifold.normal, -1.0);
    var contactOnB = getSupport(vertsB, dirToA);

    manifold.contacts = [];
    manifold.contacts.push(contactOnB);
    return manifold;
}

def checkCirclePolygon(circle, poly)
{
    var manifold = Manifold();
    manifold.hasCollision = false;
    var verts = getTransformedVertices(poly);
    var normals = calculateNormals(verts);

    var minOverlap = 999999.0;
    var bestAxis = Vec2(0.0, 0.0);

    for (var i = 0; i < len(normals); i = i + 1)
    {
        var axis = normals[i];
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    var closestDist = 999999.0;
    var closestVert = verts[0];
    for (var i = 0; i < len(verts); i = i + 1)
    {
        var dist = lengthSq(sub(verts[i], circle.pos));
        if (dist < closestDist)
        {
            closestDist = dist;
            closestVert = verts[i];
        }
    }

    var toClosest = sub(closestVert, circle.pos);
    if (lengthSq(toClosest) > 0.0001)
    {
        var axis = normalize(toClosest);
        var projCircle = projectCircle(circle.pos, circle.radius, axis);
        var projPoly = projectPolygon(verts, axis);
        if (projCircle[1] < projPoly[0] || projPoly[1] < projCircle[0])
        {
            return manifold;
        }
        var overlap = min(projCircle[1], projPoly[1]) - max(projCircle[0], projPoly[0]);
        if (overlap < minOverlap)
        {
            minOverlap = overlap;
            bestAxis = axis;
        }
    }

    manifold.hasCollision = true;
    manifold.penetration = minOverlap;

    var delta = sub(poly.pos, circle.pos);
    if (dot(delta, bestAxis) < 0.0)
    {
        bestAxis = scale(bestAxis, -1.0);
    }

    manifold.normal = bestAxis;
    manifold.contacts = [];
    manifold.contacts.push(add(circle.pos, scale(bestAxis, circle.radius)));
    return manifold;
}

def checkCollision(a, b)
{
    if (a.type == 0 && b.type == 0)
    {
        return checkCircleCircle(a, b);
    }
    else if (a.type == 1 && b.type == 1)
    {
        return checkPolygonPolygon(a, b);
    }
    else if (a.type == 0 && b.type == 1)
    {
        return checkCirclePolygon(a, b);
    }
    else
    {
        var m = checkCirclePolygon(b, a);
        if (m.hasCollision)
        {
            m.normal = scale(m.normal, -1.0);
        }
        return m;
    }
}

// ==========================================
// COLLISION RESOLUTION
// ==========================================
def resolveCollisionImpulse(a, b, manifold)
{
    if (a.isStatic && b.isStatic)
    {
        return;
    }

    for (var c = 0; c < len(manifold.contacts); c = c + 1)
    {
        var contactPoint = manifold.contacts[c];

        var centerA = a.pos;
        var centerB = b.pos;
        if (a.isFlipper) centerA = a.pivot;
        if (b.isFlipper) centerB = b.pivot;

        var ra = sub(contactPoint, centerA);
        var rb = sub(contactPoint, centerB);

        var vaLinear = a.vel;
        var vbLinear = b.vel;
        var vaAngular = Vec2(-a.angularVel * ra.y, a.angularVel * ra.x);
        var vbAngular = Vec2(-b.angularVel * rb.y, b.angularVel * rb.x);

        var va = add(vaLinear, vaAngular);
        var vb = add(vbLinear, vbAngular);
        var rv = sub(vb, va);

        var velAlongNormal = dot(rv, manifold.normal);

        if (velAlongNormal > 0.0)
        {
            continue;
        }

        var e = min(a.restitution, b.restitution);

        if (a.isBumper || b.isBumper)
        {
            e = 1.5;
        }
        else if (abs(velAlongNormal) < 50.0)
        {
            e = 0.0;
        }

        var raCrossN = cross(ra, manifold.normal);
        var rbCrossN = cross(rb, manifold.normal);
        var invMassSum = a.invMass + b.invMass +
                        raCrossN * raCrossN * a.invInertia +
                        rbCrossN * rbCrossN * b.invInertia;

        var j = -(1.0 + e) * velAlongNormal;
        j = j / invMassSum;
        j = j / len(manifold.contacts);

        var impulse = scale(manifold.normal, j);

        if (!a.isStatic)
        {
            a.vel = sub(a.vel, scale(impulse, a.invMass));
            a.angularVel = a.angularVel - cross(ra, impulse) * a.invInertia;
        }

        if (!b.isStatic)
        {
            b.vel = add(b.vel, scale(impulse, b.invMass));
            b.angularVel = b.angularVel + cross(rb, impulse) * b.invInertia;
        }

        // Fricção
        rv = sub(add(vbLinear, Vec2(-b.angularVel * rb.y, b.angularVel * rb.x)),
                 add(vaLinear, Vec2(-a.angularVel * ra.y, a.angularVel * ra.x)));

        var tangent = sub(rv, scale(manifold.normal, dot(rv, manifold.normal)));
        if (lengthSq(tangent) > 0.0001)
        {
            tangent = normalize(tangent);
            var raCrossT = cross(ra, tangent);
            var rbCrossT = cross(rb, tangent);
            var invMassSumT = a.invMass + b.invMass +
                            raCrossT * raCrossT * a.invInertia +
                            rbCrossT * rbCrossT * b.invInertia;

            var jt = -dot(rv, tangent);
            jt = jt / invMassSumT;
            jt = jt / len(manifold.contacts);

            var mu = sqrt(a.friction * a.friction + b.friction * b.friction);
            var frictionImpulse;

            if (abs(jt) < j * mu)
            {
                frictionImpulse = scale(tangent, jt);
            }
            else
            {
                frictionImpulse = scale(tangent, -j * mu);
            }

            if (!a.isStatic)
            {
                a.vel = sub(a.vel, scale(frictionImpulse, a.invMass));
                a.angularVel = a.angularVel - cross(ra, frictionImpulse) * a.invInertia;
            }

            if (!b.isStatic)
            {
                b.vel = add(b.vel, scale(frictionImpulse, b.invMass));
                b.angularVel = b.angularVel + cross(rb, frictionImpulse) * b.invInertia;
            }
        }
    }
}

// ==========================================
// MOTOR SIMULATION 
// ==========================================
def applyMotor(flipper, dt)
{
    if (!flipper.isFlipper) return;

    var targetAngle = flipper.motorSpeed;
    
    var angleError = targetAngle - flipper.angle;
    var desiredAngularVel = angleError * 60.0; 
    var angularError = desiredAngularVel - flipper.angularVel;
    
    var torque = angularError * flipper.inertia * 150.0;
    
    // Clamp torque
    if (torque > flipper.maxMotorTorque) torque = flipper.maxMotorTorque;
    if (torque < -flipper.maxMotorTorque) torque = -flipper.maxMotorTorque;
    
    // Apply torque
    flipper.angularVel = flipper.angularVel + torque * flipper.invInertia * dt;
    
    // Limites (SEM zerar angularVel!)
    if (flipper.angle < flipper.lowerAngleLimit)
    {
        flipper.angle = flipper.lowerAngleLimit;
    }
    if (flipper.angle > flipper.upperAngleLimit)
    {
        flipper.angle = flipper.upperAngleLimit;
    }
}



// Constraint para manter flipper no pivot
def constrainFlipperToPivot(flipper)
{
    if (!flipper.isFlipper) return;

    // Flipper NÃO se move linearmente! Apenas roda
    flipper.pos = flipper.pivot;
    flipper.vel = Vec2(0.0, 0.0);
}

// ==========================================
// HELPERS
// ==========================================
def min(a, b)
{
    if (a < b) return a;
    return b;
}

def max(a, b)
{
    if (a > b) return a;
    return b;
}

def updateAABB(body)
{
    if (body.type == 0)
    {
        body.bounds.x = body.pos.x;
        body.bounds.y = body.pos.y;
        body.bounds.w = body.radius;
        body.bounds.h = body.radius;
    }
    else
    {
        var verts = getTransformedVertices(body);
        var minX = 999999.0;
        var maxX = -999999.0;
        var minY = 999999.0;
        var maxY = -999999.0;

        for(var i = 0; i < len(verts); i = i + 1)
        {
            var v = verts[i];
            if (v.x < minX) minX = v.x;
            if (v.x > maxX) maxX = v.x;
            if (v.y < minY) minY = v.y;
            if (v.y > maxY) maxY = v.y;
        }

        body.bounds.x = (minX + maxX) / 2.0;
        body.bounds.y = (minY + maxY) / 2.0;
        body.bounds.w = (maxX - minX) / 2.0;
        body.bounds.h = (maxY - minY) / 2.0;
    }
}

// ==========================================
// WORLD SETUP
// ==========================================
var IDS = 0;
var bodies = [];
var score = 0;
var ball;
var flipperLeft;
var flipperRight;

def createWorld()
{

// Paredes
IDS = IDS + 1;
var leftWall = createStaticBox(15, 400, 30, 800);
leftWall.id = IDS;
bodies.push(leftWall);

IDS = IDS + 1;
var rightWall = createStaticBox(585, 400, 30, 800);
rightWall.id = IDS;
bodies.push(rightWall);

IDS = IDS + 1;
var topWall = createStaticBox(300, 15, 600, 30);
topWall.id = IDS;
bodies.push(topWall);

// Paredes inclinadas
IDS = IDS + 1;
var leftSlant = createStaticBox(100, 100, 140, 15);
leftSlant.angle = 0.6;
leftSlant.id = IDS;
bodies.push(leftSlant);

IDS = IDS + 1;
var rightSlant = createStaticBox(500, 100, 140, 15);
rightSlant.angle = -0.6;
rightSlant.id = IDS;
bodies.push(rightSlant);

// Flippers CORRIGIDOS!
IDS = IDS + 1;
flipperLeft = createFlipper(170, 700, 120, 16, true);
flipperLeft.id = IDS;
bodies.push(flipperLeft);


IDS = IDS + 1;
flipperRight = createFlipper(430, 700, 120, 16, false);
flipperRight.id = IDS;
bodies.push(flipperRight);

// Bumpers
IDS = IDS + 1;
var bumper1 = createCircle(200, 280, 30, 1.0);
bumper1.isStatic = true;
bumper1.invMass = 0.0;
bumper1.invInertia = 0.0;
bumper1.color = RED;
bumper1.isBumper = true;
bumper1.id = IDS;
bodies.push(bumper1);

IDS = IDS + 1;
var bumper2 = createCircle(400, 280, 30, 1.0);
bumper2.isStatic = true;
bumper2.invMass = 0.0;
bumper2.invInertia = 0.0;
bumper2.color = RED;
bumper2.isBumper = true;
bumper2.id = IDS;
bodies.push(bumper2);

IDS = IDS + 1;
var bumper3 = createCircle(300, 400, 30, 1.0);
bumper3.isStatic = true;
bumper3.invMass = 0.0;
bumper3.invInertia = 0.0;
bumper3.color = RED;
bumper3.isBumper = true;

bumper3.id = IDS;
bodies.push(bumper3);

// Obstáculos
IDS = IDS + 1;
var obstacle1 = createStaticBox(150, 500, 50, 12);
obstacle1.angle = 0.5;
obstacle1.id = IDS;
obstacle1.restitution = 0.9;
obstacle1.color = PURPLE;
 
bodies.push(obstacle1);

IDS = IDS + 1;
var obstacle2 = createStaticBox(450, 500, 50, 12);
obstacle2.angle = -0.5;
obstacle2.restitution = 0.9;
obstacle2.id = IDS;
obstacle2.color = PURPLE;
 
bodies.push(obstacle2);

// Bola
IDS = IDS + 1;
ball = createCircle(300, 200, 12, 1.0);
ball.id = IDS;
ball.color = CYAN;
ball.restitution = 0.9;
ball.friction = 0.02;
ball.mass = 1.0;
ball.invMass = 1.0 / ball.mass; 
bodies.push(ball);
}

def renderWorld()
{
      for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];
        if (body.type == 0)
        {
            DrawCircle(body.pos.x, body.pos.y, body.radius, body.color);

            if (body.isBumper)
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 5, ORANGE);
                DrawCircleLines(body.pos.x, body.pos.y, body.radius + 8, ORANGE);
            }
            else
            {
                DrawCircleLines(body.pos.x, body.pos.y, body.radius, WHITE);
            }
        }
        else
        {
            var verts = getTransformedVertices(body);
            for (var j = 0; j < len(verts); j = j + 1)
            {
                var v1 = verts[j];
                var v2 = verts[(j + 1) % len(verts)];
                DrawLineEx(v1.x, v1.y      ,v2.x, v2.y, 5.0, body.color);
            }

            if (body.isFlipper)
            {
                DrawCircle(body.pivot.x, body.pivot.y, 7, GREEN);
                DrawCircleLines(body.pivot.x, body.pivot.y, 10, WHITE);
            }
        }
    }
}




// ==========================================
// MAIN LOOP
// ==========================================
var screenRect = Rect();
screenRect.x = 300;
screenRect.y = 400;
screenRect.w = 300;
screenRect.h = 400;
createWorld();
var ballRef = ball;

while (!WindowShouldClose())
{
    var dt = 1.0 / 60.0;

   // Motor control
 
if (IsKeyDown(KEY_A) || IsKeyDown(KEY_LEFT))
{
    flipperLeft.motorSpeed = flipperLeft.lowerAngleLimit;  
}
else
{
    flipperLeft.motorSpeed = flipperLeft.upperAngleLimit;  
}

if (IsKeyDown(KEY_D) || IsKeyDown(KEY_RIGHT))
{
    flipperRight.motorSpeed = flipperRight.upperAngleLimit;   
}
else
{
    flipperRight.motorSpeed = flipperRight.lowerAngleLimit;   
}



    // Nova bola
    if (IsKeyPressed(KEY_SPACE))
    {
        ballRef.pos.x = 550.0;
        ballRef.pos.y = 100.0;
        ballRef.vel = Vec2(-100.0, 0.0);
        ballRef.angularVel = 0.0;
    }

    // Physics step
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var body = bodies[i];

        if (body.isFlipper)
        {
            // Apply motor
            applyMotor(body, dt);

            // Update rotation
            body.angle = body.angle + body.angularVel * dt;

            // Damping
            body.angularVel = body.angularVel * 0.98;

            // Constraint ao pivot
            constrainFlipperToPivot(body);
        }
        else if (!body.isStatic)
        {
            body.vel.y = body.vel.y + GRAVITY * dt;
            body.pos = add(body.pos, scale(body.vel, dt));
            body.angle = body.angle + body.angularVel * dt;
            body.vel = scale(body.vel, 0.998);
            body.angularVel = body.angularVel * 0.98;

            if (abs(body.angularVel) < 0.02)
            {
                body.angularVel = 0.0;
            }
        }

        updateAABB(body);
    }

    // QuadTree
    var qt = createQuadTree(screenRect, 4);
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        insertQT(qt, bodies[i]);
    }

    // Collision detection
    var contacts = [];
    for (var i = 0; i < len(bodies); i = i + 1)
    {
        var bodyA = bodies[i];
        var candidates = [];
        queryQT(qt, bodyA.bounds, candidates);

        for (var j = 0; j < len(candidates); j = j + 1)
        {
            var bodyB = candidates[j];

            if (bodyA.id != bodyB.id && bodyA.id < bodyB.id)
            {
                if (intersectsRect(bodyA.bounds, bodyB.bounds))
                {
                    var manifold = checkCollision(bodyA, bodyB);
                    if (manifold.hasCollision)
                    {
                        var c = Contact();
                        c.bodyA = bodyA;
                        c.bodyB = bodyB;
                        c.manifold = manifold;
                        contacts.push(c);

                        // Score
                        if ((bodyA.isBumper || bodyB.isBumper) && 
                            (bodyA.id == ballRef.id || bodyB.id == ballRef.id))
                        {
                            score = score + 100;
                        }
                    }
                }
            }
        }
    }

 
    for (var i = 0; i < len(contacts); i = i + 1)
    {
        var c = contacts[i];
        var a = c.bodyA;
        var b = c.bodyB;
        var manifold = c.manifold;

        // Flippers não movem linearmente!
        var aCanMove = !a.isStatic ;
        var bCanMove = !b.isStatic ;

        if (aCanMove || bCanMove)
        {
            var percent = 0.4;
            var slop = 0.05;

            var totalInvMass = 0.0;
            if (aCanMove) totalInvMass = totalInvMass + a.invMass;
            if (bCanMove) totalInvMass = totalInvMass + b.invMass;

            if (totalInvMass > 0.0001)
            {
                var correctionMag = max(manifold.penetration - slop, 0.0) / totalInvMass * percent;
                var correction = scale(manifold.normal, correctionMag);

                if (aCanMove)
                {
                    a.pos = sub(a.pos, scale(correction, a.invMass));
                }
                if (bCanMove)
                {
                    b.pos = add(b.pos, scale(correction, b.invMass));
                }
            }
        }
    }

    // Solver
    var solverIterations = 6;
    for (var iter = 0; iter < solverIterations; iter = iter + 1)
    {
        for (var i = 0; i < len(contacts); i = i + 1)
        {
            var c = contacts[i];
            resolveCollisionImpulse(c.bodyA, c.bodyB, c.manifold);
        }
    }

    // Render
    BeginDrawing();
    ClearBackground(Color(10, 10, 20, 255));
   
    renderWorld();
  

    // UI
    DrawText("FLIPPER!", 20, 20, 32, YELLOW);
    DrawText(format("SCORE: {}", score), 20, 60, 28, GREEN);
    DrawText("A/LEFT - Left Flipper", 350, 20, 18, WHITE);
    DrawText("D/RIGHT - Right Flipper", 350, 45, 18, WHITE);
    DrawText("SPACE - Launch Ball", 350, 70, 18, CYAN);
    DrawFPS(10, 95);

    EndDrawing();
}

CloseWindow();