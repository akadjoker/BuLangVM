require "raylib";
import math;
import raylib;
using raylib;
var screenW = 800;
var screenH = 600;


var renderW = 320;
var renderH = 240;

InitWindow(screenW, screenH, "Real-Time Ray Tracer");
SetTargetFPS(60);

 

var WHITE = Color(255, 255, 255, 255);
var BLACK = Color(0, 0, 0, 255);

// ==========================================
// STRUCTS
// ==========================================

struct Vec3
{
    var x, y, z;
};

struct Ray
{
    var ox, oy, oz;
    var dx, dy, dz;
};

struct Sphere
{
    var cx, cy, cz;
    var radius;
    var r, g, b;
    var reflective;
};

struct HitRecord
{
    var hit;
    var t;
    var sphereIdx;
    var px, py, pz;
    var nx, ny, nz;
};

// ==========================================
// VECTOR MATH
// ==========================================

def dot(ax, ay, az, bx, by, bz)
{
    return ax * bx + ay * by + az * bz;
}

def length(x, y, z)
{
    return sqrt(x * x + y * y + z * z);
}

def reflect(vx, vy, vz, nx, ny, nz)
{
    var d = dot(vx, vy, vz, nx, ny, nz);
    return Vec3(
        vx - 2.0 * d * nx,
        vy - 2.0 * d * ny,
        vz - 2.0 * d * nz
    );
}

// ==========================================
// SPHERE INTERSECTION
// ==========================================

def intersectSphere(ray, sphere)
{
    var ocx = ray.ox - sphere.cx;
    var ocy = ray.oy - sphere.cy;
    var ocz = ray.oz - sphere.cz;
    
    var a = dot(ray.dx, ray.dy, ray.dz, ray.dx, ray.dy, ray.dz);
    var b = 2.0 * dot(ocx, ocy, ocz, ray.dx, ray.dy, ray.dz);
    var c = dot(ocx, ocy, ocz, ocx, ocy, ocz) - sphere.radius * sphere.radius;
    
    var discriminant = b * b - 4.0 * a * c;
    
    if (discriminant < 0.0)
    {
        return -1.0;
    }
    
    var t = (-b - sqrt(discriminant)) / (2.0 * a);
    if (t > 0.001)
    {
        return t;
    }
    
    return -1.0;
}

// ==========================================
// SCENE
// ==========================================

var sphere1 = Sphere();
sphere1.cx = 0.0;
sphere1.cy = 0.0;
sphere1.cz = -5.0;
sphere1.radius = 1.0;
sphere1.r = 1.0;
sphere1.g = 0.3;
sphere1.b = 0.3;
sphere1.reflective = 0.3;

var sphere2 = Sphere();
sphere2.cx = -2.5;
sphere2.cy = 0.5;
sphere2.cz = -6.0;
sphere2.radius = 1.2;
sphere2.r = 0.3;
sphere2.g = 1.0;
sphere2.b = 0.3;
sphere2.reflective = 0.5;

var sphere3 = Sphere();
sphere3.cx = 2.0;
sphere3.cy = -0.5;
sphere3.cz = -4.5;
sphere3.radius = 0.8;
sphere3.r = 0.3;
sphere3.g = 0.3;
sphere3.b = 1.0;
sphere3.reflective = 0.7;

var sphere4 = Sphere();
sphere4.cx = 0.0;
sphere4.cy = -101.0;
sphere4.cz = -5.0;
sphere4.radius = 100.0;
sphere4.r = 0.8;
sphere4.g = 0.8;
sphere4.b = 0.8;
sphere4.reflective = 0.2;

var spheres = [sphere1, sphere2, sphere3, sphere4];

var lightX = 3.0;
var lightY = 5.0;
var lightZ = -2.0;

// ==========================================
// RENDERING
// ==========================================

def findClosestHit(ray)
{
    var closestT = 999999.0;
    var closestIdx = -1;
    
    for (var i = 0; i < len(spheres); i = i + 1)
    {
        var s = spheres[i];
        var t = intersectSphere(ray, s);
        
        if (t > 0.0 && t < closestT)
        {
            closestT = t;
            closestIdx = i;
        }
    }
    
    if (closestIdx >= 0)
    {
        var px = ray.ox + ray.dx * closestT;
        var py = ray.oy + ray.dy * closestT;
        var pz = ray.oz + ray.dz * closestT;
        
        var sphere = spheres[closestIdx];
        var nx = px - sphere.cx;
        var ny = py - sphere.cy;
        var nz = pz - sphere.cz;
        var nlen = length(nx, ny, nz);
        if (nlen < 0.0001)
        {
            nlen = 1.0;
        }
        nx = nx / nlen;
        ny = ny / nlen;
        nz = nz / nlen;
        
        var hit = HitRecord();
        hit.hit = 1;
        hit.t = closestT;
        hit.sphereIdx = closestIdx;
        hit.px = px;
        hit.py = py;
        hit.pz = pz;
        hit.nx = nx;
        hit.ny = ny;
        hit.nz = nz;
        return hit;
    }
    
    var miss = HitRecord();
    miss.hit = 0;
    return miss;
}

def shade(hitRec)
{
    var sphere = spheres[hitRec.sphereIdx];
    
    var ar = sphere.r * 0.2;
    var ag = sphere.g * 0.2;
    var ab = sphere.b * 0.2;
    
    var ldx = lightX - hitRec.px;
    var ldy = lightY - hitRec.py;
    var ldz = lightZ - hitRec.pz;
    var ldlen = length(ldx, ldy, ldz);
    ldx = ldx / ldlen;
    ldy = ldy / ldlen;
    ldz = ldz / ldlen;
    
    var diff = dot(hitRec.nx, hitRec.ny, hitRec.nz, ldx, ldy, ldz);
    if (diff < 0.0) diff = 0.0;
    
    var dr = sphere.r * diff * 0.8;
    var dg = sphere.g * diff * 0.8;
    var db = sphere.b * diff * 0.8;
    
    var viewX = 0.0 - hitRec.px;
    var viewY = 0.0 - hitRec.py;
    var viewZ = 0.0 - hitRec.pz;
    var viewLen = length(viewX, viewY, viewZ);
    viewX = viewX / viewLen;
    viewY = viewY / viewLen;
    viewZ = viewZ / viewLen;
    
    var hx = ldx + viewX;
    var hy = ldy + viewY;
    var hz = ldz + viewZ;
    var hlen = length(hx, hy, hz);
    hx = hx / hlen;
    hy = hy / hlen;
    hz = hz / hlen;
    
    var spec = dot(hitRec.nx, hitRec.ny, hitRec.nz, hx, hy, hz);
    if (spec < 0.0) spec = 0.0;
    
    var specPow = spec;
    specPow = specPow * specPow;
    specPow = specPow * specPow;
    specPow = specPow * specPow;
    specPow = specPow * specPow;
    
    var sr = specPow * 0.5;
    var sg = specPow * 0.5;
    var sb = specPow * 0.5;
    
    var shadowRay = Ray();
    shadowRay.ox = hitRec.px + hitRec.nx * 0.001;
    shadowRay.oy = hitRec.py + hitRec.ny * 0.001;
    shadowRay.oz = hitRec.pz + hitRec.nz * 0.001;
    shadowRay.dx = ldx;
    shadowRay.dy = ldy;
    shadowRay.dz = ldz;
    
    var shadowHit = findClosestHit(shadowRay);
    if (shadowHit.hit == 1)
    {
        dr = dr * 0.3;
        dg = dg * 0.3;
        db = db * 0.3;
        sr = 0.0;
        sg = 0.0;
        sb = 0.0;
    }
    
    var color = Vec3();
    color.x = ar + dr + sr;
    color.y = ag + dg + sg;
    color.z = ab + db + sb;
    return color;
}

def trace(ray, depth)
{
    if (depth <= 0)
    {
        var black = Vec3();
        black.x = 0.0;
        black.y = 0.0;
        black.z = 0.0;
        return black;
    }
    
    var hit = findClosestHit(ray);
    
    if (hit.hit == 0)
    {
        var t = 0.5 * (ray.dy + 1.0);
        var sky = Vec3();
        sky.x = 0.5 * (1.0 - t) + 0.7 * t;
        sky.y = 0.7 * (1.0 - t) + 0.85 * t;
        sky.z = 1.0 * (1.0 - t) + 1.0 * t;
        return sky;
    }
    
    var color = shade(hit);
    
    var sphere = spheres[hit.sphereIdx];
    if (sphere.reflective > 0.01 && depth > 1)
    {
        var reflDir = reflect(ray.dx, ray.dy, ray.dz, hit.nx, hit.ny, hit.nz);
        
        var reflRay = Ray();
        reflRay.ox = hit.px + hit.nx * 0.001;
        reflRay.oy = hit.py + hit.ny * 0.001;
        reflRay.oz = hit.pz + hit.nz * 0.001;
        reflRay.dx = reflDir.x;
        reflRay.dy = reflDir.y;
        reflRay.dz = reflDir.z;
        
        var reflColor = trace(reflRay, depth - 1);
        
        var k = sphere.reflective;
        color.x = color.x * (1.0 - k) + reflColor.x * k;
        color.y = color.y * (1.0 - k) + reflColor.y * k;
        color.z = color.z * (1.0 - k) + reflColor.z * k;
    }
    
    return color;
}

def getRay(x, y,_width,_height)
{
    var u = (x / _width) * 2.0 - 1.0;
    var v = (y / _height) * 2.0 - 1.0;
    v = -v;
    
    var aspectRatio = _width / _height;
    u = u * aspectRatio;
    
    var l = sqrt(u * u + v * v + 1.0);
    
    var r = Ray();
    r.ox = 0.0;
    r.oy = 0.0;
    r.oz = 0.0;
    r.dx = u / l;
    r.dy = v / l;
    r.dz = -1.0 / l;
    return r;
}

def clamp(x, min, max)
{
    if (x < min) return min;
    if (x > max) return max;
    return x;
}

// ==========================================
// REAL-TIME LOOP
// ==========================================

var time = 0.0;
var pixelSize = 1; // Render em blocos de 2x2 para ser mais rápido

 var framePass = 0; 
var  SKIP_STEP = 2; // Quanto maior, mais rápido (mas mais "riscado")




var target = LoadRenderTexture(renderW, renderH);
var src = Rectangle(0, 0, renderW, -renderH); // Invertido
var dest = Rectangle(0, 0, screenW, screenH);
var origin = Vector2(0, 0);
    
var r =  getRay(0,0, renderW, renderH);
var color = trace(r, 2);

while (!WindowShouldClose())
{
    time = time + 0.02;
    
    // Animar esferas!
    spheres[1].cx = -2.5 + sin(time) * 0.5;
    spheres[2].cy = -0.5 + cos(time * 1.3) * 0.3;
    
    // Mover luz com rato
    var mx = GetMouseX();
    var my = GetMouseY();
    lightX = (mx / renderW) * 6.0 - 3.0;
    lightY = 5.0 - (my / renderH) * 4.0;

    BeginTextureMode(target);

       framePass = (framePass + 1) % SKIP_STEP;


    if (framePass == 0)
    {
      
    for (var y = 0; y < renderH; y = y + pixelSize)
    {
        for (var x = 0; x < renderW; x = x + pixelSize)
        {
           var r = getRay(x, y,renderW, renderH);
            
           
           color = trace(r, 3); // Só 2 bounces para performance
           
            //Gamma correction
            color.x = sqrt(color.x);
            color.y = sqrt(color.y);
            color.z = sqrt(color.z);
            
            var ir = clamp(color.x * 255.0, 0.0, 255.0);
            var ig = clamp(color.y * 255.0, 0.0, 255.0);
            var ib = clamp(color.z * 255.0, 0.0, 255.0);
            
            var c = Color(ir, ig, ib, 255);
         //  DrawRectangle(x, y, pixelSize, pixelSize, c);
           DrawPixel(x, y, c);
        }
    }
    _gc();
    }
    EndTextureMode();
    
    BeginDrawing();
    ClearBackground(BLACK);
    
   
    
 

    
    // Render progressivo (cada frame renderiza tudo)
  
        
  

    var tex = GetRenderTextureTexture(target); 
    
    DrawTexture(tex, 0,0, WHITE);

 
    
//     // DrawTexturePro(texture, source, dest, origin, rotation, tint)
     DrawTexturePro(tex, src, dest, origin, 0.0, WHITE);

    
    DrawText("Ray Tracer - Move o rato!", 10, 10, 16, WHITE);
    DrawFPS(10, 30);
    //DrawStats(10,10);
    
    EndDrawing();
}

CloseWindow();