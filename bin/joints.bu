// ==========================================
// REVOLUTE JOINT - IMPULSE BASED
// ==========================================

struct RevoluteJoint
{
    var bodyA;
    var bodyB;
    var localAnchorA;
    var localAnchorB;
    
    var enableMotor;
    var motorSpeed;
    var maxMotorTorque;
    
    var enableLimit;
    var lowerAngle;
    var upperAngle;
    
    // Accumulated impulses (warm starting)
    var impulseX;
    var impulseY;
};

def createRevoluteJoint(bodyA, bodyB, anchorWorld)
{
    var joint = RevoluteJoint();
    joint.bodyA = bodyA;
    joint.bodyB = bodyB;
    
    joint.localAnchorA = sub(anchorWorld, bodyA.pos);
    joint.localAnchorB = sub(anchorWorld, bodyB.pos);
    
    joint.enableMotor = false;
    joint.motorSpeed = 0.0;
    joint.maxMotorTorque = 0.0;
    
    joint.enableLimit = false;
    joint.lowerAngle = 0.0;
    joint.upperAngle = 0.0;
    
    joint.impulseX = 0.0;
    joint.impulseY = 0.0;
    
    return joint;
}
def solveRevoluteJoint(joint, dt)
{
    var a = joint.bodyA;
    var b = joint.bodyB;
    
    // 1. Calcular vetores r (braços de alavanca)
    var c = cos(a.angle);
    var s = sin(a.angle);
    var rAx = joint.localAnchorA.x * c - joint.localAnchorA.y * s;
    var rAy = joint.localAnchorA.x * s + joint.localAnchorA.y * c;
    
    c = cos(b.angle);
    s = sin(b.angle);
    var rBx = joint.localAnchorB.x * c - joint.localAnchorB.y * s;
    var rBy = joint.localAnchorB.x * s + joint.localAnchorB.y * c;

    // 2. Calcular Massa Efetiva (Matriz K)
    var mA = a.invMass;
    var mB = b.invMass;
    var iA = a.invInertia;
    var iB = b.invInertia;

    var K11 = mA + mB + rAy * rAy * iA + rBy * rBy * iB;
    var K22 = mA + mB + rAx * rAx * iA + rBx * rBx * iB;
    var K12 = -rAy * rAx * iA - rBy * rBx * iB;
    
    var det = K11 * K22 - K12 * K12;
    if (det < 0.00001) return; // Evitar divisão por zero
    
    var invDet = 1.0 / det;
    var invK11 = K22 * invDet;
    var invK22 = K11 * invDet;
    var invK12 = -K12 * invDet;

    // ---------------------------------------------------------
    // NOVO: Correção de Posição (Bias / Baumgarte Stabilization)
    // ---------------------------------------------------------
    // Calcular onde os pontos estão no mundo real
    var pAx = a.pos.x + rAx;
    var pAy = a.pos.y + rAy;
    var pBx = b.pos.x + rBx;
    var pBy = b.pos.y + rBy;
    
    // Erro de posição (distância entre os pontos que deviam estar juntos)
    var ex = pBx - pAx;
    var ey = pBy - pAy;
    
    // Fator de correção (0.1 a 0.3 é bom para estabilidade)
    var biasFactor = 0.2; 
    var invDt = 1.0 / dt;
    
    // Velocidade extra necessária para fechar o gap neste frame
    var biasX = biasFactor * invDt * ex;
    var biasY = biasFactor * invDt * ey;
    
    // ---------------------------------------------------------
    // Resolver Velocidades
    // ---------------------------------------------------------
    
    // Velocidades relativas
    var vAx = a.vel.x - a.angularVel * rAy;
    var vAy = a.vel.y + a.angularVel * rAx;
    var vBx = b.vel.x - b.angularVel * rBy;
    var vBy = b.vel.y + b.angularVel * rBx;
    
    var Cdotx = vBx - vAx;
    var Cdoty = vBy - vAy;
    
    // O impulso agora inclui o BIAS para corrigir a posição!
    // Impulse = -K_inv * (V_rel + Bias)
    var impulsex = -(invK11 * (Cdotx + biasX) + invK12 * (Cdoty + biasY));
    var impulsey = -(invK12 * (Cdotx + biasX) + invK22 * (Cdoty + biasY));

    // Aplicar Impulso
    if (!a.isStatic)
    {
        a.vel.x = a.vel.x - impulsex * mA;
        a.vel.y = a.vel.y - impulsey * mA;
        a.angularVel = a.angularVel - (rAx * impulsey - rAy * impulsex) * iA;
    }
    
    if (!b.isStatic)
    {
        b.vel.x = b.vel.x + impulsex * mB;
        b.vel.y = b.vel.y + impulsey * mB;
        b.angularVel = b.angularVel + (rBx * impulsey - rBy * impulsex) * iB;
    }
}