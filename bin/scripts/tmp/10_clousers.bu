print("--- TEST 10: Closures & Upvalues ---\n");

// ==========================================
// TEST 1: Closure via Parâmetro
// ==========================================
print("[TEST 1] Closure via Parameter");

var globalCounter = 0;

def increment()
{
    globalCounter = globalCounter + 1;
    return globalCounter;
}

def callNTimes(func, n)
{
    var result = 0;
    for (var i = 0; i < n; i++)
    {
        result = func();
    }
    return result;
}

globalCounter = 0;
var result = callNTimes(increment, 3);
assert_eq(globalCounter, 3, "Called 3 times");

// ==========================================
// TEST 2: Function as Return Value
// ==========================================
print("\n[TEST 2] Function as Return Value");

def getAdder()
{
    return increment; // Retorna referência a função
}

var fn = getAdder();
globalCounter = 0;
fn();
fn();
assert_eq(globalCounter, 2, "Function returned and called");

// ==========================================
// TEST 3: Array de Funções
// ==========================================
print("\n[TEST 3] Array of Functions");

def add(a, b) { return a + b; }
def sub(a, b) { return a - b; }
def mul(a, b) { return a * b; }
def div(a, b) { return a / b; }

var ops = [add, sub, mul, div];

assert_eq(ops[0](10, 5), 15, "add via array");
assert_eq(ops[1](10, 5), 5, "sub via array");
assert_eq(ops[2](10, 5), 50, "mul via array");
assert_eq(ops[3](10, 5), 2, "div via array");

// ==========================================
// TEST 4: Map de Funções (Dispatch Table)
// ==========================================
print("\n[TEST 4] Map of Functions");

var handlers =
{
    "add": add,
    "sub": sub,
    "mul": mul
};

assert_eq(handlers["add"](7, 3), 10, "Dispatch add");
assert_eq(handlers["sub"](7, 3), 4, "Dispatch sub");
assert_eq(handlers["mul"](7, 3), 21, "Dispatch mul");

// ==========================================
// TEST 5: Higher-Order Functions
// ==========================================
print("\n[TEST 5] Higher-Order Functions");

def applyTwice(func, x)
{
    return func(func(x));
}

def double(n)
{
    return n * 2;
}

assert_eq(applyTwice(double, 5), 20, "double(double(5)) = 20");

// ==========================================
// TEST 6: Callback Pattern
// ==========================================
print("\n[TEST 6] Callback Pattern");

var callbackResult = 0;

def proc(data, callback)
{
    var result = data * 2;
    callback(result);
}

def onResult(value)
{
    callbackResult = value + 10;
}

proc(15, onResult);
assert_eq(callbackResult, 40, "Callback executed: (15*2) + 10");

// ==========================================
// TEST 7: Filter Pattern
// ==========================================
print("\n[TEST 7] Filter Pattern");

def isEven(n)
{
    return (n % 2) == 0;
}

def filter(arr, predicate)
{
    var result = [];
    for (var i = 0; i < arr.length(); i++)
    {
        if (predicate(arr[i]))
        {
            result.push(arr[i]);
        }
    }
    return result;
}

var numbers = [1, 2, 3, 4, 5, 6];
var evens = filter(numbers, isEven);

assert_eq(evens.length(), 3, "Filtered 3 evens");
assert_eq(evens[0], 2, "First even is 2");
assert_eq(evens[1], 4, "Second even is 4");
assert_eq(evens[2], 6, "Third even is 6");

// ==========================================
// TEST 8: Map Pattern
// ==========================================
print("\n[TEST 8] Map Pattern");

def square(n)
{
    return n * n;
}

def map(arr, transformer)
{
    var result = [];
    for (var i = 0; i < arr.length(); i++)
    {
        result.push(transformer(arr[i]));
    }
    return result;
}

var nums = [1, 2, 3, 4];
var squares = map(nums, square);

assert_eq(squares[0], 1, "1² = 1");
assert_eq(squares[1], 4, "2² = 4");
assert_eq(squares[2], 9, "3² = 9");
assert_eq(squares[3], 16, "4² = 16");

// ==========================================
// TEST 9: Reduce Pattern
// ==========================================
print("\n[TEST 9] Reduce Pattern");

def sum(a, b)
{
    return a + b;
}

def reduce(arr, reducer, initial)
{
    var acc = initial;
    for (var i = 0; i < arr.length(); i++)
    {
        acc = reducer(acc, arr[i]);
    }
    return acc;
}

var values = [1, 2, 3, 4, 5];
var total = reduce(values, sum, 0);

assert_eq(total, 15, "Sum of 1+2+3+4+5 = 15");

// ==========================================
// TEST 10: Function in Struct
// ==========================================
print("\n[TEST 10] Function in Struct");

def greet(name) 
{
    return "Hello, " + name + "!";
}

struct Handler 
{
    var action;
}

var h = Handler(greet);


var fn = h.action;
assert_eq(fn("World"), "Hello, World!", "Function stored in struct");



// ==========================================
// TEST 11: Recursion via Function Reference
// ==========================================
print("\n[TEST 11] Recursion via Function Reference");

def factorial(n)
{
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}

assert_eq(factorial(5), 120, "Recursive 5! = 120");

// ==========================================
// TEST 12: Mutual Recursion
// ==========================================
print("\n[TEST 12] Mutual Recursion");

def isEvenMutual(n)
{
    if (n == 0) return true;
    return isOddMutual(n - 1);
}

def isOddMutual(n)
{
    if (n == 0) return false;
    return isEvenMutual(n - 1);
}

assert(isEvenMutual(10), "10 is even");
assert(isOddMutual(7), "7 is odd");

print("\n[TEST 13] Sort with Comparator");

def ascending(a, b)
{
    return a < b;
}

def descending(a, b)
{
    return a > b;
}

def bubbleSort(arr, compare) 
{
    var n = arr.length();
    for (var i = 0; i < n; i++) 
    {
        for (var j = 0; j < n - 1; j++) 
        {
            if (compare(arr[j + 1], arr[j])) 
            {
                var temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    return arr;
}

var unsorted = [5, 2, 8, 1, 9];
var asc = bubbleSort(unsorted, ascending);

assert_eq(asc[0], 1, "Sorted ascending [0]");
assert_eq(asc[4], 9, "Sorted ascending [4]");



// ==========================================
// TEST 15: Closure via Parâmetro
// ==========================================
print("[TEST 15] Closure via Parameter");


 
def makeCounter() 
{
    var count = 0;
    
    def increment() 
    {
        count = count + 1;
        return count;
    }
    
    return increment;
}

 var counter = makeCounter();
 assert_eq(counter(), 1, "First call returns 1");
 assert_eq(counter(), 2, "Second call returns 2");
 assert_eq(counter(), 3, "Third call returns 3");


print("\n✅ All function reference tests passed!");
pass("10_closures.bu completed");

 