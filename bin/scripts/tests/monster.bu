 
def assertEq(name, got, expected) {
 
    assert_eq(got,expected,name);
 
}

def assertTrue(name, condition) {
    assert(condition,name);
 
}

// ═══════════════════════════════════════════════════════════════════════
// TEST 1: Structs com MUITOS fields (stress List/HybridMap)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 1] Structs com 100 fields\n");
print("────────────────────────────────────────────────────────────────\n");

struct Monster100 {
    var f1, f2, f3, f4, f5, f6, f7, f8, f9, f10,
        f11, f12, f13, f14, f15, f16, f17, f18, f19, f20,
        f21, f22, f23, f24, f25, f26, f27, f28, f29, f30,
        f31, f32, f33, f34, f35, f36, f37, f38, f39, f40,
        f41, f42, f43, f44, f45, f46, f47, f48, f49, f50,
        f51, f52, f53, f54, f55, f56, f57, f58, f59, f60,
        f61, f62, f63, f64, f65, f66, f67, f68, f69, f70,
        f71, f72, f73, f74, f75, f76, f77, f78, f79, f80,
        f81, f82, f83, f84, f85, f86, f87, f88, f89, f90,
        f91, f92, f93, f94, f95, f96, f97, f98, f99, f100;
};

var m = Monster100(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,
                   21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
                   41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,
                   61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
                   81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100);

assertEq("Monster.f1", m.f1, 1);
assertEq("Monster.f50", m.f50, 50);
assertEq("Monster.f100", m.f100, 100);

// Stress último field (worst case para List!)
for(var i = 0; i < 1000; i++) {
    m.f100 = i;
}
assertEq("Monster.f100 após loop", m.f100, 999);

 

 

// ═══════════════════════════════════════════════════════════════════════
// TEST 3: MUITAS structs (memory stress)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 3] Criar 10.000 structs\n");
print("────────────────────────────────────────────────────────────────\n");

struct bPoint { var x, y; };

var points = [];
for(var i = 0; i < 10000; i++) 
{
    points.push(bPoint(i, i * 2));
}

assertEq("points[0].x", points[0].x, 0);
assertEq("points[9999].x", points[9999].x, 9999);
assertEq("points[5000].y", points[5000].y, 10000);

// ═══════════════════════════════════════════════════════════════════════
// TEST 4: Field name collision entre structs diferentes
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 4] Field collision entre structs\n");
print("────────────────────────────────────────────────────────────────\n");

struct aPlayer { var name, health, mana; };
struct Enemy { var name, health, damage; };
struct NPC { var name, health, dialog; };

var p = aPlayer("Hero", 100, 50);
var e = Enemy("Goblin", 30, 10);
var n = NPC("Merchant", 50, "Hello!");

assertEq("Player.health", p.health, 100);
assertEq("Enemy.health", e.health, 30);
assertEq("NPC.health", n.health, 50);
assertEq("Player.mana", p.mana, 50);
assertEq("Enemy.damage", e.damage, 10);

// ═══════════════════════════════════════════════════════════════════════
// TEST 5: Acesso intensivo a fields (performance)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 5] 100K field accesses\n");
print("────────────────────────────────────────────────────────────────\n");

struct Entity { 
    var a, b, c, d, e, f, g, h, i, j,
        k, l, m, n, o, p, q, r, s, t;
};

var ent = Entity(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);
var sum = 0;

var start = clock();
for(var i = 0; i < 100000; i++) {
    sum = sum + ent.a + ent.j + ent.t;
    ent.a = i % 100;
    ent.j = (i * 2) % 100;
    ent.t = (i * 3) % 100;
}
var elapsed = clock() - start;

print("Tempo: " + elapsed + "s\n");
assertTrue("Sum > 0", sum > 0);
assertTrue("Performance OK (<5s)", elapsed < 5.0);

// ═══════════════════════════════════════════════════════════════════════
// TEST 6: Strings longas como field names
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 6] Field names muito longos\n");
print("────────────────────────────────────────────────────────────────\n");

struct LongFieldNames {
    var thisIsAnExtremelyLongFieldNameThatShouldStillWorkCorrectlyInTheVM,
        anotherVeryLongFieldNameToTestStringInterningAndHashCollisions,
        yetAnotherIncrediblyLongNameJustToMakeSureEverythingWorks,
        short;
};

var lf = LongFieldNames(111, 222, 333, 444);
assertEq("Long field 1", lf.thisIsAnExtremelyLongFieldNameThatShouldStillWorkCorrectlyInTheVM, 111);
assertEq("Long field 2", lf.anotherVeryLongFieldNameToTestStringInterningAndHashCollisions, 222);
assertEq("Long field 3", lf.yetAnotherIncrediblyLongNameJustToMakeSureEverythingWorks, 333);
assertEq("Short field", lf.short, 444);

// ═══════════════════════════════════════════════════════════════════════
// TEST 7: Modificação massiva de fields
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 7] Modificar fields 100K vezes\n");
print("────────────────────────────────────────────────────────────────\n");

struct Counter { var count, total; };
var c = Counter(0, 0);

for(var i = 0; i < 100000; i++) {
    c.count = i;
    c.total = c.total + 1;
}

assertEq("Counter final", c.count, 99999);
assertEq("Total increments", c.total, 100000);

 // ═══════════════════════════════════════════════════════════════════════
// TEST 8: Struct em arrays com acesso aleatório
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 8] Random access em 1000 structs\n");
print("────────────────────────────────────────────────────────────────\n");

struct Item { var id, value, active; };

var items = [];
for(var i = 0; i < 1000; i++) 
{
    items.push(Item(i, i * 10, true));
}

var total = 0;
for(var i = 0; i < 10000; i++) {
    var idx = i % 1000;
    total = total + items[idx].value;
    items[idx].value = items[idx].value + 1;
    items[idx].active = (i % 2) == 0;
}

assertTrue("Total > 0", total > 0);
assertEq("items[500].value", items[500].value, 5010);


// ═══════════════════════════════════════════════════════════════════════
// TEST 9: Structs com tipos mistos
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 9] Structs com tipos mistos\n");
print("────────────────────────────────────────────────────────────────\n");

struct MixedTypes {
    var intVal, floatVal, stringVal, boolVal, nilVal, arrayVal;
};

var mix = MixedTypes(42, 3.14, "hello", true, nil, [1, 2, 3]);

assertEq("int field", mix.intVal, 42);
assertTrue("bool field", mix.boolVal);
assertEq("array[1]", mix.arrayVal[1], 2);