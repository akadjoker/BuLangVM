// // ===== CRIAÇÃO =====
// var b8 = @(4, TYPE_UINT8);
// var b16 = @(100, TYPE_INT16);
// var floats = @(1000, TYPE_FLOAT);

// // ===== INDEXAÇÃO =====
// b8[0] = 255;
// b8[1] = 128;
// print(b8[0]); // 255

// // ===== MÉTODOS =====

// // 1. fill() - Preencher com valor
// b8.fill(42);
// print(b8[0]); // 42
// print(b8[3]); // 42

// // 2. clear() - 
// b8.clear();
// print(b8[0]); // 0

// // 3. length() -

// print(b8.length());

// // 4. slice() - Criar sub-buffer
// var original = @(10, TYPE_INT32);
// original.fill(100);
// var slice = original.slice(2, 5); // [2, 3, 4]
// print(slice.length()); // 3

// // 5. copy() - Copiar entre buffers
// var src = @(5, TYPE_UINT8);
// var dst = @(5, TYPE_UINT8);

// src.fill(99);
// dst.copy(0,src, 0, 5); // Copia tudo
// print(dst[0]); // 99

// // ===== EXPRESSÕES DINÂMICAS =====
// var width = 1920;
// var height = 1080;
// var pixels = @(width * height, TYPE_UINT8);


// def processImage(w, h) 
// {
//     // Cria buffer de pixels
//     var buffer = @(w * h * 4, TYPE_UINT8);
    
//     // Preenche com cor
//     buffer.fill(128);
    
//     // Processa região
//     var region = buffer.slice(0, 100);
//     region.fill(255);
    
//     // Copia de volta
//     buffer.copy(0,region, 0, region.length());
    
//     return buffer;
// }

// var img = processImage(640, 480);
// print(img.length()); // 1228800 (640*480*4)


// // TESTE 1: Verificação de tipos e overflow
// var b8 = @(4, TYPE_UINT8);
// b8[0] = 255;
// b8[1] = -1;   // Deve converter para 255 (unsigned wrap)
// b8[2] = 256;  // Deve converter para 0 (overflow)
// print("UINT8: " + b8[0] + " | " + b8[1] + " | " + b8[2]); 
// // Esperado: "UINT8: 255 | 255 | 0"

// // TESTE 2: Diferentes tipos
// var i16 = @(2, TYPE_INT16);
// i16[0] = -32768;
// i16[1] = 32767;
// print("INT16: " + i16[0] + " | " + i16[1]);
// // Esperado: "INT16: -32768 | 32767"

// // TESTE 3: Floats
// var f32 = @(3, TYPE_FLOAT);
// f32[0] = 3.14159;
// f32[1] = -2.71828;
// f32[2] = 1.41421;
// print("FLOAT: " + f32[0]);
// // Esperado: "FLOAT: 3.14159"

// // TESTE 4: Métodos encadeados
// var buffer = @(10, TYPE_UINT8)
//     .fill(42)
//     .slice(0, 5)
//     .fill(99);
// print(buffer[0]); // 99
// print(buffer.length()); // 5
// // EXEMPLO 1: Cópia simples
// var src = @(5, TYPE_UINT8);
// var dst = @(10, TYPE_UINT8);

// for (var i = 0; i < 5; i = i + 1)
// {
//     src[i] = i * 10;
// }

// // Copiar tudo de src para dst[3]
// dst.copy(3, src, 0, 5);
// // dst = [0, 0, 0, 0, 10, 20, 30, 40, 0, 0]
// //                ↑ início da cópia

// print(dst[3]); // 0
// print(dst[4]); // 10
// print(dst[5]); // 20

// // EXEMPLO 2: Cópia parcial
// var data = @(10, TYPE_INT32);
// var backup = @(10, TYPE_INT32);

// data.fill(42);

// // Copiar apenas metade
// backup.copy(0, data, 5, 5);
// // backup[0:5] = data[5:10]

// // EXEMPLO 3: Shift interno (mesmo buffer)
// var buf = @(10, TYPE_UINT8);
// buf.fill(1);
// buf[0] = 99;

// // Move buf[0:5] para buf[5:10]
// buf.copy(5, buf, 0, 5);
// // buf = [99, 1, 1, 1, 1, 99, 1, 1, 1, 1]
// //        ↑                 ↑ copiado

// // EXEMPLO 4: Processamento de imagem
// var image = @(1920 * 1080 *3, TYPE_UINT8);
// var thumbnail = @(320 * 240 *3, TYPE_UINT8);

// // Copiar primeira linha
// thumbnail.copy(0, image, 0, 320 * 4);

// // EXEMPLO 5: Chaining
// var src = @(100, TYPE_FLOAT);
// var dst = @(100, TYPE_FLOAT);

// dst.copy(0, src, 0, 100)
//    .fill(3.14)          // Preenche tudo com 3.14
//    .clear();            // Depois zera



// var bank = @("data.txt",TYPE_UINT8)   ;


// var pixels = @(1920 * 1080 * 4, TYPE_UINT8);
// pixels.fill(128);
// pixels.save("screenshot.raw");



// // Criar imagem RGB 100x100
// var width = 100;
// var height = 100;
// var image = @(width * height * 3, TYPE_UINT8);

// // Preencher com gradiente
// for (var y = 0; y < height; y = y + 1) 
// {
//     for (var x = 0; x < width; x = x + 1) 
//     {
//         var i = (y * width + x) * 3;
//         image[i + 0] = x * 2;     // R
//         image[i + 1] = y * 2;     // G
//         image[i + 2] = 128;       // B
//     }
// }

// // Salvar RAW
// image.save("gradient.raw");

// // Converter com ImageMagick :
// // $ convert -size 100x100 -depth 8 rgb:gradient.raw gradient.png

// // Carregar de volta
// var loaded = @("gradient.raw", TYPE_UINT8);
// print("Loaded: " + loaded.length() + " bytes");



// struct Point 
// {
//     x, y, z;
// };

// // Caso 1: Vazio (Tudo nil)
// var p1 = Point();
// print(p1.x); // nil

// // Caso 2: Parcial (Preenche em ordem, resto nil)
// var p2 = Point(10);
// print(p2.x); // 10
// print(p2.y); // nil

// // Caso 3: Completo
// var p3 = Point(10, 20, 30);
// print(p3.z); // 30

// // Caso 4: Definindo depois
// var p4 = Point();
// p4.x = 100;
// p4.y = 200;




// var buf = @(100, TYPE_UINT8);

// // Escreve com cursor
// buf.writeInt(42);
// buf.writeFloat(3.14);
// print(buf.tell());  // 8

// // Fill NÃO mexe cursor
// buf.fill(0);
// print(buf.tell());  // Ainda 8!

// // Clear RESETA cursor
// buf.clear();
// print(buf.tell());  // 0

// // Copy NÃO mexe cursor
// buf.writeInt(100);
// buf.writeInt(200);
// print(buf.tell());  // 8

// var buf2 = @(100, TYPE_UINT8);
// buf2.copy(0, buf, 0, 8);  // Copia dados
// print(buf.tell());   // Ainda 8
// print(buf2.tell());  // 0 (novo buffer)

// // Save NÃO mexe cursor
// buf.save("data.bin");
// print(buf.tell());  // Ainda 8



// // Configuração da Imagem
// var width = 256;
// var height = 256;

// // Cada pixel tem 3 bytes (Blue, Green, Red)
// // Padding: As linhas devem ser múltiplas de 4 bytes. 
// // Como 256*3 = 768 (é múltiplo de 4), não precisamos de padding extra.
// var pixelDataSize = width * height * 3;
// var headerSize = 54; // 14 (FileHeader) + 40 (InfoHeader)
// var totalSize = headerSize + pixelDataSize;

// // Cria o buffer
// var bmp = @(totalSize, TYPE_UINT8);

// print("A gerar BMP de " + totalSize + " bytes...");

// // ==========================================
// // 1. BMP FILE HEADER (14 bytes)
// // ==========================================

// // Magic Number "BM" (0x42, 0x4D)
// bmp.writeByte(66); // B
// bmp.writeByte(77); // M

// // File Size (Int - 4 bytes)
// bmp.writeInt(totalSize);

// // Reserved 1 & 2 (Shorts - 2 + 2 bytes)
// bmp.writeShort(0);
// bmp.writeShort(0);

// // Offset para os dados de pixel (Int - 4 bytes)
// // Os pixels começam logo após o header (54 bytes)
// bmp.writeInt(54);

// // ==========================================
// // 2. BMP INFO HEADER (40 bytes)
// // ==========================================

// // Header Size (Int)
// bmp.writeInt(40); 

// // Width & Height (Ints)
// bmp.writeInt(width);
// bmp.writeInt(height);

// // Planes (Short - sempre 1)
// bmp.writeShort(1);

// // Bits per Pixel (Short - 24 para RGB)
// bmp.writeShort(24);

// // Compression (Int - 0 para sem compressão)
// bmp.writeInt(0);

// // Image Size (Int - pode ser 0 para uncompressed)
// bmp.writeInt(pixelDataSize);

// // X/Y Pixels Per Meter (Ints - resolução de impressão, ex: 2835)
// bmp.writeInt(2835); 
// bmp.writeInt(2835);

// // Colors Used/Important (Ints)
// bmp.writeInt(0);
// bmp.writeInt(0);

// // ==========================================
// // 3. PIXEL DATA (Gerar padrão)
// // ==========================================

// // Nota: O BMP grava cores na ordem BGR (Blue, Green, Red)
// // E geralmente grava de baixo para cima (mas vamos ignorar isso por agora)

// var x = 0;
// var y = 0;

// // Vamos usar o tell() para garantir que o cursor está certo (deve ser 54)
// print("Cursor após headers: " + bmp.tell()); 

// if (bmp.tell() != 54) 
// {
//     print("ERRO CRÍTICO: Cabeçalho mal formado!");

// }

// while (y < height)
// {
//     x = 0;
//     while (x < width)
//     {
        
//         // Efeito "XOR Pattern" clássico
//         var val = (x ^ y) % 256;
        
//         // Escrever B, G, R sequencialmente
//         bmp.writeByte(val);         // Blue
//         bmp.writeByte((x * y) % 256); // Green (efeito noise)
//         bmp.writeByte(255 - val);   // Red
        
//         x = x + 1;
//     }
//     y = y + 1;
// }

// // ==========================================
// // 4. SALVAR
// // ==========================================

// if (bmp.save("test_output.bmp"))
// {
//     print("Sucesso! Abre 'test_output.bmp' para ver o resultado.");
// } else
// {
//     print("Falha ao gravar.");
// }


// // Carregar o BMP que criaste antes
// var img = @("test_output.bmp", TYPE_UINT8);

// // Ler o Header
// var b = img.readByte(); // 66 'B'
// var m = img.readByte(); // 77 'M'
// var size = img.readInt(); // Tamanho total

// print("Header: " + b + " " + m);
// print("Tamanho do ficheiro: " + size);

// // Saltar para a largura/altura (Offset 18)
// img.seek(18);
// var w = img.readInt();
// var h = img.readInt();

// print("Resolução: " + w + "x" + h);





// var width = 800;
// var height = 600;
// var bmp = @(54 + width * height * 3, TYPE_UINT8);
// var pixelDataSize = width * height * 3;
// var headerSize = 54; // 14 (FileHeader) + 40 (InfoHeader)
// var totalSize = headerSize + pixelDataSize;

// // Cria o buffer
// var bmp = @(totalSize, TYPE_UINT8);

// print("A gerar BMP de " + totalSize + " bytes...");
// bmp.writeByte(66); // B
// bmp.writeByte(77); // M
// bmp.writeInt(totalSize);
// bmp.writeShort(0);
// bmp.writeShort(0);
// bmp.writeInt(54);
// bmp.writeInt(40); 
// bmp.writeInt(width);
// bmp.writeInt(height);
// bmp.writeShort(1);
// bmp.writeShort(24);
// bmp.writeInt(0);
// bmp.writeInt(pixelDataSize);
// bmp.writeInt(2835); 
// bmp.writeInt(2835);
// bmp.writeInt(0);
// bmp.writeInt(0);

// var y = 0;
// while (y < height)
// {
//     var x = 0;
//     while (x < width)
//     {
//         // Map pixel to complex plane
//         var cx = (x - width/2) * 4.0 / width;
//         var cy = (y - height/2) * 4.0 / height;
        
//         var zx = 0.0;
//         var zy = 0.0;
//         var iter = 0;
        
//         while (zx*zx + zy*zy < 4.0 && iter < 255)
//         {
//             var tmp = zx*zx - zy*zy + cx;
//             zy = 2.0*zx*zy + cy;
//             zx = tmp;
//             iter = iter + 1;
//         }
        
//         // Color based on iterations
//         bmp.writeByte(iter);
//         bmp.writeByte(iter * 2);
//         bmp.writeByte(iter * 4);
        
//         x = x + 1;
//     }
//     y = y + 1;
// }

// bmp.save("mandelbrot.bmp");


// def blur(input, output) {
//     var img = @(input, TYPE_UINT8);
    
//     img.seek(18);
//     var w = img.readInt();
//     var h = img.readInt();
    
//     var result = @(54 + w * h * 3, TYPE_UINT8);
    
//     // Copy header
//     img.rewind();
//     result.copy(0, img, 0, 54);
    
//     // Blur pixels (box blur 3x3)
//     img.seek(54);
//     result.seek(54);
    
//     var y = 1;
//     while (y < h - 1) {
//         var x = 1;
//         while (x < w - 1) {
//             var sumB = 0;
//             var sumG = 0;
//             var sumR = 0;
            
//             // 3x3 neighborhood
//             var dy = -1;
//             while (dy <= 1) {
//                 var dx = -1;
//                 while (dx <= 1) {
//                     var offset = 54 + ((y+dy) * w + (x+dx)) * 3;
//                     img.seek(offset);
//                     sumB = sumB + img.readByte();
//                     sumG = sumG + img.readByte();
//                     sumR = sumR + img.readByte();
//                     dx = dx + 1;
//                 }
//                 dy = dy + 1;
//             }
            
//             result.writeByte(sumB / 9);
//             result.writeByte(sumG / 9);
//             result.writeByte(sumR / 9);
            
//             x = x + 1;
//         }
//         y = y + 1;
//     }
    
//     result.save(output);
// }

// blur("mandelbrot.bmp", "blurred.bmp");




var successPath = false;
var catchPath = false;
var errorMsg = "";

try 
{
   
    var a = 10;
    var b = 0;
    var c = a / b; // error
    
    successPath = true;  
} catch (err) 
{
    catchPath = true;
    errorMsg = err; 
    print("   -> Errr captured: " + err);
}

print("Program continues!");
print("Sucess: ",successPath);
print("Catch: ",catchPath);