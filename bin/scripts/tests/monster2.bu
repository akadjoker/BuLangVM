 
def assertEq(name, got, expected) {
 
    assert_eq(got,expected,name);
 
}

def assertTrue(name, condition) {
    assert(condition,name);
 
}


// ═══════════════════════════════════════════════════════════════════════
// TEST 10: Structs idênticos (não devem conflitar)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 10] Múltiplas instâncias do mesmo struct\n");
print("────────────────────────────────────────────────────────────────\n");

struct Position { var x, y, z; };

var p1 = Position(1, 2, 3);
var p2 = Position(4, 5, 6);
var p3 = Position(7, 8, 9);

p2.x = 100;

assertEq("p1.x não mudou", p1.x, 1);
assertEq("p2.x mudou", p2.x, 100);
assertEq("p3.x não mudou", p3.x, 7);

// ═══════════════════════════════════════════════════════════════════════
// TEST 11: Field reassignment com valores diferentes
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 11] Reassignment com tipos diferentes\n");
print("────────────────────────────────────────────────────────────────\n");

struct Flexible { var data; };

var flex = Flexible(42);
assertEq("Initial int", flex.data, 42);

flex.data = "string";
assertEq("Changed to string", flex.data, "string");

flex.data = 3.14;
// Note: comparação de floats pode ser tricky
assertTrue("Changed to float", flex.data > 3.0);

flex.data = [1, 2, 3];
assertEq("Changed to array", flex.data[0], 1);

// ═══════════════════════════════════════════════════════════════════════
// TEST 12: Structs com field names similares (hash collision test)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 12] Field names similares (hash test)\n");
print("────────────────────────────────────────────────────────────────\n");

struct Similar {
    var name, name1, name2, name10, name11, name12,
        data, data1, data2, data10, data11, data12;
};

var sim = Similar(1,2,3,4,5,6,7,8,9,10,11,12);

assertEq("name", sim.name, 1);
assertEq("name1", sim.name1, 2);
assertEq("name12", sim.name12, 6);
assertEq("data", sim.data, 7);
assertEq("data12", sim.data12, 12);

// ═══════════════════════════════════════════════════════════════════════
// TEST 13: Struct vazio (edge case)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 13] Struct sem fields\n");
print("────────────────────────────────────────────────────────────────\n");

struct Empty {};

var empty = Empty();
assertTrue("Empty struct criado", true); // Se chegou aqui, passou!

// ═══════════════════════════════════════════════════════════════════════
// TEST 14: Struct com 1 field apenas
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 14] Struct com 1 field\n");
print("────────────────────────────────────────────────────────────────\n");

struct Single { var value; };

var single = Single(999);
assertEq("Single field", single.value, 999);

// ═══════════════════════════════════════════════════════════════════════
// TEST 15: Acesso a field inexistente (deve dar erro)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 15] Tentativa de acesso a field inexistente\n");
print("────────────────────────────────────────────────────────────────\n");

struct Limited { var a, b; };
var lim = Limited(1, 2);

// Este teste DEVE dar erro runtime - comentar se crashar a VM
// var bad = lim.c;  // Field 'c' não existe!

print("(Teste de erro comentado - descomentar para testar)\n");
assertTrue("Struct limitado OK", lim.a == 1);

// ═══════════════════════════════════════════════════════════════════════
// TEST 16: Loop criando e destruindo structs (GC stress)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 16] GC stress - criar/destruir 10K structs em loop\n");
print("────────────────────────────────────────────────────────────────\n");

struct Temp { var id, data; };

for(var i = 0; i < 10000; i++) {
    var temp = Temp(i, i * 2);
    // temp vai ser garbage collected
}

assertTrue("GC stress OK", true);

// ═══════════════════════════════════════════════════════════════════════
// TEST 17: Array de structs diferentes
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 17] Array com structs de tipos diferentes\n");
print("────────────────────────────────────────────────────────────────\n");

struct A { var t; };
struct B { var t; };
struct C { var t; };

var mixed = [A("A"), B("B"), C("C")];

assertEq("mixed[0].t", mixed[0].t, "A");
assertEq("mixed[1].t", mixed[1].t, "B");
assertEq("mixed[2].t", mixed[2].t, "C");

// ═══════════════════════════════════════════════════════════════════════
// TEST 18: Struct como valor de outro struct
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 18] Struct dentro de struct (não aninhado)\n");
print("────────────────────────────────────────────────────────────────\n");

struct Inner { var val; };
struct Outer { var inner, other; };

var inner = Inner(42);
var outer = Outer(inner, 100);

assertEq("outer.inner.val", outer.inner.val, 42);
assertEq("outer.other", outer.other, 100);

inner.val = 999;
assertEq("inner modificado reflete", outer.inner.val, 999);

// ═══════════════════════════════════════════════════════════════════════
// TEST 19: Field names unicode (se suportado)
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 19] Field names especiais\n");
print("────────────────────────────────────────────────────────────────\n");

struct Special 
{
    var _private, special, __dunder__;
};

var spec = Special(1, 2, 3);
assertEq("_private", spec._private, 1);
assertEq("special", spec.special, 2);
assertEq("__dunder__", spec.__dunder__, 3);

// ═══════════════════════════════════════════════════════════════════════
// TEST 20: Performance comparison - Struct vs Array
// ═══════════════════════════════════════════════════════════════════════
print("\n[TEST 20] Performance: Struct vs Array\n");
print("────────────────────────────────────────────────────────────────\n");

struct Vec3 { var x, y, z; };

var startStruct = clock();
for(var i = 0; i < 100000; i++) {
    var v = Vec3(i, i+1, i+2);
    var sum = v.x + v.y + v.z;
}
var timeStruct = clock() - startStruct;

var startArray = clock();
for(var i = 0; i < 100000; i++) {
    var v = [i, i+1, i+2];
    var sum = v[0] + v[1] + v[2];
}
var timeArray = clock() - startArray;

print("Struct time: " + timeStruct + "s\n");
print("Array time: " + timeArray + "s\n");
assertTrue("Struct performance reasonable", timeStruct < 10.0);



var list = [];
def factory(val) {
    var x = val;
    var y = val * 2;
    // Closure captura 'x' e 'y'
    def inner() {
        return x + y;
    }
    return inner;
}

for (var i = 0; i < 10000; i++) {
    // Cria um scope local
    
    // Guarda a closure
    list.push(factory(i));
    
    // Força GC no meio para ver se ele apaga o 'x' e 'y' indevidamente
    if (i % 100 == 0) _gc(); 
}

print("A verificar integridade...");
for (var k = 0; k < 10000; k++) {
    var func = list[k];
    var res = func(); // Isto deve retornar k + k*2
    if (res != k * 3) {
        print("CRASH LOGICO: Valor errado no index " + k);
     
    }
}
print("Closures blindadas!");


var count = 0;

process Kamikaze() {
    count = count + 1;
    // Cria algum lixo na stack
    var lixo = [1, 2, 3, "teste"];
    // Morre imediatamente
    return;
}

print("A lançar enxame...");

// Tenta lançar 500.000 processos (não todos ao mesmo tempo, mas sequencialmente)
for (var i = 0; i < 50000; i++) {
    Kamikaze();
    frame; // Deixa o processo correr e morrer
    
    // A cada 1000, força limpeza
    if (i % 1000 == 0) {
        print("Processos: " + i);
        // O GC deve limpar os processos mortos aqui
    }
}

print("Enxame sobreviveu. Count final: " + count);