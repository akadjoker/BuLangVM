require "raylib";
import math;
import raylib;
using raylib;

var screenW = 800;
var screenH = 600;
var renderW = 400;
var renderH = 300;

InitWindow(screenW, screenH, "Ray-Doom Hybrid");
SetTargetFPS(60);

var WHITE = Color(255, 255, 255, 255);
var BLACK = Color(0, 0, 0, 255);
var RED = Color(255, 0, 0, 255);
var GREEN = Color(0, 255, 0, 255);
var BLUE = Color(0, 0, 255, 255);
var YELLOW = Color(255, 255, 0, 255);
var GRAY = Color(100, 100, 100, 255);
var DARK_GRAY = Color(50, 50, 50, 255);

// ==========================================
// MAPA (cor = tipo de parede)
// ==========================================
var mapW = 16;
var mapH = 16;

var worldMap = [];

// 0 = vazio, 1 = vermelho, 2 = verde, 3 = azul, 4 = amarelo
var rows = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,2,2,2,0,0,0,0,3,3,3,0,0,1],
    [1,0,0,2,0,0,0,0,0,0,0,0,3,0,0,1],
    [1,0,0,2,0,0,0,0,0,0,0,0,3,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,4,4,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,3,0,0,0,0,0,0,0,0,2,0,0,1],
    [1,0,0,3,0,0,0,0,0,0,0,0,2,0,0,1],
    [1,0,0,3,3,3,0,0,0,0,2,2,2,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

for (var y = 0; y < mapH; y = y + 1)
{
    var row = rows[y];
    for (var x = 0; x < mapW; x = x + 1)
    {
        worldMap.push(row[x]);
    }
}

def getMap(x, y)
{
    if (x < 0 || x >= mapW || y < 0 || y >= mapH)
        return 1;
    return worldMap[y * mapW + x];
}

// ==========================================
// PLAYER
// ==========================================

var posX = 4.0;
var posY = 8.0;
var dirX = -1.0;
var dirY = 0.0;
var planeX = 0.0;
var planeY = 0.66;

var moveSpeed = 0.08;
var rotSpeed = 0.04;

// ==========================================
// CORES DAS PAREDES
// ==========================================

def getWallColor(wallType, side, brightness)
{
    var baseColor;
    
    if (wallType == 1)
    {
        baseColor = Color(200, 50, 50, 255); // Vermelho
    }
    else if (wallType == 2)
    {
        baseColor = Color(50, 200, 50, 255); // Verde
    }
    else if (wallType == 3)
    {
        baseColor = Color(50, 50, 200, 255); // Azul
    }
    else if (wallType == 4)
    {
        baseColor = Color(200, 200, 50, 255); // Amarelo
    }
    else
    {
        baseColor = GRAY;
    }
    
    // Lado escuro vs claro
    if (side == 1)
    {
        baseColor = Color(baseColor.r * 0.7, baseColor.g * 0.7, baseColor.b * 0.7, 255);
    }
    
    // Distância (fog)
    baseColor = Color(
        baseColor.r * brightness,
        baseColor.g * brightness,
        baseColor.b * brightness,
        255
    );
    
    return baseColor;
}

// ==========================================
// RAYCASTING PARA PAREDES
// ==========================================

var zBuffer = []; // Para sprites

def castRays(target)
{
    BeginTextureMode(target);
    
    // Céu e chão com gradiente
    for (var y = 0; y < renderH; y = y + 1)
    {
        var skyBrightness = 1.0 - (y / renderH) * 0.5;
        var skyColor = Color(30 * skyBrightness, 30 * skyBrightness, 80 * skyBrightness, 255);
        DrawLine(0, y, renderW, y, skyColor);
    }
    
    // Limpar zBuffer
    zBuffer = [];
    for (var i = 0; i < renderW; i = i + 1)
    {
        zBuffer.push(0.0);
    }
    
    for (var x = 0; x < renderW; x = x + 1)
    {
        var cameraX = 2.0 * x / renderW - 1.0;
        var rayDirX = dirX + planeX * cameraX;
        var rayDirY = dirY + planeY * cameraX;

        var mapX = floor(posX);
        var mapY = floor(posY);
        
        var deltaDistX;
        var deltaDistY;

        if (rayDirX == 0.0) deltaDistX = 10000000.0;
        else deltaDistX = abs(1.0 / rayDirX);

        if (rayDirY == 0.0) deltaDistY = 10000000.0;
        else deltaDistY = abs(1.0 / rayDirY);
        
        var stepX, stepY;
        var sideDistX, sideDistY;
        
        if (rayDirX < 0.0)
        {
            stepX = -1;
            sideDistX = (posX - mapX) * deltaDistX;
        }
        else
        {
            stepX = 1;
            sideDistX = (mapX + 1.0 - posX) * deltaDistX;
        }
        
        if (rayDirY < 0.0)
        {
            stepY = -1;
            sideDistY = (posY - mapY) * deltaDistY;
        }
        else
        {
            stepY = 1;
            sideDistY = (mapY + 1.0 - posY) * deltaDistY;
        }
        
        var hit = 0;
        var side = 0;
        var wallType = 0;
        
        var steps = 0;
        while (hit == 0 && steps < 100)
        {
            steps = steps + 1;
            if (sideDistX < sideDistY)
            {
                sideDistX = sideDistX + deltaDistX;
                mapX = mapX + stepX;
                side = 0;
            }
            else
            {
                sideDistY = sideDistY + deltaDistY;
                mapY = mapY + stepY;
                side = 1;
            }
            
            if (mapX >= 0 && mapX < mapW && mapY >= 0 && mapY < mapH)
            {
                wallType = getMap(mapX, mapY);
                if (wallType > 0) hit = 1;
            }
            else
            {
                hit = 1;
                wallType = 1;
            }
        }
        
        var perpWallDist;
        if (side == 0)
        {
            if (abs(rayDirX) < 0.00001) perpWallDist = 0.00001;
            else perpWallDist = (mapX - posX + (1 - stepX) / 2) / rayDirX;
        }
        else
        {
            if (abs(rayDirY) < 0.00001) perpWallDist = 0.00001;
            else perpWallDist = (mapY - posY + (1 - stepY) / 2) / rayDirY;
        }
        
        if (perpWallDist <= 0.0001) perpWallDist = 0.0001;
        
        zBuffer[x] = perpWallDist; // Guardar para sprites
        
        var lineHeight = floor(renderH / perpWallDist);
        
        var drawStart = -lineHeight / 2 + renderH / 2;
        if (drawStart < 0) drawStart = 0;
        
        var drawEnd = lineHeight / 2 + renderH / 2;
        if (drawEnd >= renderH) drawEnd = renderH - 1;
        
        // Fog/distância
        var brightness = 1.0 / (1.0 + perpWallDist * perpWallDist * 0.02);
        if (brightness > 1.0) brightness = 1.0;
        
        var color = getWallColor(wallType, side, brightness);
        
        DrawLine(x, drawStart, x, drawEnd, color);
        
        // CHÃO COM REFLEXÃO SIMPLES (ray traced!)
        for (var y = drawEnd + 1; y < renderH; y = y + 4) // Skip pixels
        {
            var currentDist = renderH / (2.0 * y - renderH);
            
            var weight = currentDist / perpWallDist;
            
            var floorX = weight * (mapX - posX + (1 - stepX) / 2) + posX;
            var floorY = weight * (mapY - posY + (1 - stepY) / 2) + posY;
            
            var floorMapX = floor(floorX);
            var floorMapY = floor(floorY);
            
            // Checkerboard pattern
            var checker = (floorMapX + floorMapY) % 2;
            
            var floorBrightness = 1.0 / (1.0 + currentDist * currentDist * 0.05);
            
            var floorColor;
            if (checker == 0)
            {
                floorColor = Color(60 * floorBrightness, 60 * floorBrightness, 60 * floorBrightness, 255);
            }
            else
            {
                floorColor = Color(40 * floorBrightness, 40 * floorBrightness, 40 * floorBrightness, 255);
            }
            
            DrawPixel(x, y, floorColor);
        }
    }
    
    EndTextureMode();
}

// ==========================================
// MINIMAP
// ==========================================

def drawMinimap()
{
    var scale = 15;
    var offsetX = 10;
    var offsetY = 10;
    
    DrawRectangle(offsetX - 2, offsetY - 2, mapW * scale + 4, mapH * scale + 4, BLACK);
    
    for (var y = 0; y < mapH; y = y + 1)
    {
        for (var x = 0; x < mapW; x = x + 1)
        {
            var tile = getMap(x, y);
            if (tile > 0)
            {
                var c = getWallColor(tile, 0, 1.0);
                DrawRectangle(offsetX + x * scale, offsetY + y * scale, scale - 1, scale - 1, c);
            }
        }
    }
    
    var px = floor(posX * scale);
    var py = floor(posY * scale);
    DrawCircle(offsetX + px, offsetY + py, 3, RED);
    
    // Direção
    DrawLine(
        offsetX + px,
        offsetY + py,
        offsetX + px + dirX * 10,
        offsetY + py + dirY * 10,
        RED
    );
}

// ==========================================
// MAIN LOOP
// ==========================================

var target = LoadRenderTexture(renderW, renderH);
var src = Rectangle(0, 0, renderW, -renderH);
var dest = Rectangle(0, 0, screenW, screenH);
var origin = Vector2(0, 0);

while (!WindowShouldClose())
{
    // INPUT
    if (IsKeyDown(KEY_W))
    {
        if (getMap(floor(posX + dirX * moveSpeed), floor(posY)) == 0)
            posX = posX + dirX * moveSpeed;
        if (getMap(floor(posX), floor(posY + dirY * moveSpeed)) == 0)
            posY = posY + dirY * moveSpeed;
    }
    
    if (IsKeyDown(KEY_S))
    {
        if (getMap(floor(posX - dirX * moveSpeed), floor(posY)) == 0)
            posX = posX - dirX * moveSpeed;
        if (getMap(floor(posX), floor(posY - dirY * moveSpeed)) == 0)
            posY = posY - dirY * moveSpeed;
    }
    
    if (IsKeyDown(KEY_A))
    {
        var oldDirX = dirX;
        dirX = dirX * cos(rotSpeed) - dirY * sin(rotSpeed);
        dirY = oldDirX * sin(rotSpeed) + dirY * cos(rotSpeed);
        
        var oldPlaneX = planeX;
        planeX = planeX * cos(rotSpeed) - planeY * sin(rotSpeed);
        planeY = oldPlaneX * sin(rotSpeed) + planeY * cos(rotSpeed);
    }
    
    if (IsKeyDown(KEY_D))
    {
        var oldDirX = dirX;
        dirX = dirX * cos(-rotSpeed) - dirY * sin(-rotSpeed);
        dirY = oldDirX * sin(-rotSpeed) + dirY * cos(-rotSpeed);
        
        var oldPlaneX = planeX;
        planeX = planeX * cos(-rotSpeed) - planeY * sin(-rotSpeed);
        planeY = oldPlaneX * sin(-rotSpeed) + planeY * cos(-rotSpeed);
    }
    
    // RENDER
    castRays(target);
    
    BeginDrawing();
    ClearBackground(BLACK);
    
    var tex = GetRenderTextureTexture(target);
    DrawTexturePro(tex, src, dest, origin, 0.0, WHITE);
    
    drawMinimap();
    
    DrawText("WASD = Move | Paredes coloridas!", 10, screenH - 30, 16, WHITE);
    DrawFPS(screenW - 100, 10);
    
    EndDrawing();
}

CloseWindow();