// ============================================
// PLAY TRAINED AI PONG
// ============================================
// Carrega modelo treinado e permite jogar contra ele

require "raylib";
import math;
import raylib;
import file;
using raylib;

// ============================================
// NEURAL NETWORK (copy from newral.bu)
// ============================================

class NeuralNetwork
{
    var input_size;
    var hidden_size;
    var output_size;
    
    var weights_ih;
    var weights_ho;
    var bias_h;
    var bias_o;
    
    def init(inputs, hidden, outputs)
    {
        self.input_size = inputs;
        self.hidden_size = hidden;
        self.output_size = outputs;
        
        self.weights_ih = [];
        for (var i = 0; i < inputs; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < hidden; j = j + 1)
            {
                row.push(0);
            }
            self.weights_ih.push(row);
        }
        
        self.weights_ho = [];
        for (var i = 0; i < hidden; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < outputs; j = j + 1)
            {
                row.push(0);
            }
            self.weights_ho.push(row);
        }
        
        self.bias_h = [];
        for (var i = 0; i < hidden; i = i + 1)
        {
            self.bias_h.push(0);
        }
        
        self.bias_o = [];
        for (var i = 0; i < outputs; i = i + 1)
        {
            self.bias_o.push(0);
        }
    }
    
    def sigmoid(x)
    {
        return 1.0 / (1.0 + exp(-x));
    }
    
    def predict(inputs)
    {
        var hidden = [];
        for (var j = 0; j < self.hidden_size; j = j + 1)
        {
            var sum = self.bias_h[j];
            for (var i = 0; i < self.input_size; i = i + 1)
            {
                sum = sum + inputs[i] * self.weights_ih[i][j];
            }
            hidden.push(self.sigmoid(sum));
        }
        
        var outputs = [];
        for (var j = 0; j < self.output_size; j = j + 1)
        {
            var sum = self.bias_o[j];
            for (var i = 0; i < self.hidden_size; i = i + 1)
            {
                sum = sum + hidden[i] * self.weights_ho[i][j];
            }
            outputs.push(self.sigmoid(sum));
        }
        
        return outputs;
    }
    
    def load_from_file(filename)
    {
        var f = file.open(filename, "r");
        
        self.input_size = file.read_int(f);
        self.hidden_size = file.read_int(f);
        self.output_size = file.read_int(f);
        
        self.weights_ih = [];
        for (var i = 0; i < self.input_size; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < self.hidden_size; j = j + 1)
            {
                row.push(file.read_double(f));
            }
            self.weights_ih.push(row);
        }
        
        self.weights_ho = [];
        for (var i = 0; i < self.hidden_size; i = i + 1)
        {
            var row = [];
            for (var j = 0; j < self.output_size; j = j + 1)
            {
                row.push(file.read_double(f));
            }
            self.weights_ho.push(row);
        }
        
        self.bias_h = [];
        for (var i = 0; i < self.hidden_size; i = i + 1)
        {
            self.bias_h.push(file.read_double(f));
        }
        
        self.bias_o = [];
        for (var i = 0; i < self.output_size; i = i + 1)
        {
            self.bias_o.push(file.read_double(f));
        }
        
        file.close(f);
    }
}

// ============================================
// GAME CLASSES
// ============================================

class Paddle
{
    var x, y;
    var width, height;
    var speed;
    var score;
    
    def init(x, y)
    {
        self.x = x;
        self.y = y;
        self.width = 15;
        self.height = 80;
        self.speed = 400;
        self.score = 0;
    }
    
    def update(dir, dt)
    {
        self.y = self.y + dir * self.speed * dt;
        if (self.y < 0) self.y = 0;
        if (self.y > 600 - self.height) self.y = 600 - self.height;
    }
    
    def draw()
    {
        DrawRectangle(self.x, self.y, self.width, self.height, Color(255, 255, 255, 255));
    }
}

class Ball
{
    var x, y;
    var vx, vy;
    var size;
    var speed;
    
    def init()
    {
        self.size = 10;
        self.speed = 300;
        self.x = 400;
        self.y = 300;
        
        var angle = (floor(math.rand(60)) - 30) * 3.14159 / 180.0;
        var dir = 1.0;
        if (math.rand(2) == 0) dir = -1;
        
        self.vx = cos(angle) * self.speed * dir;
        self.vy = sin(angle) * self.speed;
    }
    
    def reset()
    {
        self.x = 400;
        self.y = 300;
        
        var angle = (floor(math.rand(60)) - 30) * 3.14159 / 180.0;
        var dir = 1.0;
        if (math.rand(2) == 0) dir = -1;
        
        self.vx = cos(angle) * self.speed * dir;
        self.vy = sin(angle) * self.speed;
    }
    
    def update(dt, paddle_left, paddle_right)
    {
        self.x = self.x + self.vx * dt;
        self.y = self.y + self.vy * dt;
        
        if (self.y < 0 || self.y > 600 - self.size)
        {
            self.vy = -self.vy;
        }
        
        if (self.x < paddle_left.x + paddle_left.width &&
            self.x + self.size > paddle_left.x &&
            self.y < paddle_left.y + paddle_left.height &&
            self.y + self.size > paddle_left.y)
        {
            self.vx = abs(self.vx);
            var hitPos = (self.y - paddle_left.y) / paddle_left.height - 0.5;
            self.vy = hitPos * 400;
        }
        
        if (self.x < paddle_right.x + paddle_right.width &&
            self.x + self.size > paddle_right.x &&
            self.y < paddle_right.y + paddle_right.height &&
            self.y + self.size > paddle_right.y)
        {
            self.vx = -abs(self.vx);
            var hitPos = (self.y - paddle_right.y) / paddle_right.height - 0.5;
            self.vy = hitPos * 400;
        }
        
        if (self.x < 0)
        {
            paddle_right.score = paddle_right.score + 1;
            self.reset();
            return 1;
        }
        
        if (self.x > 800)
        {
            paddle_left.score = paddle_left.score + 1;
            self.reset();
            return -1;
        }
        
        return 0;
    }
    
    def draw()
    {
        DrawRectangle(self.x, self.y, self.size, self.size, Color(255, 255, 255, 255));
    }
}

// ============================================
// MAIN
// ============================================

// Check if weights file exists
if (!file.exists("pong_weights.nn"))
{
    print("âŒ Nenhum modelo treinado encontrado!");
    print("   Execute 'newral.bu' para treinar o modelo primeiro.");
}
else
{
    print("âœ… Carregando modelo treinado...");
    
    var brain = NeuralNetwork(5, 6, 3);
    brain.load_from_file("pong_weights.nn");
    print("âœ… Modelo carregado com sucesso!");
    print("");
    print("ðŸŽ® CONTROLES:");
    print("   Seta CIMA/BAIXO = Controlar pÃ¡ direita");
    print("   ESC = Sair");
    print("");
    
    InitWindow(800, 600, "Treined AI Pong - Play vs AI");
    SetTargetFPS(60);
    
    var paddle_ai = Paddle(30, 260);
    var paddle_player = Paddle(755, 260);
    var ball = Ball();
    var game_time = 0.0;
    
    while (!WindowShouldClose())
    {
        if (IsKeyPressed(KEY_ESCAPE)) break;
        
        var dt = GetFrameTime();
        game_time = game_time + dt;
        
        // AI thinks
        var inputs = [
            paddle_ai.y / 600.0,
            ball.x / 800.0,
            ball.y / 600.0,
            ball.vx / 400.0,
            ball.vy / 400.0
        ];
        
        var outputs = brain.predict(inputs);
        var maxIdx = 0;
        
        // Only 2 actions: UP (0) and DOWN (1)
        if (outputs[1] > outputs[0])
        {
            ai_action = 1; // DOWN
        }
        else
        {
            ai_action = -1; // UP
        }
        
        // Update
        paddle_ai.update(ai_action, dt);
        
        // Player controls
        if (IsKeyDown(KEY_UP)) paddle_player.update(-1, dt);
        if (IsKeyDown(KEY_DOWN)) paddle_player.update(1, dt);
        
        ball.update(dt, paddle_ai, paddle_player);
        
        // Draw
        BeginDrawing();
        ClearBackground(Color(0, 0, 0, 255));
        
        paddle_ai.draw();
        paddle_player.draw();
        ball.draw();
        
        // Center line
        for (var i = 0; i < 600; i = i + 20)
        {
            DrawRectangle(397, i, 6, 10, Color(100, 100, 100, 255));
        }
        
        // Draw scores
        DrawText(format("AI: {}", paddle_ai.score), 150, 20, 32, Color(100, 200, 255, 255));
        DrawText(format("You: {}", paddle_player.score), 550, 20, 32, Color(255, 200, 100, 255));
        
        DrawText("Use ARROW KEYS to play", 230, 560, 16, Color(200, 200, 200, 255));
        
        DrawFPS(700, 20);
        
        EndDrawing();
    }
    
    CloseWindow();
    print("âœ… Obrigado por jogar!");
}
