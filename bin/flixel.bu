 

def checkOverlap(obj1, obj2)
{
    return obj1.x < obj2.x + obj2.width &&
           obj1.x + obj1.width > obj2.x &&
           obj1.y < obj2.y + obj2.height &&
           obj1.y + obj1.height > obj2.y;
}


def computeVelocity(velocity, acceleration, drag, max, elapsed)
{
    if (acceleration != 0.0)
    {
        velocity = velocity + acceleration * elapsed;
    }
    else if (drag != 0.0)
    {
        var d = drag * elapsed;
        if (velocity - d > 0.0)
        {
            velocity = velocity - d;
        }
        else if (velocity + d < 0.0)
        {
            velocity = velocity + d;
        }
        else
        {
            velocity = 0.0;
        }
    }
    
    if (velocity != 0.0)
    {
        if (velocity > max)
        {
            velocity = max;
        }
        else if (velocity < -max)
        {
            velocity = -max;
        }
    }
    
    return velocity;
}

 

class Object
{
    var x, y;
    var lastX, lastY;
    var width, height;
    
    var velocityX, velocityY;
    var accelerationX, accelerationY;
    var dragX, dragY;
    var maxVelocityX, maxVelocityY;
    
    var mass;
    var elasticity;
    var immovable;
    
    var touching; // 0=NONE, 1=UP, 2=DOWN, 4=LEFT, 8=RIGHT
    var allowCollisions; // Same flags
    
    var active;
    var exists;
    
    def init(x, y, w, h)
    {
        self.x = x;
        self.y = y;
        self.lastX = x;
        self.lastY = y;
        self.width = w;
        self.height = h;
        
        self.velocityX = 0.0;
        self.velocityY = 0.0;
        self.accelerationX = 0.0;
        self.accelerationY = 0.0;
        self.dragX = 0.0;
        self.dragY = 0.0;
        self.maxVelocityX = 10000.0;
        self.maxVelocityY = 10000.0;
        
        self.mass = 1.0;
        self.elasticity = 0.0;
        self.immovable = false;
        
        self.touching = 0;
        self.allowCollisions = 15; // All directions
        
        self.active = true;
        self.exists = true;
    }
    
    def update(elapsed)
    {
        if (!self.active)
        {
            return;
        }
        
        self.updateMotion(elapsed);
    }
    
    def updateMotion(elapsed)
    {
        // Save last position
        self.lastX = self.x;
        self.lastY = self.y;
        
        // X axis (Semi-implicit Euler)
        var velocityDelta = (computeVelocity(self.velocityX, self.accelerationX, self.dragX, self.maxVelocityX, elapsed) - self.velocityX) / 2.0;
        self.velocityX = self.velocityX + velocityDelta;
        var delta = self.velocityX * elapsed;
        self.velocityX = self.velocityX + velocityDelta;
        self.x = self.x + delta;
        
        // Y axis
        velocityDelta = (computeVelocity(self.velocityY, self.accelerationY, self.dragY, self.maxVelocityY, elapsed) - self.velocityY) / 2.0;
        self.velocityY = self.velocityY + velocityDelta;
        delta = self.velocityY * elapsed;
        self.velocityY = self.velocityY + velocityDelta;
        self.y = self.y + delta;
        
        // Clear touching flags
        self.touching = 0;
    }
    
    def draw()
    {
        // Override in subclasses
    }
}


 

var OVERLAP_BIAS = 4.0;

// Flags
var NONE = 0;
var UP = 1;
var DOWN = 2;
var LEFT = 4;
var RIGHT = 8;
var ANY = 15;

def separate(obj1, obj2)
{
    var separatedX = separateX(obj1, obj2);
    var separatedY = separateY(obj1, obj2);
    return separatedX || separatedY;
}

def separateX(obj1, obj2)
{
    // Can't separate two immovable objects
    if (obj1.immovable && obj2.immovable)
    {
        return false;
    }
    
    var overlap = 0.0;
    var obj1delta = obj1.x - obj1.lastX;
    var obj2delta = obj2.x - obj2.lastX;
    
    if (obj1delta != obj2delta)
    {
        // Check if X hulls overlap (swept AABB)
        var obj1deltaAbs = abs(obj1delta);
        var obj2deltaAbs = abs(obj2delta);
        
        // Build swept rectangles
        var obj1rectX = obj1.x;
        if (obj1delta < 0.0) obj1rectX = obj1rectX + obj1delta;
        var obj1rectY = obj1.lastY;
        var obj1rectW = obj1.width + obj1deltaAbs;
        var obj1rectH = obj1.height;
        
        var obj2rectX = obj2.x;
        if (obj2delta < 0.0) obj2rectX = obj2rectX + obj2delta;
        var obj2rectY = obj2.lastY;
        var obj2rectW = obj2.width + obj2deltaAbs;
        var obj2rectH = obj2.height;
        
        // AABB overlap check
        if ((obj1rectX + obj1rectW > obj2rectX) && 
            (obj1rectX < obj2rectX + obj2rectW) && 
            (obj1rectY + obj1rectH > obj2rectY) && 
            (obj1rectY < obj2rectY + obj2rectH))
        {
            var maxOverlap = obj1deltaAbs + obj2deltaAbs + OVERLAP_BIAS;
            
            // Calculate overlap direction
            if (obj1delta > obj2delta)
            {
                overlap = obj1.x + obj1.width - obj2.x;
                if ((overlap > maxOverlap) || (obj1.allowCollisions & RIGHT) == 0 || (obj2.allowCollisions & LEFT) == 0)
                {
                    overlap = 0.0;
                }
                else
                {
                    obj1.touching = obj1.touching | RIGHT;
                    obj2.touching = obj2.touching | LEFT;
                }
            }
            else if (obj1delta < obj2delta)
            {
                overlap = obj1.x - obj2.width - obj2.x;
                if ((-overlap > maxOverlap) || (obj1.allowCollisions & LEFT) == 0 || (obj2.allowCollisions & RIGHT) == 0)
                {
                    overlap = 0.0;
                }
                else
                {
                    obj1.touching = obj1.touching | LEFT;
                    obj2.touching = obj2.touching | RIGHT;
                }
            }
        }
    }
    
    // Resolve overlap
    if (overlap != 0.0)
    {
        var obj1v = obj1.velocityX;
        var obj2v = obj2.velocityX;
        
        if (!obj1.immovable && !obj2.immovable)
        {
            // Both movable
            overlap = overlap * 0.5;
            obj1.x = obj1.x - overlap;
            obj2.x = obj2.x + overlap;
            
            // Exchange velocities with mass
            var obj1velocity = sqrt((obj2v * obj2v * obj2.mass) / obj1.mass);
            if (obj2v < 0.0) obj1velocity = -obj1velocity;
            
            var obj2velocity = sqrt((obj1v * obj1v * obj1.mass) / obj2.mass);
            if (obj1v < 0.0) obj2velocity = -obj2velocity;
            
            var average = (obj1velocity + obj2velocity) * 0.5;
            obj1velocity = obj1velocity - average;
            obj2velocity = obj2velocity - average;
            
            obj1.velocityX = average + obj1velocity * obj1.elasticity;
            obj2.velocityX = average + obj2velocity * obj2.elasticity;
        }
        else if (!obj1.immovable)
        {
            // Only obj1 movable
            obj1.x = obj1.x - overlap;
            obj1.velocityX = obj2v - obj1v * obj1.elasticity;
        }
        else if (!obj2.immovable)
        {
            // Only obj2 movable
            obj2.x = obj2.x + overlap;
            obj2.velocityX = obj1v - obj2v * obj2.elasticity;
        }
        
        return true;
    }
    
    return false;
}

def separateY(obj1, obj2)
{
    if (obj1.immovable && obj2.immovable)
    {
        return false;
    }
    
    var overlap = 0.0;
    var obj1delta = obj1.y - obj1.lastY;
    var obj2delta = obj2.y - obj2.lastY;
    
    if (obj1delta != obj2delta)
    {
        var obj1deltaAbs = abs(obj1delta);
        var obj2deltaAbs = abs(obj2delta);
        
        var obj1rectX = obj1.x;
        var obj1rectY = obj1.y;
        if (obj1delta < 0.0) obj1rectY = obj1rectY + obj1delta;
        var obj1rectW = obj1.width;
        var obj1rectH = obj1.height + obj1deltaAbs;
        
        var obj2rectX = obj2.x;
        var obj2rectY = obj2.y;
        if (obj2delta < 0.0) obj2rectY = obj2rectY + obj2delta;
        var obj2rectW = obj2.width;
        var obj2rectH = obj2.height + obj2deltaAbs;
        
        if ((obj1rectX + obj1rectW > obj2rectX) && 
            (obj1rectX < obj2rectX + obj2rectW) && 
            (obj1rectY + obj1rectH > obj2rectY) && 
            (obj1rectY < obj2rectY + obj2rectH))
        {
            var maxOverlap = obj1deltaAbs + obj2deltaAbs + OVERLAP_BIAS;
            
            if (obj1delta > obj2delta)
            {
                overlap = obj1.y + obj1.height - obj2.y;
                if ((overlap > maxOverlap) || (obj1.allowCollisions & DOWN) == 0 || (obj2.allowCollisions & UP) == 0)
                {
                    overlap = 0.0;
                }
                else
                {
                    obj1.touching = obj1.touching | DOWN;
                    obj2.touching = obj2.touching | UP;
                }
            }
            else if (obj1delta < obj2delta)
            {
                overlap = obj1.y - obj2.height - obj2.y;
                if ((-overlap > maxOverlap) || (obj1.allowCollisions & UP) == 0 || (obj2.allowCollisions & DOWN) == 0)
                {
                    overlap = 0.0;
                }
                else
                {
                    obj1.touching = obj1.touching | UP;
                    obj2.touching = obj2.touching | DOWN;
                }
            }
        }
    }
    
    if (overlap != 0.0)
    {
        var obj1v = obj1.velocityY;
        var obj2v = obj2.velocityY;
        
        if (!obj1.immovable && !obj2.immovable)
        {
            overlap = overlap * 0.5;
            obj1.y = obj1.y - overlap;
            obj2.y = obj2.y + overlap;
            
            var obj1velocity = sqrt((obj2v * obj2v * obj2.mass) / obj1.mass);
            if (obj2v < 0.0) obj1velocity = -obj1velocity;
            
            var obj2velocity = sqrt((obj1v * obj1v * obj1.mass) / obj2.mass);
            if (obj1v < 0.0) obj2velocity = -obj2velocity;
            
            var average = (obj1velocity + obj2velocity) * 0.5;
            obj1velocity = obj1velocity - average;
            obj2velocity = obj2velocity - average;
            
            obj1.velocityY = average + obj1velocity * obj1.elasticity;
            obj2.velocityY = average + obj2velocity * obj2.elasticity;
        }
        else if (!obj1.immovable)
        {
            obj1.y = obj1.y - overlap;
            obj1.velocityY = obj2v - obj1v * obj1.elasticity;
        }
        else if (!obj2.immovable)
        {
            obj2.y = obj2.y + overlap;
            obj2.velocityY = obj1v - obj2v * obj2.elasticity;
        }
        
        return true;
    }
    
    return false;
}
 
 
class Group
{
    var members;
    var length;
    
    def init()
    {
        self.members = [];
        self.length = 0;
    }
    
    def add(obj)
    {
        self.members.push(obj);
        self.length = len(self.members);
        return obj;
    }
    
    def remove(obj)
    {
        var n = len(self.members);
        for (var i = 0; i < n; i = i + 1)
        {
            if (self.members[i] == obj)
            {
                var lastIndex = n - 1;
                if (i != lastIndex)
                {
                    self.members[i] = self.members[lastIndex];
                }
                self.members.pop();
                self.length = n - 1;
                return;
            }
        }
    }

    
    def update(elapsed)
    {
        for (var i = 0; i < len(self.members); i = i + 1)
        {
            var obj = self.members[i];
            if (obj.active && obj.exists)
            {
                obj.update(elapsed);
            }
        }
    }
    
    def draw()
    {
        for (var i = 0; i < len(self.members); i = i + 1)
        {
            var obj = self.members[i];
            if (obj.exists)
            {
                obj.draw();
            }
        }
    }
    
    def clear()
    {
        self.members = [];
        self.length = 0;
    }
    
    def getFirstAvailable()
    {
        for (var i = 0; i < len(self.members); i = i + 1)
        {
            if (!self.members[i].exists)
            {
                return self.members[i];
            }
        }
        return nil;
    }
    
    def recycle(classType, x, y, w, h)
    {
        // Find dead object to reuse
        var obj = self.getFirstAvailable();
        
        if (obj == nil)
        {
            // Create new if none available
            obj = classType(x, y, w, h);
            self.add(obj);
        }
        else
        {
            // Reset existing
            obj.x = x;
            obj.y = y;
            obj.exists = true;
            obj.active = true;
            obj.velocityX = 0.0;
            obj.velocityY = 0.0;
        }
        
        return obj;
    }
} 


// ============================================
// World - Manages all objects and collisions
// ============================================

class World
{
    var objects;      // All game objects
 
    var gravity;      // World gravity
    
    def init()
    {
        self.objects = [];
  
        self.gravity = 600.0;
    }
    
    def add(obj)
    {
        self.objects.push(obj);
        return obj;
    }
    
    def remove(obj)
    {
        var n = len(self.objects);
        for (var i = 0; i < n; i = i + 1)
        {
            if (self.objects[i] == obj)
            {
                var lastIndex = n - 1;
                if (i != lastIndex)
                {
                    self.objects[i] = self.objects[lastIndex];
                }
                self.objects.pop();
                return;
            }
        }
    }

    
    def update(elapsed)
    {
        // Update all objects
        for (var i = 0; i < len(self.objects); i = i + 1)
        {
            var obj = self.objects[i];
            
            if (obj.active && obj.exists)
            {
                obj.update(elapsed);
            }
        }
    }
    
    def draw()
    {
        // Draw all objects
        for (var i = 0; i < len(self.objects); i = i + 1)
        {
            var obj = self.objects[i];
            
            if (obj.exists)
            {
                obj.draw();
            }
        }
    }
    
    // Collide two groups
    def collide(group1, group2)
    {
        var collided = false;
        
        for (var i = 0; i < len(group1); i = i + 1)
        {
            var obj1 = group1[i];
            
            if (!obj1.exists || !obj1.active)
            {
                continue;
            }
            
            for (var j = 0; j < len(group2); j = j + 1)
            {
                var obj2 = group2[j];
                
                if (!obj2.exists || !obj2.active)
                {
                    continue;
                }
                
                // Don't collide with self
                if (obj1 == obj2)
                {
                    continue;
                }
                
                if (separate(obj1, obj2))
                {
                    collided = true;
                }
            }
        }
        
        return collided;
    }
    
    // Overlap check without separation
    def overlap(group1, group2, callback)
    {
        var overlapped = false;
        
        for (var i = 0; i < len(group1); i = i + 1)
        {
            var obj1 = group1[i];
            
            if (!obj1.exists)
            {
                continue;
            }
            
            for (var j = 0; j < len(group2); j = j + 1)
            {
                var obj2 = group2[j];
                
                if (!obj2.exists || obj1 == obj2)
                {
                    continue;
                }
                
                if (checkOverlap(obj1, obj2))
                {
                    overlapped = true;
                    
                    // Call callback if provided
                    if (callback != nil)
                    {
                        callback(obj1, obj2);
                    }
                }
            }
        }
        
        return overlapped;
    }
    
  
}



class Sprite : Object
{
    var color;
    
    def init(x, y, w, h)
    {
        super.init(x, y, w, h);
        self.color = Color(100 + math.rand(155), 100 + math.rand(155), 100 + math.rand(155), 255);
    }
     
    
    def draw()
    {
        if (!self.exists)
        {
            return;
        }
        
        DrawRectangle(self.x, self.y, self.width, self.height, self.color);
        DrawRectangleLines(self.x, self.y, self.width, self.height, Color(255, 255, 255, 100));
    }
}

class Particle : Sprite
{
    var life;
    
 
    def init(x, y, w, h)
    {
        super.init(x, y, w, h);
    }
    
    def update(elapsed)
    {
        super.update(elapsed);
        self.life = self.life - elapsed;
        
        if (self.life <= 0.0)
        {
            self.exists = false;
        }
    }
}

class Emitter : Group
{
    def init()
    {
        super.init();
    }
    
 
    
    def explode(x, y, count)
    {
        for (var i = 0; i < count; i = i + 1)
        {
            // Recycle or create particle
            var p = self.recycle(Particle, x, y, 4, 4);
            
            p.active = true;
            p.exists = true;
            p.color = Color(255, 100 + math.rand(155), 0, 255);
            p.life = 0.5 + (math.rand(50) / 100.0); // 0.5 to 1.0 seconds
            
            // Explosion velocity
            p.velocityX = (math.rand(400) - 200);
            p.velocityY = (math.rand(400) - 200);
            p.accelerationY = 800.0; // Gravity
            p.dragX = 100.0;
        }
    }
}
 
